<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flutter定制上下拉刷新功能</title>
    <url>/2020/07/09/Flutter%E5%AE%9A%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>项目中需要定制一个基于Gif图片的下拉刷新功能，调研发现<br>Flutter支持上下拉刷新的框架很多，其中有两个比较有名的有<a href="https://pub.dev/packages/flutter_easyrefresh" target="_blank" rel="noopener">flutter_easyrefresh</a>和<a href="https://pub.dev/packages/pull_to_refresh" target="_blank" rel="noopener">pull_to_refresh</a>，两个框架功能都很强大，都能满足需求，其中flutter_easyrefresh在github的star更多，lib包大小为<code>644KB</code>，pull_to_refresh在pub.dev的评分更高，lib包大小为<code>172KB</code>，综合考虑后，选择基于pull_to_refresh来实现框架功能。</p>
<a id="more"></a>

<h2 id="下拉刷新GIF图片的生成"><a href="#下拉刷新GIF图片的生成" class="headerlink" title="下拉刷新GIF图片的生成"></a>下拉刷新GIF图片的生成</h2><p>下拉刷新需要控制Gif图片的播放，所以需要引入组件<a href="https://pub.dev/packages/flutter_gifimage" target="_blank" rel="noopener">flutter_gifimage</a>，gifimage支持加载本地和网络的gif图片，但是不支持加载图片列表的方式来执行gif动画，所以我们需要将图片列表生成为gif图片（UI小姐姐只给了图片列表）。<br>网上有很多网站可以生成gif，但是都有图片数量限制。 下载一个生成gif的软件来生成又显得很麻烦，我们选择使用Python的Pillow库来创建gif图片。Pillow是PIL的python3版本，功能强大，可以很好的完成需求。创建脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_frame</span><span class="params">(path)</span>:</span></span><br><span class="line">    png = Image.open(path).convert(<span class="string">'RGBA'</span>)</span><br><span class="line">    background = Image.new(<span class="string">'RGBA'</span>, png.size, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>))</span><br><span class="line">    alpha_composite = Image.alpha_composite(background, png)</span><br><span class="line">    <span class="keyword">return</span> alpha_composite</span><br><span class="line"></span><br><span class="line">image_list = []</span><br><span class="line">im0 = gen_frame(<span class="string">'refresh_images/Loading_00@2x.png'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">57</span>):</span><br><span class="line">    path = <span class="string">'refresh_images/Loading_0'</span> + str(i) + <span class="string">"@2x.png"</span></span><br><span class="line">    image_list.append(gen_frame(path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成透明图片需要加两个个参数：transparency=0, disposal=2</span></span><br><span class="line">im0.save(<span class="string">'GIF.gif'</span>, save_all=<span class="literal">True</span>, append_images=image_list, loop=<span class="number">0</span>, duration=<span class="number">34</span>, transparency=<span class="number">0</span>, disposal=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述脚本对Gif背景进行了处理，以生成一张透明背景的gif图片</p>
</blockquote>
<h2 id="Gif下拉刷新组件头部的实现"><a href="#Gif下拉刷新组件头部的实现" class="headerlink" title="Gif下拉刷新组件头部的实现"></a>Gif下拉刷新组件头部的实现</h2><p>pull_to_refresh中提供了抽象类RefreshIndicator与RefreshIndicator，与material提供的重名，所以需要隐藏。 import部分代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span></span><br><span class="line">    <span class="keyword">hide</span> RefreshIndicator, RefreshIndicatorState;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br></pre></td></tr></table></figure>

<p>最终下拉刷新的Header实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span></span><br><span class="line">    <span class="keyword">hide</span> RefreshIndicator, RefreshIndicatorState;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_gifimage/flutter_gifimage.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GifHeader</span> <span class="keyword">extends</span> <span class="title">RefreshIndicator</span> </span>&#123;</span><br><span class="line">  GifHeader() : <span class="keyword">super</span>(height: <span class="number">72.0</span>, refreshStyle: RefreshStyle.Follow);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GifHeaderState createState() =&gt; _GifHeaderState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GifHeaderState</span> <span class="keyword">extends</span> <span class="title">RefreshIndicatorState</span>&lt;<span class="title">GifHeader</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  GifController _gifController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">//value可以理解成Gif图片里面的第几帧</span></span><br><span class="line">    _gifController = GifController(</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onModeChange(RefreshStatus mode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == RefreshStatus.refreshing) &#123;</span><br><span class="line">     <span class="comment">//min和max都可以理解成Gif图片里面的第几帧，这里表示低0帧到第44帧</span></span><br><span class="line">      _gifController.repeat(</span><br><span class="line">          min: <span class="number">0</span>, max: <span class="number">44</span>, period: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onModeChange(mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; endRefresh() &#123;</span><br><span class="line">    <span class="keyword">return</span> _gifController.animateTo(<span class="number">44</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> resetValue() &#123;</span><br><span class="line">    <span class="comment">// reset not ok , the plugin need to update lowwer</span></span><br><span class="line">    _gifController.value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">super</span>.resetValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildContent(BuildContext context, RefreshStatus mode) &#123;</span><br><span class="line">    <span class="keyword">return</span> GifImage(</span><br><span class="line">      image: AssetImage(<span class="string">"images/pull_refresh.gif"</span>),</span><br><span class="line">      controller: _gifController,</span><br><span class="line">      height: <span class="number">72.0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _gifController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置Gif的<code>value</code>（帧）时，不能超过Gif的最大帧数，不然超出的帧数是显示一个有颜色的空白页面</p>
</blockquote>
<h2 id="集成进入项目"><a href="#集成进入项目" class="headerlink" title="集成进入项目"></a>集成进入项目</h2><p>pull_to_refresh提供了全局的统一配置类<code>RefreshConfiguration</code>，用它来包裹MaterialApp则可以全局生效，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RefreshConfiguration(</span><br><span class="line">      headerBuilder: () =&gt; GifHeader(), <span class="comment">// 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个</span></span><br><span class="line">      footerBuilder: () =&gt; ClassicFooter(), <span class="comment">// 配置默认底部指示器</span></span><br><span class="line">      headerTriggerDistance: <span class="number">72.0</span>, <span class="comment">// 头部触发刷新的越界距离</span></span><br><span class="line">      <span class="comment">//  springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9),         // 自定义回弹动画,三个属性值意义请查询flutter api</span></span><br><span class="line">      maxOverScrollExtent: <span class="number">100</span>, <span class="comment">//头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性</span></span><br><span class="line">      maxUnderScrollExtent: <span class="number">0</span>, <span class="comment">// 底部最大可以拖动的范围</span></span><br><span class="line">      enableScrollWhenRefreshCompleted:</span><br><span class="line">          <span class="keyword">true</span>, <span class="comment">//这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true</span></span><br><span class="line">      enableLoadingWhenFailed: <span class="keyword">true</span>, <span class="comment">//在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多</span></span><br><span class="line">      hideFooterWhenNotFull: <span class="keyword">false</span>, <span class="comment">// Viewport不满一屏时,禁用上拉加载更多功能</span></span><br><span class="line">      <span class="comment">// 当列表无法充满全屏的时候，加载更多跟在列表后面</span></span><br><span class="line">      shouldFooterFollowWhenNotFull: (status) =&gt; <span class="keyword">true</span>,</span><br><span class="line">      enableBallisticLoad: <span class="keyword">true</span>, <span class="comment">// 可以通过惯性滑动触发加载更多</span></span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">        home: HomePage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局配置好后，则可以在列表进行集成了：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:my_flutter/message/notice_list_page/notice_ist_cell.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:my_flutter/message/notice_list_page/notice_list_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoticeListPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NoticeListPageState createState() =&gt; _NoticeListPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NoticeListPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NoticeListPage</span>&gt; </span>&#123;</span><br><span class="line">  RefreshController _refreshController =</span><br><span class="line">      RefreshController(initialRefresh: <span class="keyword">true</span>);</span><br><span class="line">  <span class="built_in">List</span>&lt;NoticeListModel&gt; list = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onRefresh() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// monitor network fetch</span></span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line">    <span class="comment">// 这里可以添加逻辑判断，如果无更多数据：_refreshController.loadNoData();</span></span><br><span class="line">    <span class="comment">// 如果加载失败： 设置_refreshController.refreshFailed()</span></span><br><span class="line">    _refreshController.refreshCompleted();</span><br><span class="line">    </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      list = _getList();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onLoading() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// monitor network fetch</span></span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>));</span><br><span class="line">    <span class="comment">// if failed,use loadFailed(),if no data return,use LoadNodata()</span></span><br><span class="line">    _refreshController.loadComplete();</span><br><span class="line">    <span class="keyword">if</span> (mounted)</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        list.addAll(_getList());</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SmartRefresher(</span><br><span class="line">        enablePullDown: <span class="keyword">true</span>,</span><br><span class="line">        enablePullUp: list.length &gt; <span class="number">0</span>,</span><br><span class="line">        controller: _refreshController,</span><br><span class="line">        onRefresh: _onRefresh,</span><br><span class="line">        onLoading: _onLoading,</span><br><span class="line">        child: ListView.builder(</span><br><span class="line">          itemBuilder: (c, i) =&gt; NoticeListCell(model: list[i]),</span><br><span class="line">          itemExtent: <span class="number">100.0</span>,</span><br><span class="line">          itemCount: list.length,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;NoticeListModel&gt; _getList() &#123;</span><br><span class="line">      <span class="keyword">return</span> [NoticeListModel(),NoticeListModel()];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Github Pages搭建博客及使用</title>
    <url>/2018/01/08/Github-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文基于Hexo进行说明。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>确保电脑中是安装有<code>Node.js</code>、<code>Git</code></li>
<li>hexo安装：<code>npm install -g hexo-cli</code></li>
</ul>
<h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>在 _config.yml 中修改大部份的配置。配置说明见<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官方文档</a></p>
<p>主要配置参数：</p>
<ul>
<li>网站</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title	网站标题</span><br><span class="line">subtitle	网站副标题</span><br><span class="line">description	网站描述</span><br><span class="line">author	您的名字</span><br><span class="line">language	网站使用的语言</span><br></pre></td></tr></table></figure>

<ul>
<li>配置对应的Github Pages</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/StudyData/StudyData.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<ul>
<li>网址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;blog.devlxx.com</span><br></pre></td></tr></table></figure>

<ul>
<li>配置评论</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disqus_shortname: devlxx</span><br><span class="line">disqus: true</span><br></pre></td></tr></table></figure>

<h3 id="日常用法"><a href="#日常用法" class="headerlink" title="日常用法"></a>日常用法</h3><ul>
<li>创建新博文：<code>$ hexo new [layout] &lt;title&gt;</code>，如<code>hexo new &quot;Github Pages搭建博客及使用</code>，执行后，会在<code>source/_posts</code>目录下创建<code>hexo new &quot;Github Pages搭建博客及使用.md</code>文件<ul>
<li>创建草稿使用特殊布局：<code>draft</code>, 建立时会保存在<code>source/_drafts</code>文件夹，可以执行<code>$ hexo publish [layout] &lt;title&gt;</code>移动到<code>source/_posts</code>目录</li>
</ul>
</li>
<li>生成静态文件：<code>hexo generate</code></li>
<li>本地查看：<code>hexo server -p 5000</code>，执行后，打开<code>http://localhost:5000/</code>即可查看博客效果。</li>
<li>部署：<code>hexo deploy</code></li>
<li>可以通过在文章中插入<code>&lt;!--more--&gt;</code>来设置在文章列表中展示的内容。<code>&lt;!--more--&gt;</code>上面内容均会展示在在列表中，下面的会被收起。（for <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a> 主题）</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h4><p>使用自己的域名逼格更高，域名绑定需要做两部分工作。</p>
<h5 id="Github-Pages域名绑定设置"><a href="#Github-Pages域名绑定设置" class="headerlink" title="Github Pages域名绑定设置"></a>Github Pages域名绑定设置</h5><p>使用一个自定义域名去重定向你的 GitHub Pages，你必须创建和提交一个包含自定义域名的 CNAME 文件到你的 GitHub Pages 存储库中。</p>
<ul>
<li>进入Github Pages仓库：<code>https://github.com/StudyData/StudyData.github.io</code></li>
<li>添加一个新文件，命名为 CNAME （全部大写！），放在 Pages 分支的根目录下。</li>
<li>在新文件中，添加一行，指定自定义域名的空子域名。例如，使用 blog.example.com 而不是 <a href="https://blog.example.com" target="_blank" rel="noopener">https://blog.example.com</a> 。</li>
</ul>
<blockquote>
<p>请注意，在 CNAME 文件中只允许有一个域名。</p>
</blockquote>
<h5 id="域名服务商设置"><a href="#域名服务商设置" class="headerlink" title="域名服务商设置"></a>域名服务商设置</h5><p>以万网为例</p>
<ul>
<li>点击添加解析</li>
<li>记录类型：<code>CHAME</code></li>
<li>主机记录：<code>blog</code></li>
<li>记录值：<code>studydata.github.io</code></li>
</ul>
<h4 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h4><p>hexo支持各种评论，常见的有1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment等，评估那个适合自己，申请相关服务后在根目录的<code>_config.yml</code>中进行配置，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">devlxx</span></span><br><span class="line"><span class="attr">disqus:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>畅言对国内支持较好，可以微信，QQ登录，配置如下：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#畅言app id</span></span><br><span class="line"><span class="attr">changyan_appid:</span> <span class="string">'xxxx'</span></span><br><span class="line"><span class="comment">#畅言app key</span></span><br><span class="line"><span class="attr">changyan_conf:</span> <span class="string">'xxxxxxxxxxxxxxxxxx'</span></span><br></pre></td></tr></table></figure>

<h4 id="资源文件使用"><a href="#资源文件使用" class="headerlink" title="资源文件使用"></a>资源文件使用</h4><ul>
<li>在根目录的<code>_config.yml</code>中进行配置:</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个<code>markdown</code>文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们</p>
<ul>
<li>也可以在source目录下创建一个资源目录<code>assets</code>，然后通过类似于<code>![](/assets/image.jpg)</code>的方法访问它们。</li>
</ul>
<h4 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h4><p>主题都放置在<code>themes/</code>目录下，一般从<a href="https://www.github.com" target="_blank" rel="noopener">github</a>上找到自己心仪的主题，clone到此目录下。然后在<code>_config.yml</code>配置相应的主题。 如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-yilia</span></span><br></pre></td></tr></table></figure>
<p><code>hexo-theme-yilia</code>为clone下来的项目的文件名。</p>
<h4 id="如何使用主题"><a href="#如何使用主题" class="headerlink" title="如何使用主题"></a>如何使用主题</h4><p>每个主题基本都有自己说明文档，一般通过修改主题中的<code>themes/theme_name/_config.yml</code>文件来实现主题修改。</p>
<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><ul>
<li><p>有人会把整个<code>hexo目录</code>放入<code>GitHub Pages</code>仓库，这是不对的，指定<code>hexo d</code>会将生成的博文相关静态文件上传到<code>Github Pages</code>，hexo目录一般用另外一个私有仓库放置，里面可以有你的草稿，主题等。</p>
</li>
<li><p>执行<code>hexo d</code>会将仓库先清空，如果有加入<code>CNAME</code>文件也会被清空，可以将<code>CNAME</code>放入<code>source/</code>目录下，上传的时候会一并传上去。</p>
</li>
<li><p>执行<code>hexo g</code>出现警告<code>WARN  No layout:xxx</code>，然后执行<code>hexo s</code>运行本地博客无内容。解决方法：</p>
<ul>
<li>是否配置的主题在<code>theme</code>下存在，检查下<code>themes/themeName/layout/</code>文件夹里是否有<code>index.js</code>文件，以及目录结构是否与实际主题的layout保持一致</li>
</ul>
</li>
<li><p>执行<code>hexo g</code>报错：<code>Error: The module &#39;/Users/lixinxing/Documents/BlogBackup/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#39;
was compiled against a different Node.js version using</code></p>
<ul>
<li>一般是node的版本发生了变化，删除目录下的<code>node_modules</code>文件，然后执行<code>npm install</code>重新安装即可。</li>
<li>依然不行，可以执行<code>npm i -g hexo-cli</code>再跑跑试试。 </li>
</ul>
</li>
<li><p>执行<code>hexo g</code>报错：<code>ERROR Plugin load failed: hexo-generator-json-content</code></p>
<ul>
<li>可能是node版本过低，升级node版本即可。</li>
</ul>
</li>
<li><p>hexo将整个目录都上传了上去，一般是设置了submodule导致的。</p>
<ul>
<li>把<code>.deploy_git</code>文件夹删除</li>
<li>执行<code>hexo clean</code>删除public目录后，再重新执行命令上传即可。</li>
</ul>
</li>
</ul>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo主题yilia</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView的Cookie问题</title>
    <url>/2018/05/08/WKWebView%E7%9A%84Cookie%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>WKWebView与App不在同一个进程运行，不会从App的标准Cookie容器<code>NSHTTPCookieStorage</code>读取Cookie。跨进程的数据同步是一个麻烦及容易出现问题的场景，Apple在iOS11之前没有专门的API用于Cookie操作，在iOS11之后提供了<code>WKHTTPCookieStore</code>，但是自测发现存在一些奇怪的bug，无法使用，此部分后续会做说明。</p>
<p>网上关于WKWebView的Cookie同步我有查到多种方案，但是均无法解决跨域请求的Cookie问题，后来发现使用WKProcessPool可以解决跨域问题。</p>
<a id="more"></a>

<h3 id="UIWebView为什么没有Cookie同步问题？"><a href="#UIWebView为什么没有Cookie同步问题？" class="headerlink" title="UIWebView为什么没有Cookie同步问题？"></a>UIWebView为什么没有Cookie同步问题？</h3><p>网络请求完成后，会返回一个Response，如果Response中带有<code>Set-Cookie</code>字段，如：<code>&quot;Set-Cookie&quot; = &quot;wifi_jsessionid=3aea4df28ab14b4e8714132cb911c15a; Domain=.pingan.com.cn; Path=/&quot;;</code>，操作系统就会将此条Cookie信息写入到<code>NSHTTPCookieStorage</code>中</p>
<p>当UIWebView中有任意请求时（App进程中的请求也是一样），会去NSHTTPCookieStorage查找对应的Cookie信息，如果存在<strong>符合条件</strong>的Cookie信息，就会在请求头中带上此条Cookie信息。所以UIWebView进行跨域请求是没有任何问题的，只要NSHTTPCookieStorage有<strong>符合条件</strong>的Cookie信息即可带上。</p>
<h3 id="WKWebView-Cookie同步一般解决方案"><a href="#WKWebView-Cookie同步一般解决方案" class="headerlink" title="WKWebView Cookie同步一般解决方案"></a>WKWebView Cookie同步一般解决方案</h3><p>WKWebView上请求不会自动带上<code>NSHTTPCookieStorage</code>中的Cookie, 目前的主要解决方案是通过手动的方式直接在请求头上带上Cookie或者使用JS脚本进行Cookie注入：</p>
<h4 id="在请求头中设置Cookie-解决首个请求Cookie带不上的问题"><a href="#在请求头中设置Cookie-解决首个请求Cookie带不上的问题" class="headerlink" title="在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:"></a>在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> * webView = [<span class="built_in">WKWebView</span> new]; </span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> * request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://h5.qzone.qq.com/mqzone/index"</span>]]; </span><br><span class="line"></span><br><span class="line">[request addValue:<span class="string">@"skey=skeyValue"</span> forHTTPHeaderField:<span class="string">@"Cookie"</span>]; </span><br><span class="line">[webView loadRequest:request];</span><br></pre></td></tr></table></figure>

<p>此方法只适合解决简单针对性的场景。</p>
<h4 id="通过document-cookie设置Cookie解决后续页面-同域-Ajax、iframe请求的Cookie问题"><a href="#通过document-cookie设置Cookie解决后续页面-同域-Ajax、iframe请求的Cookie问题" class="headerlink" title="通过document.cookie设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:"></a>通过<code>document.cookie</code>设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKUserContentController</span>* userContentController = <span class="built_in">WKUserContentController</span>.new;</span><br><span class="line"><span class="comment">//不设定Domain，则会将domain默认设为请求的URL的Domain</span></span><br><span class="line"><span class="built_in">WKUserScript</span> * cookieScript = [[<span class="built_in">WKUserScript</span> alloc] </span><br><span class="line">    initWithSource: <span class="string">@"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';"</span></span><br><span class="line">    injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// again, use stringWithFormat: in the above line to inject your values programmatically</span></span><br><span class="line">[userContentController addUserScript:cookieScript];</span><br><span class="line"><span class="built_in">WKWebViewConfiguration</span>* webViewConfig = <span class="built_in">WKWebViewConfiguration</span>.new;</span><br><span class="line">webViewConfig.userContentController = userContentController;</span><br><span class="line"><span class="built_in">WKWebView</span> * webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="comment">/*set your values*/</span>) configuration:webViewConfig];</span><br></pre></td></tr></table></figure>

<p>设定Cookie的辅助方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cookieString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@;domain=%@;path=%@"</span>,</span><br><span class="line">                        <span class="keyword">self</span>.name,</span><br><span class="line">                        <span class="keyword">self</span>.value,</span><br><span class="line">                        <span class="keyword">self</span>.domain,</span><br><span class="line">                        <span class="keyword">self</span>.path ?: <span class="string">@"/"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secure) &#123;</span><br><span class="line">        string = [string stringByAppendingString:<span class="string">@";secure=true"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Cookie注入无法跨域，此方法无法解决跨域请求的Cookie问题。</p>
<h3 id="WKProcessPool同步方案解决跨域问题"><a href="#WKProcessPool同步方案解决跨域问题" class="headerlink" title="WKProcessPool同步方案解决跨域问题"></a>WKProcessPool同步方案解决跨域问题</h3><p>苹果开发者文档对WKProcessPool的定义是：<a href="https://developer.apple.com/documentation/webkit/wkprocesspool" target="_blank" rel="noopener">A WKProcessPool object represents a pool of Web Content process.</a> 通过让所有WKWebView共享同一个WKProcessPool实例，可以实现多个 WKWebView之间共享Cookie（session Cookie and persistent Cookie）数据。</p>
<p>既然可以多个WKWebView共享一个WKProcessPool实例，那么是不是可以先访问跨域的URL，将Cookie注入，不就得到了一个有跨域Cookie的WKProcessPool实例吗？再用此实例去访问原始的Web页面，不就可以解决跨域访问的Cookie问题了吗？ 经过实测，此方案是OK的。 样例如下：</p>
<p>可以创建一个单例管理WKProcessPool。如果Cookie更新了，更新WKProcessPool即可同步。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateProcessPool &#123;</span><br><span class="line">    _isUpdatePooling = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_webView) &#123;</span><br><span class="line">        _webView.navigationDelegate = <span class="literal">nil</span>;</span><br><span class="line">        [_webView removeFromSuperview];</span><br><span class="line">        _webView = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_delegate &amp;&amp; [_delegate respondsToSelector:<span class="keyword">@selector</span>(willUpdateCookieWithPool)]) &#123;</span><br><span class="line">        [_delegate willUpdateCookieWithPool];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JS注入</span></span><br><span class="line">    <span class="built_in">NSString</span> *jsStr = [<span class="keyword">self</span> updateCookieScriptString];</span><br><span class="line">    <span class="comment">//JS注入的domain（跨域注入会失败）</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.pingan.com.cn/"</span>];</span><br><span class="line">    <span class="built_in">WKUserScript</span> * cookieScript =</span><br><span class="line">    [[<span class="built_in">WKUserScript</span> alloc] initWithSource:jsStr</span><br><span class="line">                           injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class="line">                        forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line">    <span class="built_in">WKUserContentController</span>* userContentController = <span class="built_in">WKUserContentController</span>.new;</span><br><span class="line">    [userContentController addUserScript:cookieScript];</span><br><span class="line">    <span class="built_in">WKWebViewConfiguration</span>* configuration = <span class="built_in">WKWebViewConfiguration</span>.new;</span><br><span class="line">    configuration.userContentController = userContentController;</span><br><span class="line">    configuration.processPool = <span class="keyword">self</span>.pool;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span> configuration:configuration];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication].keyWindow addSubview:webView];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">3</span>];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">    _webView = webView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;</span><br><span class="line">    LOG_INFO(<span class="string">"WEB"</span>, <span class="string">@"didFinishNavigation :%@"</span>, navigation);</span><br><span class="line">    webView.navigationDelegate = <span class="literal">nil</span>;</span><br><span class="line">    [webView removeFromSuperview];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">void</span>(^block)(<span class="built_in">WKProcessPool</span> *pool) <span class="keyword">in</span> _handlers) &#123;</span><br><span class="line">            block(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        [_handlers removeAllObjects];</span><br><span class="line">        _isUpdatePooling = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_delegate &amp;&amp; [_delegate respondsToSelector:<span class="keyword">@selector</span>(didUpdateCookieWithPool)]) &#123;</span><br><span class="line">        [_delegate didUpdateCookieWithPool];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line">- (<span class="keyword">void</span>)getCookieWithProcessPoolHandler:(<span class="keyword">void</span>(^)(<span class="built_in">WKProcessPool</span> *pool))handler &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isUpdatePooling) &#123;</span><br><span class="line">        [_handlers addObject:handler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler(_pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于WKProcessPool只能在初始化时传入有效，所以调用有一点特殊：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">PAWFWebProcessPoolManager *cookieManager = [PAWFWebProcessPoolManager sharedManager];</span><br><span class="line">[cookieManager getCookieWithProcessPoolHandler:^(<span class="built_in">WKProcessPool</span> * _Nonnull pool) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>.webView = [<span class="keyword">self</span> creatWebViewWithPool:pool];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.webView];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:<span class="keyword">self</span>.URL];</span><br><span class="line">    [<span class="keyword">self</span>.webView loadRequest:request];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">WKWebView</span> *)creatWebViewWithPool:(<span class="built_in">WKProcessPool</span> *)pool &#123;</span><br><span class="line">    <span class="built_in">WKWebViewConfiguration</span>* configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">    configuration.processPool = pool;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kScreenWidth, <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.contentView.frame) - kGrwonStatusBarHeight);</span><br><span class="line">    <span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:frame configuration:configuration];</span><br><span class="line">    wkWebView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> wkWebView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WKHTTPCookieStore同步cookie问题"><a href="#WKHTTPCookieStore同步cookie问题" class="headerlink" title="WKHTTPCookieStore同步cookie问题"></a>WKHTTPCookieStore同步cookie问题</h3><p><code>WKHTTPCookieStore</code>，存在一些奇怪的bug，完全无法使用，已知问题如下：</p>
<h4 id="无法正常写入cookie的Bug："><a href="#无法正常写入cookie的Bug：" class="headerlink" title="无法正常写入cookie的Bug："></a>无法正常写入cookie的Bug：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *cookieProperties = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"wifi_jsessionid"</span> forKey:<span class="built_in">NSHTTPCookieName</span>];</span><br><span class="line">[cookieProperties setObject:jsessionid forKey:<span class="built_in">NSHTTPCookieValue</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@".pingan.com.cn"</span> forKey:<span class="built_in">NSHTTPCookieDomain</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@""</span> forKey:<span class="built_in">NSHTTPCookieOriginURL</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"/"</span> forKey:<span class="built_in">NSHTTPCookiePath</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"0"</span> forKey:<span class="built_in">NSHTTPCookieVersion</span>];</span><br><span class="line"><span class="built_in">NSHTTPCookie</span> *cookie = [<span class="built_in">NSHTTPCookie</span> cookieWithProperties:cookieProperties];</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKWebsiteDataStore</span> *store = [<span class="built_in">WKWebsiteDataStore</span> defaultDataStore];</span><br><span class="line">[store.httpCookieStore setCookie:cookie completionHandler:^&#123;</span><br><span class="line">    [store.httpCookieStore getAllCookies:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; * _Nonnull cookies) &#123;</span><br><span class="line">        <span class="comment">//读取不到写入的cookie。 </span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>使用迂回方式解决写入问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加observer代理</span></span><br><span class="line">[store.httpCookieStore addObserver:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：网络不畅通时，存在不回调的情况。网络ok后才会调用。原因不明</span></span><br><span class="line">- (<span class="keyword">void</span>)cookiesDidChangeInCookieStore:(<span class="built_in">WKHTTPCookieStore</span> *)cookieStore &#123;</span><br><span class="line">    <span class="built_in">WKWebsiteDataStore</span> *store = [<span class="built_in">WKWebsiteDataStore</span> defaultDataStore];</span><br><span class="line">    [store.httpCookieStore getAllCookies:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; * _Nonnull cookies) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">"WEB"</span>, <span class="string">@"cookiesDidChangeInCookieStore: %@"</span>, cookies);</span><br><span class="line">        <span class="comment">//参考链接：https://forums.developer.apple.com/thread/97194</span></span><br><span class="line">        <span class="comment">//此时才能看到Cookie被写入了</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：-140191"><a href="#cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：-140191" class="headerlink" title="cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：#140191"></a>cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：<a href="https://bugs.webkit.org/show_bug.cgi?id=140191" target="_blank" rel="noopener">#140191</a></h4><ul>
<li>自测添加跨域的cookie, Cookie添加成功后进行跨域访问，cookie无法生效。</li>
<li>自测添加正常cookie也无法生效。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">Can I set the cookies to be used by a WKWebView?
</a></li>
<li><a href="https://juejin.im/entry/5880ac602f301e006980d1f5" target="_blank" rel="noopener">WKWebView 那些坑</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS crash文件符号化</title>
    <url>/2018/02/27/iOS-crash%E6%96%87%E4%BB%B6%E7%AC%A6%E5%8F%B7%E5%8C%96/</url>
    <content><![CDATA[<p>carsh文件符号化需要<code>symbolicatecrash</code>脚本、<code>.crash</code>文件、产生crash的app对应的<code>.dSYM</code>文件。脚本可以通过<code>.dSYM</code>文件对<code>.crash</code>文件进行格式化。</p>
<a id="more"></a>

<h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><h4 id="查找symbolicatecrash脚本"><a href="#查找symbolicatecrash脚本" class="headerlink" title="查找symbolicatecrash脚本"></a>查找<code>symbolicatecrash</code>脚本</h4><p>执行命令：<code>find /Applications/Xcode.app/ -name symbolicatecrash</code>， 返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/WatchSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>

<p>找到四个结果，随意使用一个即可，这里使用：<code>/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</code></p>
<h4 id="提取crash文件"><a href="#提取crash文件" class="headerlink" title="提取crash文件"></a>提取<code>crash</code>文件</h4><ul>
<li>连上发生crash的手机，在Xcode的Window -&gt; Devices and Simulator 下，选中发生crash的设备，点击<code>View Device Logs</code>按钮</li>
<li>找到对应的crash日志，点击右键，选择<code>Export Log</code>导出。</li>
</ul>
<blockquote>
<p>不是所有的crash，都能产生crash日志。 没有crash日志只能通过其它方式debug.</p>
</blockquote>
<h4 id="提取dSYM文件"><a href="#提取dSYM文件" class="headerlink" title="提取dSYM文件"></a>提取<code>dSYM</code>文件</h4><ul>
<li>如果是xcode上打的包，在Xcode的Window -&gt; Organizer下，选中对应的app</li>
<li>选中对应的包，点击右键，选择Show in Finder，找到对应的<code>.xcarchive</code>文件</li>
<li>点击右键，选择<code>显示包内容</code>，在dSYMs文件夹中找到对应的<code>.dSYM</code>文件</li>
</ul>
<blockquote>
<p>如果使用脚本打包，注意<code>.dSYM</code>文件的存档</p>
</blockquote>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul>
<li>建立目录，将上述三个文件放入同一个目录</li>
<li>进入指定目录，执行<code>./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash</code>，会生成格式化的<code>crash</code>文件。</li>
</ul>
<blockquote>
<p>如果出现报错<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code>执行<code>export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer</code>修复。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS的ipa包重签名</title>
    <url>/2016/04/23/iOS%E7%9A%84ipa%E5%8C%85%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p>日常开发中，我们需要一个Apple账号用于发布App到AppStore，一个企业账号用于内部发布测试及给客户演示。但是Apple限制<code>Bundle Identifier</code>是不能重复的。所以我们有时候需要使用企业证书对个人证书发布的ipa包进行重签名。(注：当然你也可以用于其他用途，但是有被Apple封杀的风险)</p>
<h3 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h3><p>为了能对整个流程进行更好的说明，这里设置一些模拟数据</p>
<ul>
<li>App 在AppStore的<em>Bundle Identifier</em>:<code>com.test.AppStore</code></li>
<li>企业证书的名称：<code>iPhone Distribution: Shenzhen Test Technology Co., Ltd.</code></li>
<li>企业证书对应的Prefix：<code>828E9CDH56</code></li>
<li>企业账号用于发布的<em>Provisioning Profiles</em>文件名：<code>TestDistributionForEnterprise.mobileprovision</code></li>
<li>企业账号用于发布的<em>Provisioning Profiles</em>对应的<em>Bundle Identifier</em>：<code>com.test.enterprise</code></li>
</ul>
<blockquote>
<p>注：如果重签名后需要支持消息推送服务，需要把对应的Identifiers勾选<code>Push Notifications</code>服务</p>
</blockquote>
<a id="more"></a>

<h3 id="重签名流程"><a href="#重签名流程" class="headerlink" title="重签名流程"></a>重签名流程</h3><h4 id="创建entitlements-plist授权文件"><a href="#创建entitlements-plist授权文件" class="headerlink" title="创建entitlements.plist授权文件"></a>创建<code>entitlements.plist</code>授权文件</h4><ul>
<li><code>entitlements.plist</code>文件内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;keychain-access-groups&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;828E9CDH56.*&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;key&gt;get-task-allow&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;false&#x2F;&gt;</span><br><span class="line">    &lt;key&gt;application-identifier&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;828E9CDH56.com.test.enterprise&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;com.apple.developer.team-identifier&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;828E9CDH56&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;aps-environment&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;production&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure></li>
<li>图示如下：<br><img src="http://7xqwu9.com1.z0.glb.clouddn.com/entitlements.png" alt=""></li>
</ul>
<h3 id="ipa文件处理"><a href="#ipa文件处理" class="headerlink" title="ipa文件处理"></a>ipa文件处理</h3><ul>
<li>使用个人账号证书打包（和往常上传AppStore一样操作），导出ipa文件，文件名为<code>test.ipa</code>。</li>
<li>将<code>test.ipa</code>后缀改成<code>zip</code>并进行解压得到一个文件<code>Payload</code></li>
<li>删除<code>Payload/test.app/_CodeSignature</code> 以及 <code>Payload/test.app/embedded.mobileprovision</code>两个文件</li>
</ul>
<h4 id="替换证书配置文件（文件名为embedded，不能自定义）"><a href="#替换证书配置文件（文件名为embedded，不能自定义）" class="headerlink" title="替换证书配置文件（文件名为embedded，不能自定义）"></a>替换证书配置文件（文件名为embedded，不能自定义）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp TestDistributionForEnterprise.mobileprovision Payload&#x2F;test.app&#x2F;embedded.mobileprovision</span><br></pre></td></tr></table></figure>

<h4 id="重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）"><a href="#重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）" class="headerlink" title="重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）"></a>重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certifierName&#x3D;&quot;iPhone Distribution: Shenzhen Test Technology Co., Ltd.&quot;</span><br><span class="line">codesign -f -s $certifierName  --entitlements entitlements.plist Payload&#x2F;test.app</span><br></pre></td></tr></table></figure>

<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r resignTest.ipa Payload</span><br></pre></td></tr></table></figure>

<p>这样就得到了一个新的文件<code>resignTest.ipa</code>，可以企业发布给任何人安装，同时<em>Bundle Identifier</em>依然是<code>com.test.AppStore</code></p>
<blockquote>
<p><strong>注意：</strong><br>1、如果不在Payload所在目录进行打包，如<code>xxx/Payload</code>，则会导致打包出来的安装包无法安装，原因不明。<br>2、如果之前有安装过对应App测试版本，会导致安装失败，可能是缓存导致的问题。</p>
</blockquote>
<h4 id="Extension支持"><a href="#Extension支持" class="headerlink" title="Extension支持"></a>Extension支持</h4><p>在iOS开发中，Extension越来越多，尤其是很多app添加了Today Extension，在重签名的时候需要对extension进行处理，如果有多个extension，那么每个extension都要做重签名处理。对extension进行重签名流程如下：</p>
<ul>
<li>找到<code>PlugIns</code>目录下对应的Extension文件</li>
<li>与对app进行重签名一样，删除Extension里面的<code>_CodeSignature</code>目录，删除<code>embedded.mobileprovision</code>文件。</li>
<li>使用codesign命令进行重签名，证书与主app一致。命令也一样，修改对应的entitlements.plist和指定目录即可。 例：<code>codesign -f -s $certifierName  --entitlements extension_entitlements.plist Payload/test.app/PlugIns/extension.appex</code></li>
</ul>
<p>这里有两个注意事项：</p>
<ul>
<li>先对Extension进行签名，再对主app进行签名，不然会报错说codesign内容被修改之类的错误</li>
<li>重签名的时候注意证书的传参，如果对证书名字中有空格又没有用””引起来，会导致找不到证书。</li>
<li>如果报错<code>This application&#39;s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.</code>，那么应该是安装了一个同样bundle id的app， 把它删掉重新安装就可以了。</li>
</ul>
<h4 id="企业发布"><a href="#企业发布" class="headerlink" title="企业发布"></a>企业发布</h4><ul>
<li>按照常规的企业发布方式来即可<blockquote>
<p><strong>注意：</strong>1、企业发布后出现在有些机型可以安装成功，有些机型安装失败，刚开始怀疑是打的包有问题，后来发现是由于用于安装的plist文件里面的<code>display-image</code>以及<code>full-size-image</code>链接有问题，修复后OK<br>2、如果出现有的手机能安装， 有的手机不能安装， 那可能是.mobileprovision没有被正确替换导致的。</p>
</blockquote>
</li>
</ul>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>我把整个流程用<code>Python</code>做了一个脚本，功能流程如下 <code>打包ipa</code>–&gt;<code>重签名</code>–&gt;<code>上传服务器</code>–&gt;<code>发送邮件</code>，<a href="https://github.com/xx-li/iOSAutoPackaging" target="_blank" rel="noopener">点此可以下载</a>。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Xcode模板加速及规范开发</title>
    <url>/2020/06/29/%E4%BD%BF%E7%94%A8Xcode%E6%A8%A1%E6%9D%BF%E5%8A%A0%E9%80%9F%E5%8F%8A%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>前言：开发效率和质量是每位开发人员永恒的追求，而Xcode的模板功能可以帮助你更好的达成这个目标，更难能可贵的是它还能在一定程度上帮助你统一实现逻辑和开发规范。</p>
<a id="more"></a>

<h2 id="为什么需要使用模板"><a href="#为什么需要使用模板" class="headerlink" title="为什么需要使用模板"></a>为什么需要使用模板</h2><p>在日常开发中，经常会碰到开发类似功能的情况，我们可以使用面向对象编程的继承来对相同部分进行封装，利用多态来进行特定功能区分，这样可以提高开发效率和质量。当然也有函数式开发和面向协议编程等，但是万变不离其宗，大家都在提模块化，组件化，以提高开发效率、质量、可维护性等。但是不管使用哪种框架和编码方式，都不可能干掉所有的重复代码和重复逻辑，依然会存在很多复制、粘贴等重复操作。例如我们在项目基础框架之上实现两个列表模块A和B，那么A和B模块中大部分的代码文件都是类似的，里面的内容也都是类似的。</p>
<p>为了减少这些重复操作导致的效率低下，我们可以使用Dash或Gist等工具，创建代码片段，来快速的复制粘贴代码，但是这些只限定于单个文件内的文本编辑。如果你所做的项目对某一类功能的实现已经有了固定套路，例如一个常见的列表页面，包含下拉刷新、加载更多等功能，你选择了MVC或MVVM等架构模式，那么在单个项目内，每个列表页面的代码（在一个文件或多个文件中）将会大量相似，每次都要重复的创建类似的文件，写类似的实现。如果是多人开发，还可能会在大体框架基础下搞出好几套大同小异的代码来，而这样的害处是显而易见的。</p>
<h2 id="如何使用模板加速开发？"><a href="#如何使用模板加速开发？" class="headerlink" title="如何使用模板加速开发？"></a>如何使用模板加速开发？</h2><h3 id="模板工具"><a href="#模板工具" class="headerlink" title="模板工具"></a>模板工具</h3><p>在软件开发中，要提高效率，就得把重复的工作交给电脑来做，电脑会做的又快又好。针对上面提到的问题，我们完全可以创建一套模板，然后通过脚本或者IDE来批量生成代码，生成代码后，只需要修改其中的少量代码就可以完成全部功能，这样就避免了大量的文件创建和代码复制粘贴操作，也避免了一些由于操作失误导致的bug，同时也避免了一些不同开发人员的不同实现逻辑的问题。</p>
<p>我了解到有两种实现方案：</p>
<ol>
<li><a href="https://seongbrave.github.io/gckit/guide/" target="_blank" rel="noopener">介绍 | Gckit-CLI</a><br><img src="gckit.png" alt=""></li>
<li>Xcode自定义模板</li>
</ol>
<p>我刚开始是使用的<code>Gckit-CLI工</code>工具，但是发现<code>Xcode</code>原生支持自定义模板后，我转向了使用<code>Xcode自定义模板</code>，因为集成在IDE中使用起来更加的便捷。所以这里我只介绍<code>Xcode自定义模板</code>功能的使用，对<code>Gckit-CLI</code>感兴趣的可以去它的<a href="https://seongbrave.github.io/gckit/guide/" target="_blank" rel="noopener">官网</a>自行查看。</p>
<h3 id="Xcode自定义模板的使用"><a href="#Xcode自定义模板的使用" class="headerlink" title="Xcode自定义模板的使用"></a>Xcode自定义模板的使用</h3><h4 id="Xcode系统默认模板说明"><a href="#Xcode系统默认模板说明" class="headerlink" title="Xcode系统默认模板说明"></a>Xcode系统默认模板说明</h4><p>Xcode在创建项目或文件时，就是使用了Xcode自带的模板功能。 它包含<code>iOS</code>、<code>watchOS</code>、<code>tvOS</code>、<code>macOS</code>菜单，在iOS菜单下又分为<code>Source</code>、<code>User Interface</code>等类别，类别里面有<code>Cocoa Touch Class</code>、<code>Swift File</code>等模块，图示如下：</p>
<p><img src="creat_file.png" alt=""></p>
<p>这些模板的路径位置如下：</p>
<ul>
<li>iOS 平台模版的位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>watchOS 平台的模版位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>tvOS 平台的模版位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>macOS 平台文件模版的位置：<br><code>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates</code></li>
</ul>
<blockquote>
<p>这里我们仅拿iOS平台模板来进行说明</p>
</blockquote>
<p>我们看iOS平台模板的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── File\ Templates</span><br><span class="line">│   ├── Apple\ Watch</span><br><span class="line">│   ├── Playground</span><br><span class="line">│   ├── Resource</span><br><span class="line">│   ├── Source</span><br><span class="line">│   └── User\ Interface</span><br><span class="line">└── Project\ Templates</span><br><span class="line">    └── iOS</span><br></pre></td></tr></table></figure>
<p><code>Project\ Templates</code>是创建项目的模板，这里不做说明。<code>File\ Templates</code>目录下的内容就是上面图示中<code>iOS</code>菜单下的内容，例如我们根据<code>Source</code> -&gt; <code>Cocoa Touch Class</code>的模板创建文件，会进入如下页面：<br><img src="creat_file_next.png" alt=""></p>
<h5 id="Xcode模板页面的生成"><a href="#Xcode模板页面的生成" class="headerlink" title="Xcode模板页面的生成"></a>Xcode模板页面的生成</h5><p><code>Cocoa Touch Class</code>模板文件目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── File\ Templates</span><br><span class="line">│   ├── Source</span><br><span class="line">│   │   ├── Cocoa\ Touch\ Class.xctemplate  # Cocoa Touch Class模板文件目录</span><br><span class="line">│   │   │   ├── NSObjectObjective-C</span><br><span class="line">│   │   │   ├── NSObjectSwift</span><br><span class="line">│   │   │   ├── TemplateIcon.png</span><br><span class="line">│   │   │   ├── TemplateIcon@2x.png</span><br><span class="line">│   │   │   ├── TemplateInfo.plist   # 根据此文件生成页面和匹配模板目录</span><br><span class="line">│   │   │   ├── UICollectionReusableViewObjective-C</span><br><span class="line">│   │   │   ├── UICollectionReusableViewXIBObjective-C</span><br><span class="line">│   │   │   │   ├── UICollectionReusableViewObjective-C</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.h</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.m</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.xib</span><br><span class="line">│   │   │   ├── ...</span><br><span class="line">├── ...</span><br><span class="line">│   ├── ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述页面对应<code>Cocoa Touch Class.xctemplate</code>目录下的<code>TemplateInfo.plist</code>文件，这个页面是根据此文件生成的。 我们看下<code>TemplateInfo.plist</code>文件的内容（内容太多，只贴出部分，上面的注释是作者添加的）：</p>
<figure class="highlight plist"><table><tr><td class="code"><pre><span class="line">··· 省略部分</span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span> # 这里对应中间的子类输入控件</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>cocoaTouchSubclass<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Required<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  # 必须展示这个控件在页面上</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Subclass of:<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  # 左边的说明文本</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>What class to subclass in the new file<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">key</span>&gt;</span>    # UI样式类型是class类型，可以输入值，也可以选择值</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>class<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">key</span>&gt;</span>   # 默认选择的值是NSObject</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>NSObject<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>FallbackHeader<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>#import <span class="symbol">&amp;lt;</span>UIKit/UIKit.h<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Values<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  # 可选择的列表</span><br><span class="line">			<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>NSObject<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UIView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UIViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UITableViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UITableViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionReusableView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Suffixes<span class="tag">&lt;/<span class="name">key</span>&gt;</span> # 输入匹配相关</span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UIViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>ViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UITableViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>TableViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UITableViewCell<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>TableViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionViewCell<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionReusableView<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionReusableView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dict</span>&gt;</span>   # 对应最底部的语言选择按钮</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>languageChoice<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Required<span class="tag">&lt;/<span class="name">key</span>&gt;</span> # 必须展示这个控件在页面上</span><br><span class="line">			<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Language:<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  # 左边的说明文本</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>The implementation language<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">key</span>&gt;</span>   #UI样式是popup，弹出列表选择值</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>popup<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Values<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">array</span>&gt;</span> # 可选择的列表</span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>MainTemplateFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>___FILEBASENAME___.swift<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>___FILEBASENAME___.m<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>AllowedTypes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.swift-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.objective-c-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.objective-c-plus-plus-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">··· 省略部分</span><br></pre></td></tr></table></figure>

<h5 id="模板的匹配"><a href="#模板的匹配" class="headerlink" title="模板的匹配"></a>模板的匹配</h5><p>用户在上述页面填写和选择了内容后，点击<code>Next</code>创建，就进入了模板匹配逻辑。假如用户在<code>Subclass of</code>选项中输入或选择了<code>UICollectionReusableView</code>，不勾选<code>Also create XIB file</code>勾选框，在<code>Language</code>选项中选择<code>Objective-C</code>，那么Xcode就会将这两个值按顺序拼接起来，得到文件名：<code>UICollectionReusableViewObjective-C</code>，然后会在<code>TemplateInfo.plist</code>文件所在目录中，搜索文件名为<code>UICollectionReusableViewObjective-C</code>的文件夹，如果有就取这个文件夹内模板文件来生成代码（有几个文件就生成几个）。如果没搜索到，就进行默认创建。</p>
<h5 id="模板代码如何生成"><a href="#模板代码如何生成" class="headerlink" title="模板代码如何生成"></a>模板代码如何生成</h5><p>在上面流程中，已经匹配到了<code>UICollectionReusableViewObjective-C</code>模板，这个模板存在两个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UICollectionReusableViewObjective-C</span><br><span class="line">├── ___FILEBASENAME___.h</span><br><span class="line">└── ___FILEBASENAME___.m</span><br></pre></td></tr></table></figure>

<p>其中<code>___FILEBASENAME___.h</code>的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;___FILEHEADER___</span><br><span class="line"></span><br><span class="line">___IMPORTHEADER_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<p>Xcode会使用用户在创建页面输入的类名来替换文件名中的<code>___FILEBASENAME___</code>，使用用户在<code>Subclass of</code>中输入的内容来替换<code>___VARIABLE_cocoaTouchSubclass___</code>，使用之前设置好的文件注释头来替换<code>___FILEHEADER___</code>，全部替换完成后写入文件输出，呈现给用户的就是创建文件完成。到此为止，通过模板创建文件整个流程全部走完了。</p>
<blockquote>
<p>Xcode模板的相关配置和字段较多，可以根据里面的内容和展示的页面和行为来猜测每个字段的含义，然后依葫芦画瓢来学习Xcode模板是如何工作的。（如果您有找到这方面的文档，请评论区告诉我）</p>
</blockquote>
<h4 id="如何创建Xcode自定义模板"><a href="#如何创建Xcode自定义模板" class="headerlink" title="如何创建Xcode自定义模板"></a>如何创建Xcode自定义模板</h4><p>自定义模板和系统模板的实现和使用基本是一样的。将自定义模板放在特定目录下时，Xcode就会将自定义模板加载出来。</p>
<blockquote>
<p>修改模板后要重启xcode才能生效。</p>
</blockquote>
<p>自定义模板的路径是：<code>~/Library/Developer/Xcode/Templates</code>(如果不存在<code>Templates</code>目录，就手动创建一个。)<br>在此路径下，我们创建一个<code>Custom</code>目录，将系统模板中的<code>Cocoa\ Touch\ Class.xctemplate</code>目录复制到<code>Custom</code>目录下，这样在工程中新建文件就可以看到自定义的Custom目录及它下面的<code>Cocoa\ Touch\ Class</code>模板了：<br><img src="creat_file_custom.png" alt=""></p>
<p>到了这一步，你就会清楚自定义模板的套路了，剩下的就是依葫芦画瓢来实现自己的模板了。</p>
<p>我根据个人常用编程习惯，创建了一套模板，大家可以下载进行参考。下载地址： <a href="https://github.com/xx-li/CustomTemplates" target="_blank" rel="noopener">GitHub - xx-li/CustomTemplates: Xcode rapid development templates</a>，</p>
<p>使用图示：<br><img src="xcode_template_demo.gif" alt=""></p>
<h4 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h4><p>由于模板的匹配是目录匹配方式，所以每一个选项都会对应一个新的目录，例如一个2*2的选项，就会需要四个模板目录来进行匹配。当我们对模板进行功能细分时，就需要创建大量的模板，而每一个模板可能有大量内容是相似的，修改一个基础逻辑就要对所有的模板文件进行修改。为了解决这种问题，可以使用脚本来创建模板。</p>
<p>在上面的仓库中<a href="https://github.com/xx-li/CustomTemplates" target="_blank" rel="noopener">CustomTemplates</a>，有用Python写的模板生成脚本。因为是用于个人项目，生成的代码缺乏基础框架支持，并不能直接使用，您可以参考编写适用于自己的脚本和模板。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/infinum/iOS-VIPER-Xcode-Templates" target="_blank" rel="noopener">iOS-VIPER-Xcode-Templates</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建一个Flutter Plugin</title>
    <url>/2020/06/15/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAFlutter-Plugin/</url>
    <content><![CDATA[<h2 id="什么是plugin"><a href="#什么是plugin" class="headerlink" title="什么是plugin"></a>什么是plugin</h2><p><code>Flutter</code>和<code>Dart</code>生态系统的软件包有两种模板，分别是<code>packages</code>和<code>plugin</code>，其中plugin包含<code>Android</code>、<code>iOS</code>平台特定实现，一般需要Flutter端与Android或iOS进行通讯交互（类比Hybrid或RN中JS与Native的交互），以实现特定功能。 </p>
<h2 id="创建plugin"><a href="#创建plugin" class="headerlink" title="创建plugin"></a>创建plugin</h2><p>一般使用命令创建Plugin：<code>flutter create —org com.example —template=plugin hello</code>，执行命令后，会在当前目录下生成一个<code>hello</code>文件夹，里面是一个plugin的简单demo实现。iOS可以使用OC和Swift，Android可以使用Java和kotlin进行代码编写，命令默认使用swift及kotlin，如需修改，使用<code>-i</code>及<code>-o</code>命令。例如要创建一个使用OC及java的plugin，命令为：<code>flutter create —org com.example —template=plugin -a java -o objc hello</code>。</p>
<h2 id="平台通道数据类型及编解码器"><a href="#平台通道数据类型及编解码器" class="headerlink" title="平台通道数据类型及编解码器"></a>平台通道数据类型及编解码器</h2><p>在平台通道进行数据传输时，Flutter它会自动对这些值进行序列化和反序列化。 下表展示了如何在平台端接收 Dart 值，反之亦然：</p>
<p><img src="args.jpg" alt=""></p>
<h3 id="创建一个样例Demo"><a href="#创建一个样例Demo" class="headerlink" title="创建一个样例Demo"></a>创建一个样例Demo</h3><p>为了更好的说明流程，这里创建一个禁用截屏功能的plugin进行说明，plugin提供三个功能：<code>全局添加水印</code>、<code>截屏监控</code>、<code>禁用截屏</code>。其中<code>全局添加水印</code>为在Flutter当前页面栈的最上层添加一个半透、有水印、穿透触摸事件的全遮盖页面，为纯dart实现，不需要与平台进行交互； <code>截屏监控</code>为当平台监听到截屏行为后，立即通知Flutter端，是一个持续通讯的过程；<code>禁用截屏</code>为Flutter端通知平台执行禁用操作（只支持Android平台）。<br>此plugin已经开发完成并发布到官方pub，可以在<a href="https://github.com/xx-li/disable_screenshots" target="_blank" rel="noopener">GitHub - disable_screenshots</a>下载并查看源码。</p>
<a id="more"></a>

<ol>
<li>创建命令：<code>flutter create --org com.devlxx --template=plugin disable_screenshots</code></li>
<li>执行命令后会生成如下目录：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── disable_screenshots</span><br><span class="line">│   ├── CHANGELOG.md</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── android</span><br><span class="line">│   ├── disable_screenshots.iml</span><br><span class="line">│   ├── example</span><br><span class="line">│   ├── ios</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── pubspec.lock</span><br><span class="line">│   ├── pubspec.yaml</span><br><span class="line">│   └── test</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>pubspec.yaml：plugin的配置文件。里面有字段：<code>name</code>、<code>description</code>、<code>version</code>、<code>homepage</code>，这些均是字面意思，很好理解。另外有字段<code>environment</code>，指定插件的使用环境，最关键的是有一个flutter字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The following section is specific to Flutter.</span><br><span class="line">flutter:</span><br><span class="line">  # This section identifies this Flutter project as a plugin project.</span><br><span class="line">  # The &#39;pluginClass&#39; and Android &#39;package&#39; identifiers should not ordinarily</span><br><span class="line">  # be modified. They are used by the tooling to maintain consistency when</span><br><span class="line">  # adding or updating assets for this project.</span><br><span class="line">  plugin:</span><br><span class="line">    platforms:</span><br><span class="line">      android:</span><br><span class="line">        package: com.devlxx.disable_screenshots</span><br><span class="line">        pluginClass: DisableScreenshotsPlugin</span><br><span class="line">      ios:</span><br><span class="line">        pluginClass: DisableScreenshotsPlugin</span><br></pre></td></tr></table></figure>
<p>这个字段说明了plugin支持的平台以及各平台的入口class，这个需要能一一对应。默认会给你创建好，不要随意修改这里及类名即可。</p>
</li>
<li><p><code>README.md</code>  : 项目说明。当发布到官方的<code>pub.dev</code>后，插件的Readme栏目内容即为此文件内容。</p>
</li>
<li><p><code>lib</code>：plugin<code>Flutter</code>端的实现</p>
</li>
<li><p><code>ios</code>：plugin<code>ios</code>端的实现</p>
</li>
<li><p><code>android</code>：plugin<code>android</code>端的实现</p>
</li>
<li><p><code>example</code>：plugin的使用demo，可以运行此demo进行测试，另外demo里面也有<code>README.md</code>文件，当发布到官方的<code>pub.dev</code>后，插件的Example栏目内容即为此文件内容。</p>
</li>
</ul>
<ol start="3">
<li>Flutter与iOS、Android通讯原理<br>Flutter只是一个UI框架，与平台相关的功能只能由平台来原生实现，这就需要Flutter与原生进行相互通讯。它们通过PlatformChannel进行互相通讯，核心原理是：<ul>
<li>Flutter通过PlatformChannel将要传递的数据编码后，跨线程发送到宿主（iOS或Android）</li>
<li>宿主接收到PlatformChannel的消息后，执行原生API。</li>
<li>宿主执行完原生API后，将数据编码并原路返回给应用程序的Flutter部分<br>图示如下：<br><img src="PlatformChannels.png" alt=""></li>
</ul>
</li>
</ol>
<p>PlatformChannel有三种类型，分别是：<code>BasicMessageChannel</code>、<code>MethodChannel</code>、<code>EventChannel</code>。其中<code>BasicMessageChannel</code>接收一个MessageCodec<T>作为其编解码器的实现，允许我们使用自定义的消息编解码进行异步消息传递，这里不对其做说明。</p>
<pre><code>- `MethodChannel`：用于Flutter主动调用平台端的方法，并获得相应的返回值，例如获取系统电量、发起Toast等，可以说是“一次性”的调用。这里将通过它来告知平台端禁用截屏功能
- `EventChannel`，用于传递事件。例如Flutter要监听电量变化，平台端可以将监听到的电量变化情况持续的通过`EventChannel`传递给Flutter端。这里将通过它来`截屏监控`功能。</code></pre><h3 id="disable-screenshots的禁用截屏功能实现（MethodChannel）"><a href="#disable-screenshots的禁用截屏功能实现（MethodChannel）" class="headerlink" title="disable_screenshots的禁用截屏功能实现（MethodChannel）"></a><code>disable_screenshots</code>的<code>禁用截屏</code>功能实现（MethodChannel）</h3><ol>
<li><p>Flutter端实现<br>创建命令会在<code>lib</code>目录下生成一个<code>disable_screenshots.dart</code>文件，里面会有一个默认的<code>MethodChannel</code>实现样例，我们对其进行修改，修改后的核心源码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line"><span class="keyword">final</span> MethodChannel methodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过MethodChannel将方法名和参数编码后发到平台端</span></span><br><span class="line">methodChannel.invokeMethod(<span class="string">"disableScreenshots"</span>, &#123;<span class="string">"disable"</span>: disable&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android端实现（kotlin）<br>创建命令会在<code>android</code>目录下的<code>/src/main/kotlin/com/devlxx/disable_screenshots/</code>生成一个<code>DisableScreenshotsPlugin.kt</code>文件，其中实现<code>禁用截屏</code>的核心代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToEngine</span><span class="params">(applicationContext: <span class="type">Context</span>, messenger: <span class="type">BinaryMessenger</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext</span><br><span class="line">	  <span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line">    <span class="keyword">this</span>.channel = MethodChannel(messenger, <span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>)</span><br><span class="line">    <span class="comment">//handle指向了this，this必须实现onMethodCall方法</span></span><br><span class="line">    <span class="keyword">this</span>.channel.setMethodCallHandler(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodCall</span><span class="params">(<span class="meta">@NonNull</span> call: <span class="type">MethodCall</span>, <span class="meta">@NonNull</span> result: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (call.method == <span class="string">"disableScreenshots"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> disable = call.argument&lt;<span class="built_in">Boolean</span>&gt;(<span class="string">"disable"</span>) == <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 禁止截屏需要获取到当前的activity，如何获取到activity请自行查看源码，这里不做说明。</span></span><br><span class="line">      <span class="keyword">if</span> (disable) &#123;</span><br><span class="line">	    activity.window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);</span><br><span class="line">	    println(<span class="string">"禁用截屏"</span>)</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 允许截屏</span></span><br><span class="line">	    activity.window.clearFlags(WindowManager.LayoutParams.FLAG_SECURE)</span><br><span class="line">	    println(<span class="string">"允许截屏"</span>)</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">// 调用后，Flutter端的invokeMethod会收到调用的结果，结果为一个空字符串</span></span><br><span class="line">      result.success(<span class="string">""</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.notImplemented()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS端实现。（iOS无法实现禁止截屏功能，这里仅做说明）<br>创建命令会在<code>ios</code>目录下的<code>Classes/</code>下生成一个<code>DisableScreenshotsPlugin.swift</code>文件，其中实现<code>禁用截屏</code>的核心代码为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(with registrar: FlutterPluginRegistrar)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="type">SwiftDisableScreenshotsPlugin</span>()</span><br><span class="line">    <span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line">    <span class="keyword">let</span> methodChannel = <span class="type">FlutterMethodChannel</span>(name: <span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>, binaryMessenger: registrar.messenger())</span><br><span class="line">    registrar.addMethodCallDelegate(instance, channel: methodChannel)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">FlutterPlugin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="number">_</span> call: FlutterMethodCall, result: @escaping FlutterResult)</span></span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //iOS平台无法实现禁用截屏功能，这里仅做MethodChannel的使用说明</span></span><br><span class="line"><span class="comment">        if call.method == "disableScreenshots" &#123;</span></span><br><span class="line"><span class="comment">            if let arg = call.arguments as? Dictionary&lt;String, Any&gt;, let disable = arg["disable"] as? Bool &#123;</span></span><br><span class="line"><span class="comment">                if disable &#123;</span></span><br><span class="line"><span class="comment">                    //禁用截屏</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    //允许截屏</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                print("【SwiftDisableScreenshotsPlugin】disableScreenshots 收到错误参数")</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            result(FlutterMethodNotImplemented)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        result(<span class="type">FlutterMethodNotImplemented</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="disable-screenshots的截屏监控功能实现（EventChannel）"><a href="#disable-screenshots的截屏监控功能实现（EventChannel）" class="headerlink" title="disable_screenshots的截屏监控功能实现（EventChannel）"></a><code>disable_screenshots</code>的<code>截屏监控</code>功能实现（EventChannel）</h3><ol>
<li><p>Flutter端实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建EventChannel</span></span><br><span class="line"><span class="keyword">final</span> EventChannel eventChannel = <span class="keyword">const</span> EventChannel(<span class="string">'com.devlxx.DisableScreenshots/observer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 监听平台端发来的事件</span></span><br><span class="line">_eventChannel.receiveBroadcastStream().listen((event) &#123;</span><br><span class="line">  <span class="comment">//平台端发来事件后会调用到这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android端实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建EventChannel</span></span><br><span class="line"><span class="keyword">val</span> eventChannel = EventChannel(messenger, <span class="string">"com.devlxx.DisableScreenshots/observer"</span>)</span><br><span class="line"><span class="comment">// 2. handle指向了this，this必须实现onListen及onCancel方法。</span></span><br><span class="line">eventChannel.setStreamHandler(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onListen</span><span class="params">(arguments: <span class="type">Any</span>?, events: <span class="type">EventChannel</span>.<span class="type">EventSink</span>?)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"开始监听"</span>)</span><br><span class="line">    <span class="comment">// 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端</span></span><br><span class="line">    eventSink = events</span><br><span class="line">    <span class="comment">// 5. ScreenShotListenManager为一个实现了监听截屏功能的Manager</span></span><br><span class="line">    screenShotListenManager = ScreenShotListenManager.newInstance(applicationContext)</span><br><span class="line">    screenShotListenManager.setListener &#123; imagePath -&gt;</span><br><span class="line">      println(<span class="string">"监听到截屏，截屏图片地址是：<span class="variable">$imagePath</span>"</span>)</span><br><span class="line">      <span class="comment">// 6. 发送事件给Flutter端，告知监听到了截屏行为。</span></span><br><span class="line">      eventSink?.success(<span class="string">"监听到截屏行为"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    screenShotListenManager.startListen()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventChannel被取消</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">(arguments: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    screenShotListenManager.stopListen()</span><br><span class="line">    eventSink = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS端实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> eventSink: <span class="type">FlutterEventSink?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册使用此插件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(with registrar: FlutterPluginRegistrar)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="type">SwiftDisableScreenshotsPlugin</span>()</span><br><span class="line">    <span class="comment">// 1. 创建EventChannel</span></span><br><span class="line">    <span class="keyword">let</span> channel = <span class="type">FlutterEventChannel</span>(</span><br><span class="line">        name: <span class="string">"com.devlxx.DisableScreenshots/observer"</span>,</span><br><span class="line">        binaryMessenger: registrar.messenger()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 2. 设置handler为SwiftDisableScreenshotsPlugin，它必须实现onListen及onCancel方法</span></span><br><span class="line">    channel.setStreamHandler(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="number">6</span>. 发送事件给<span class="type">Flutter</span>端，告知监听到了截屏行为。</span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">callScreenshots</span><span class="params">()</span></span> &#123;</span><br><span class="line">    eventSink!(<span class="string">"监听到截屏行为"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">FlutterStreamHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onListen</span><span class="params">(withArguments arguments: <span class="keyword">Any</span>?, eventSink events: @escaping FlutterEventSink)</span></span> -&gt; <span class="type">FlutterError?</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端</span></span><br><span class="line">        eventSink = events</span><br><span class="line">        <span class="comment">// 5. iOS端实现截屏监听功能很简单，添加相应通知的监听即可。</span></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">            <span class="keyword">self</span>,</span><br><span class="line">            selector: #selector(callScreenshots),</span><br><span class="line">            name: <span class="type">UIApplication</span>.userDidTakeScreenshotNotification,</span><br><span class="line">            object: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EventChannel被取消</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCancel</span><span class="params">(withArguments arguments: <span class="keyword">Any</span>?)</span></span> -&gt; <span class="type">FlutterError?</span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">        eventSink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>综合MethodChannel及EventChannel的三端实现来看，它们的使用还是比较简单的，对于开发者来说，挑战在于需要对三端都熟悉，并写出高质量的代码。<br>在实际开发时，可以先用相应的开发者工具打开Example目录下的iOS及Android的项目，分别进行平台特定代码的开发、调试。当iOS及Android的平台代码编写完成后，再直接运行Example项目，进行Flutter端的功能开发及整体的调试。</p>
<h3 id="全局添加水印"><a href="#全局添加水印" class="headerlink" title="全局添加水印"></a>全局添加水印</h3><p>全局添加水印不涉及平台端，为纯Flutter端实现。和常规的Flutter Dart代码编写没什么差异，这里不做说明，具体实现可以直接查看源码。</p>
<h2 id="发布plugin"><a href="#发布plugin" class="headerlink" title="发布plugin"></a>发布plugin</h2><p>当plugin的三端代码写好后，需要进行发布。plugin的发布非常简单，分为两步。<br>第一步为检查项目是否OK，执行命令：<code>flutter packages pub publish --dry-run</code>后，会提示项目是否存在遗漏或者异常部分，如果有异常，根据提示进行修复即可。例如此项目在执行此命令时，有提示存在问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Package validation found the following potential issue:</span><br><span class="line">* Your pubspec.yaml includes an &quot;author&quot; section which is no longer used and may be removed.</span><br></pre></td></tr></table></figure>
<p>这个是Flutter的一个bug，默认创建的模板会包含一个author字段，但是却无法检查通过，将pubspec.yaml中的author字段删除即可检查通过。</p>
<p>检查通过后，可以执行第二步，执行命令：<code>flutter packages pub publish</code>进行发布。执行后，根据命令行会提示进行操作，需要注意的是有一个验证身份的操作，将命令行出现的网址在浏览器中打开，然后在此页面登录自己的Google账号，这样就会将这个plugin与你的账号进行绑定及身份验证，操作完成后即发布成功，命令行输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Do you want to publish disable_screenshots 0.0.1 (y&#x2F;N)? y</span><br><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br><span class="line">In a web browser, go to https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?access_type&#x3D;offline&amp;approval_prompt&#x3D;force&amp;response_type&#x3D;code&amp;client_id&#x3D;81fds5108-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A54755&amp;scope&#x3D;openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email</span><br><span class="line">Then click &quot;Allow access&quot;.</span><br><span class="line"></span><br><span class="line">Waiting for your authorization...</span><br><span class="line">Authorization received, processing...</span><br><span class="line">Successfully authorized.</span><br><span class="line">Uploading...</span><br><span class="line">Successfully uploaded package.</span><br></pre></td></tr></table></figure>

<p>plugin发布成功后并不能立即在官方的<a href="https://pub.dev/" target="_blank" rel="noopener">pub</a>中搜到，它需要一段时间来处理，但是可以直接输入地址看到：<a href="https://pub.dev/flutter/packages?q=disable_screenshots" target="_blank" rel="noopener">https://pub.dev/flutter/packages?q=disable_screenshots</a></p>
<h2 id="发布失败问题处理"><a href="#发布失败问题处理" class="headerlink" title="发布失败问题处理"></a>发布失败问题处理</h2><p>有时候会上传失败，提示<code>Failed to upload the package</code>。失败有可能是如下几种情况导致：</p>
<h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>以为package是发布到google的服务器上，如果无法科学上网，肯定是会失败的。有些同学开启代理后依然无法上传成功，那么需要检查终端是否走的代理（终端默认不走代理）。<br>此时需要给终端设置代理，也就是<code>命令行代理</code>。<br>在<code>mac</code>平台中，在<code>.bash_profile</code>文件中加入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端走代理</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">proxy_on</span></span>()&#123;</span><br><span class="line">    <span class="built_in">export</span> http_proxy=http://127.0.0.1:1087  <span class="comment">#填写您本地的实际代理端口</span></span><br><span class="line">    <span class="built_in">export</span> https_proxy=http://127.0.0.1:1087  <span class="comment">#填写您本地的实际代理端口</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"已开启代理"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">proxy_off</span></span>()&#123;</span><br><span class="line">    <span class="built_in">unset</span> http_proxy</span><br><span class="line">    <span class="built_in">unset</span> https_proxy</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"已关闭代理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打开终端后使用<code>proxy_on</code>，即可开启命令行代理。<br>当然你也可以使用<code>软路由科学上网</code>等其他方式让所有程序都走代理。</p>
<h3 id="镜像配置导致的问题"><a href="#镜像配置导致的问题" class="headerlink" title="镜像配置导致的问题"></a>镜像配置导致的问题</h3><p>很多同学使用pub的国内镜像来提高package拉取的速度，但是这些镜像设置会导致上传失败。 上传时将这些镜像配置关闭即可。</p>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p>一直失败无法找到原因时，可以使用命令<code>flutter packages pub publish --verbose</code>显示详细log，以分析问题出现的原因。例如有时候会出现异常log：<code>HTTP response 400 Bad Request for POST https://storage.googleapis.com</code>，这个并不是网络问题导致的，而是权限问题，添加<code>subo</code>执行：<code>sudo flutter packages pub publish --verbose</code> 。 即可上传成功</p>
<h3 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h3><p>如果上述操作都无法解决问题，可以去官方仓库的<a href="https://github.com/flutter/flutter/issues/16658" target="_blank" rel="noopener">issue</a>中查找答案或提问。</p>
<h2 id="引用plugin"><a href="#引用plugin" class="headerlink" title="引用plugin"></a>引用plugin</h2><p>plugin开发完后，我们可以选择多种方式将plugin提供给其它开发者使用：<br>    - 从本地路径引入<br>    - 从Git仓库引入<br>    - 从官方pub引入（需要先发布到官方pub）<br>    - 从指定源引入</p>
<h3 id="本地路径引入"><a href="#本地路径引入" class="headerlink" title="本地路径引入"></a>本地路径引入</h3><p>plugin中的Example引入plugin就是通过本地路径方式引入的，这种方式很方便本地修改和调试，进入方式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">disable_screenshots:</span></span><br><span class="line">	  <span class="comment"># 当前pubspec.yaml文件的上一级目录是plugin所在目录</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">../</span></span><br></pre></td></tr></table></figure>

<h3 id="从Git仓库引入"><a href="#从Git仓库引入" class="headerlink" title="从Git仓库引入"></a>从Git仓库引入</h3><p>顾名思义，直接从Git仓库拉取plugin，可以指定分支及路径。企业内部引用可以使用此种方式。样例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">disable_screenshots:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">https://github.com/xx-li/disable_screenshots</span></span><br><span class="line">		<span class="attr">path:</span> <span class="string">path/to/disable_screenshots</span>  <span class="comment">#这里只做说明，实际disable_screenshots插件在根目录，不需要指定路径。</span></span><br></pre></td></tr></table></figure>


<h3 id="官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using-packages-Flutter"><a href="#官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using-packages-Flutter" class="headerlink" title="官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using packages  - Flutter"></a>官方pub引入及指定源引入这里不做说明，详情可以看官方教程：<a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages" target="_blank" rel="noopener">Using packages  - Flutter</a></h3><h2 id="问题备忘"><a href="#问题备忘" class="headerlink" title="问题备忘"></a>问题备忘</h2><ol>
<li>在老的flutter项目中，在iOS平台运行可能出现编译问题无法运行。这个是由于老的flutter项目里面没有使用到swift，所以没有briging文件，但是插件使用了swift，所以会编译失败，这种情况直接使用xcode在iOS项目中创建一个swift文件，会自动生成briding文件。<br><img src="bridging.png" alt=""></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/huiger/ScreenShotDemo" target="_blank" rel="noopener">GitHub - huiger/ScreenShotDemo: 🔥Android 手机应用内截屏, 截屏监听</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/Experimental:-Create-Flutter-Plugin" target="_blank" rel="noopener">Experimental: Create Flutter Plugin · flutter/flutter Wiki · GitHub</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages" target="_blank" rel="noopener">Using packages  - Flutter</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages" target="_blank" rel="noopener">Developing packages &amp; plugins  - Flutter</a></li>
<li><a href="https://flutter.dev/docs/development/platform-integration/platform-channels#example-project" target="_blank" rel="noopener">Writing custom platform-specific code  - Flutter</a></li>
<li><a href="https://fiissh.tech/2019/flutter-basic-message-channel.html" target="_blank" rel="noopener">Flutter 开发（14）：BasicMessageChannel 的使用 | 肥言肥语</a></li>
<li><a href="https://stackoverflow.com/questions/60048704/how-to-get-activity-and-context-in-flutter-plugin" target="_blank" rel="noopener">dart - How to get Activity and Context in Flutter plugin - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>对独立开发的思考</title>
    <url>/2021/03/01/%E5%AF%B9%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="独立开发经历"><a href="#独立开发经历" class="headerlink" title="独立开发经历"></a>独立开发经历</h3><h5 id="第一个小程序项目"><a href="#第一个小程序项目" class="headerlink" title="第一个小程序项目"></a>第一个小程序项目</h5><p>我在17年的时候买人生的第一套房，是一套二手房，当时对二手房的各项交易费用一知半解，感觉自己就像一头屠宰桌上的猪，任人宰割。刚好那个时候微信小程序开始兴起，基于学习兴趣和需求，做了一个计算购房费用的小程序（在微信上搜索“首付款计算器”可以看到）。做出来后找了一个中介朋友，让他以激活码的方式帮我销售，收入五五分成，他帮我销售了几份后反馈有的客户没法安装（微信版本异常），有的客户有异常问题（非技术问题）。那个时候刚好工作比较忙，又觉得整这些事情太麻烦了（收益低），就没有更新和维护这个项目了。</p>
<h5 id="第二个跨平台项目"><a href="#第二个跨平台项目" class="headerlink" title="第二个跨平台项目"></a>第二个跨平台项目</h5><p>在20年的时候，由于年龄的逐渐增长，开始考虑去扩展一些额外的收入点。那个时候刚好在学习<code>Flutter</code>，就想用<code>Flutter</code>对之前的项目进行重构，做市面上<code>最专业的购房费用计算器</code>。当时的初衷是想从开发到发布，系统的学习一项新技能，另外就是看能不能赚点钱。但是实际情况和我预想的有点偏差，我增加了很多预想之外的需求。</p>
<a id="more"></a>

<p>一开始只想支持长沙的新房和二手房费用计算，但是做到后面想支持北上广深，因为这意味着更大的市场。为了支持不同城市，我对计算层进行了重构，引入了词法分析，支持不同的城市根据配置数据进行费用计算（不同城市的费用不一样），而这又引入了新的问题，配置下发和更新需要接口提供支持。<br>然后我决定用<code>Go</code>开发后台，我自学了<code>Go</code>的语法和<code>Beego</code>框架，然后又学习了<code>Docker</code>，编写了部署脚本，把后台部署在了自己购买的云服务器上面。</p>
<p>后面想到都有接口了，干脆开发一套用户体系，对计算结果进行收藏和管理吧，于是开发了用户体系，对计算层又进行了修改，支持修改和列表显示，加入了版本升级、用户反馈等常规功能。</p>
<p>这些对于技术人来说，都是轻车熟路，不熟悉的地方查查文档也能解决。最麻烦的地方在于不同城市的费用计算规则，一般人觉得购房就是一些税费什么的很简单，但是我当时是想做市面上最专业的购房计算器，需要支持住宅、商业的计算，然后购房者、卖房者有个人（非中国籍、中国籍）、公司（大公司、小公司）、机构等各种情况，实际上是非常复杂的。我伪装成购房者在各大购房平台咨询中介费用问题，但是有些问题中介也不清楚，还有些问题不同中介回复的不一样，最终没有办法，只有跑到当地的房管局进行咨询确认，所以最终这个项目只支持了长沙和深圳的费用计算。</p>
<p>项目完成后iOS端顺利发布到了AppStore，Android端在各大应用商店发布需要软著，后面就没有发了，自己通过云存储部署了一个简单的H5页面来进行Android端的分发。在这里不得不说AppStore的强大，在我没有做推广的情况下，还是有一定的下载量（付费下载），让我收回了购买Apple开发者账号的成本。</p>
<h3 id="对独立开发的反思"><a href="#对独立开发的反思" class="headerlink" title="对独立开发的反思"></a>对独立开发的反思</h3><p>以上是我做项目的前期，但是我完全没有考虑清楚项目后期的事情，那就是维护和营销。在我们的工作中，经常接触到这两个词，也知道是什么意思，但是在自己的个人项目中，你对这两个词有可能会有完全不一样的理解。我开始思考自己这个项目的意义，是用于学习技术还是为了赚钱？是为了做一个好的产品还是为了炫技？</p>
<p>所幸我看了一篇公众号文章<a href="https://mp.weixin.qq.com/s/pNbyg3BPF1iaHBeMYWc8zQ" target="_blank" rel="noopener">和软件开发相关的一些思考</a>，作者叫<code>liuyubobobo</code>，我很喜欢的一位开发者。文章中有一小段视频：<a href="https://v.qq.com/x/page/p3124yg5fm7.html" target="_blank" rel="noopener">97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？</a>，我觉得自己就像是这个视频中的程序员，讲着一堆牛逼的技术术语，但实际上却不知道如何做好一个项目。后面经过思考，我发现自己犯了如下错误：</p>
<ol>
<li>没有想清楚是要学习还是要赚钱。抱着又想学习又想赚钱的想法，两头都没有做好。</li>
<li>盲目的给项目引入了过多的技术，导致后续维护成本很高。个人开发者没有必要维护自己的后台，更没有必要维护一套自建的用户体系，使用对应平台的云接口，稳定，开发效率高。</li>
<li>进入了一个自己不熟悉的领域（房产），我需要学习新的知识，还要跟上数据更新的步伐，不停的去学习。我分析一些做的好的个人开发者，都是做的工具类的软件，不需要把精力花费在陌生领域的学习，可以把精力集中在打磨产品的体验方面。</li>
<li>选择以App的承载方式来做这个项目是错误的，微信小程序才是最好的方案。（给好几个朋友推荐，都是反问，你为什么不做成微信小程序类？）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做一个好的产品，应该从用户体验出发，去思考能给用户提供什么？能给用户带来什么？然后再倒推用什么技术，在人力与资源受限时，我们要学会借力于平台，使用稳定可靠的技术。让用户打开我们产品的时候，都会说：太好了，这就是我想要的！而不是坐在那里，想着自己有什么吊炸天的技术，然后怎么把它卖出去。<br>另外关于营销，我觉得其中的学问是不亚于技术的，需要持续的学习和实践，像我17年的小程序项目那样，能找到一个专业的销售人员绑定在一起，对产品的销售是很有帮助的。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><a href="http://qiniu.devlxx.com/index.html" target="_blank" rel="noopener">个人项目下载地址</a></li>
<li><a href="https://v.qq.com/x/page/p3124yg5fm7.html" target="_blank" rel="noopener">97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？</a></li>
<li><a href="https://mp.weixin.qq.com/s/pNbyg3BPF1iaHBeMYWc8zQ" target="_blank" rel="noopener">和软件开发相关的一些思考</a></li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Aspects框架的源码解读及问题解析</title>
    <url>/2021/10/18/Aspects%E6%A1%86%E6%9E%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS日常开发中，对某些方法进行hook是很常见的操作。最常见的是使用Category在<code>+load</code>中进行方法swizzle，它是针对类的，会改变这个类所有实例的行为。但是有时候我们只想针对单个实例进行hook，这种方法就显得无力了。而<code>Aspects</code>框架可以搞定这个问题。<br>它的原理是通过<code>Runtime</code>动态的创建子类，把实例的<code>isa</code>指针指向新创建的子类，然后在子类中对hook的方法进行处理，这样就支持了对单个实例的hook。<code>Aspects</code>框架支持对类和实例的hook，API很易用，可以方便的让你在任何地方进行hook，是线程安全的。但是<code>Aspects</code>框架也有一些缺陷，一不小心就会掉坑里面，我会通过源码解析进行说明。</p>
<a id="more"></a>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>我主要使用图示对<code>Aspects</code>的源码进行说明，建议参考源码一起查看。要看懂这些内容，需要对<code>isa指针</code>，<code>消息转发机制</code>，<code>runtime</code>有一定的了解，本文中不会对这些内容展开来讲，因为要把这些东西讲清楚，每一项都需要单独写一篇文章了。</p>
<h3 id="主要流程解析"><a href="#主要流程解析" class="headerlink" title="主要流程解析"></a>主要流程解析</h3><ol>
<li>它第一个流程是使用关联对象添加<code>Container</code>，在这个过程中会进行一些前置条件的判断，例如这个方法是否支持被hook等，如果条件验证通过，就会把这次hook的信息保存起来，在方法调用的时候，查询出来使用。</li>
<li>第二个流程是动态创建子类，如果是针对类的hook，则不会走这一步。</li>
<li>第三步是替换这个类的<code>forwardInvocation:</code>方法为<code>__ASPECTS_ARE_BEING_CALLED__</code>，这个方法内部会查找到之前创建的Container，然后根据Container中的逻辑进行实际的调用。</li>
<li>第四步是将原有方法的<code>IMP</code>改为<code>_objc_msgForward</code>，改完后当调用原有方法时，就会调用<code>_objc_msgForward</code>，从而触发<code>forwardInvocation:</code>方法。</li>
</ol>
<p>我对它的流程做了一个简化的图示，标有每个流程的序号，后面会对每个流程进行解析。流程如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101110315.png" alt=""></p>
<p>图示中的<code>取出对象类型</code>，是指的调用hook的对象的类型，如果是<code>实例对象</code>，那么就走<code>类</code>路径；如果是<code>类</code>对象，则走<code>元类</code>路径；如果是<code>kvo</code>等实际类型不一致的情况，则走<code>其它子类</code>路径。</p>
<h3 id="①添加Container流程"><a href="#①添加Container流程" class="headerlink" title="①添加Container流程"></a>①添加Container流程</h3><p>这个流程中，把hook的逻辑封装成Container，并使用关联对象进行保存。这个过程中会判断hook的方法是否被支持、判断被hook类的继承关系、验证回调block正确性等操作。具体图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101112238.png" alt=""></p>
<p>关键代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    aspect_performLocked(^&#123; <span class="comment">// 加锁</span></span><br><span class="line">        <span class="comment">// hook前置条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 用selector作key，通过关联对象获得Container对象。</span></span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="comment">// 内部会判断block与hook的selector是否匹配，不匹配返回nil。</span></span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="comment">// 添加identifier，包含了hook的类型和回调。 </span></span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *disallowedSelectorList;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        disallowedSelectorList = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"retain"</span>, <span class="string">@"release"</span>, <span class="string">@"autorelease"</span>, <span class="string">@"forwardInvocation:"</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里对不支持hook的方法进行过滤</span></span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Selector %@ is blacklisted."</span>, selectorName];</span><br><span class="line">        AspectError(AspectErrorSelectorBlacklisted, errorDescription);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dealloc只支持AspectPositionBefore类型下调用</span></span><br><span class="line">    AspectOptions position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@"dealloc"</span>] &amp;&amp; position != AspectPositionBefore) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = <span class="string">@"AspectPositionBefore is the only valid position when hooking dealloc."</span>;</span><br><span class="line">        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="keyword">self</span>.class instancesRespondToSelector:selector]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to find selector -[%@ %@]."</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class), selectorName];</span><br><span class="line">        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里禁止有继承关系的类hook同一个方法，代码量较多，不是关键内容，这里不贴出</span></span><br><span class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// AspectsContainer内部添加AspectIdentifier的实现。</span></span><br><span class="line"><span class="comment">/// 这里可以看出对同一个方法的多次hook都会被调用，不会出现后面hook的覆盖前面的情况。</span></span><br><span class="line">- (<span class="keyword">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(aspect);</span><br><span class="line">    <span class="built_in">NSUInteger</span> position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionBefore:  <span class="keyword">self</span>.beforeAspects  = [(<span class="keyword">self</span>.beforeAspects ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionInstead: <span class="keyword">self</span>.insteadAspects = [(<span class="keyword">self</span>.insteadAspects?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionAfter:   <span class="keyword">self</span>.afterAspects   = [(<span class="keyword">self</span>.afterAspects  ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从源码中可以看到，不支持的hook方法有<code>[NSSet setWithObjects:@&quot;retain&quot;, @&quot;release&quot;, @&quot;autorelease&quot;, @&quot;forwardInvocation:&quot;, nil];</code>。其中<code>retain</code>, <code>release</code>, <code>autorelease</code>在arc下是被禁用的，框架本身是<code>hook</code>了<code>forwardInvocation:</code>进行实现的，所以对它的hook也不支持。</li>
<li><code>dealloc</code>只支持<code>AspectPositionBefore</code>类型，使用<code>AspectPositionInstead</code>会导致系统默认的<code>dealloc</code>操作被替换无法执行而出现问题。 <code>AspectPositionAfter</code>类型，调用时对象可能已经已经被释放了，从而引发野指针错误。</li>
<li><code>Aspects</code>禁止有继承关系的类hook同一个方法，具体可以参见它的一个<a href="https://github.com/steipete/Aspects/issues/2" target="_blank" rel="noopener">issue</a>，它报告了这样操作会导致死循环，我会在文章后面再进行说明。</li>
<li><code>Aspects</code>使用<code>block</code>进行hook的调用，涉及到方法参数的传递和返回值问题，所以其中会对block进行校验。</li>
</ol>
<h3 id="②runtime创建子类"><a href="#②runtime创建子类" class="headerlink" title="②runtime创建子类"></a>②runtime创建子类</h3><p>iOS中的<code>KVO</code>就是通过<code>runtime</code>动态创建子类，然后在子类中重写对应的<code>setter</code>方法来实现的，<code>Aspects</code>支持对单个实例的hook原理与此有一些类似。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101141441.png" alt=""><br>具体说明请查看源码中的注释</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行hook</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// 针对实例类型，会通过runtime动态创建子类。类类型则直接hook。</span></span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">	Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">	<span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经被hook过的类，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">		<span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是元类(MetaClass)，则代表是对类进行hook。（非单个实例）</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="comment">// 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// 可能是一个KVO对象等情况，传入实际的类型进行hook。</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个实例的情况，动态创建子类进行hook.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">		aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">        <span class="comment">// 重写class方法，返回之前的类型，而不是新创建的子类。避免hook后，类型判断出现问题。</span></span><br><span class="line">		aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">		objc_registerClassPair(subclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">	<span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③替换forwardInvocation"><a href="#③替换forwardInvocation" class="headerlink" title="③替换forwardInvocation:"></a>③替换forwardInvocation:</h3><p>这部分就是把原有的<code>forwardInvocation:</code>替换为自定义的实现：<code>__ASPECTS_ARE_BEING_CALLED__</code>。源码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> AspectsForwardInvocationSelectorName = <span class="string">@"__aspects_forwardInvocation:"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// If there is no method, replace will act like class_addMethod.</span></span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(<span class="string">@"Aspects: %@ is now aspect aware."</span>, <span class="built_in">NSStringFromClass</span>(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换后的对应关系图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101143612.png" alt=""></p>
<h3 id="④hook方法交换IMP"><a href="#④hook方法交换IMP" class="headerlink" title="④hook方法交换IMP:"></a>④hook方法交换IMP:</h3><p>图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101144025.png" alt=""></p>
<p>第③步和第④步可能有些同学会感到疑惑，为什么要替换<code>forwardInvocation</code>以及为什么要将hook的方法的<code>IMP</code>替换为<code>_objc_msgForward</code>，这个和iOS的<code>消息转发机制</code>有关，可以自行查找相关资料，这里就不做说明了。需要注意的是有些框架也是通过iOS的消息发送机制来做一些操作，例如<code>JSPatch</code>，使用的时候需要注意，避免发生冲突。</p>
<h3 id="被hook方法的调用流程"><a href="#被hook方法的调用流程" class="headerlink" title="被hook方法的调用流程"></a>被hook方法的调用流程</h3><p>当hook注入后，对hook方法进行调用时，调用流程就会发生变化。图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101145147.png" alt=""></p>
<p>从上述解析过程中，我们可以看到<code>Aspects</code>这个框架是设计的很巧妙的，从中可以看到非常多<code>runtime</code>知识的应用。但是作者并不推荐在实际项目中进行使用：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101145635.png" alt=""></p>
<p>因为Apsects对类的底层进行了修改，这种修改是基础方面的修改，需要考虑到各种场景和边界问题，一旦某方面考虑不周，就会引发出一些未知问题。另外这个框架是有缺陷的，很久没有进行更新了，我对它的已知问题点进行了总结，在下面进行说明。如果有未总结到位的，欢迎补充。</p>
<h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><h3 id="基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。"><a href="#基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。" class="headerlink" title="基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。"></a>基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。</h3><p>之前这样会出现死循环，后面作者进行了修改，对这个行为进行了<code>禁止</code>并加了错误提示。详见这个<a href="https://github.com/steipete/Aspects/issues/2" target="_blank" rel="noopener">issue</a></p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    [<span class="keyword">super</span> foo]; <span class="comment">// 导致死循环的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    [B aspect_hookSelector:<span class="keyword">@selector</span>(foo) atPosition:AspectPositionBefore withBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSArray</span> *arguments) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"before -[B foo]"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [A aspect_hookSelector:<span class="keyword">@selector</span>(foo) atPosition:AspectPositionBefore withBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSArray</span> *arguments) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"before -[A foo]"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    B *b = [[B alloc] init];</span><br><span class="line">    [b foo]; <span class="comment">// 调用后死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道，<code>super</code>是从它的父类开始查找方法，然后传入<code>self</code>进行调用。 根据我们之前对源码的解析，在这里调用<code>[super foo]</code>后会从父类查找<code>foo</code>的<code>IMP</code>，查到后发现父类的<code>IMP</code>已经被替换为<code>_objc_msgForward</code>，然后传入<code>self</code>调用。 因为是传入的<code>self</code>，所以实际会调用到它自身的<code>forwardInvocation:</code>，这样就导致了死循环。</p>
<h3 id="针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。"><a href="#针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。" class="headerlink" title="针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。"></a>针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。</h3><p>这里通过代码进行说明，以Animal对象为例：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testKVO &#123;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"Animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"observeValueForKeyPath keypath:%@ name:%@"</span>, keyPath, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [animal testKVO];</span><br><span class="line">        <span class="comment">// 这里如果改为针对类进行hook，则不会存在问题，因为类hook修改的是Animal类，而实例hook修改的是NSKVONotifying_Animal类</span></span><br><span class="line">        [animal aspect_hookSelector:<span class="keyword">@selector</span>(setName:) </span><br><span class="line">                        withOptions:AspectPositionAfter </span><br><span class="line">                         usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo, <span class="built_in">NSString</span> *name)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="comment">// 这里会crash</span></span><br><span class="line">        animal.name = <span class="string">@"ChangedAnimalName"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常原因分析图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101165246.png" alt=""></p>
<p>上面是继承链和方法调用流程的图示，可以看出，<code>_NSSetObjectValueAndNotify</code>是被<code>aspects__setName:</code>调用的，<code>_NSSetObjectValueAndNotify</code>的内部实现逻辑是取调用它的<code>selector</code>，去父类查找方法，即<code>aspects__setName:</code>方法，而<code>Animal</code>对象并没有这个方法的实现，这就导致了crash。</p>
<h3 id="与category的共存问题"><a href="#与category的共存问题" class="headerlink" title="与category的共存问题"></a>与category的共存问题</h3><p>先用<code>aspects</code>进行hook，再使用<code>category</code>进行hook，会导致crash。反之则没有问题。样例代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span>(<span class="title">hook</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)categoryHook;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span>(<span class="title">hook</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)categoryHook &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">super</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(setName:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(lx_setName:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lx_setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span> lx_setName:name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [Animal aspect_hookSelector:<span class="keyword">@selector</span>(setName:) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo, <span class="built_in">NSString</span> *name)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [Animal categoryHook];</span><br><span class="line">        <span class="comment">// 调用后crash：[Animal lx_setName:]: unrecognized selector sent to instance 0x100608dc0</span></span><br><span class="line">        animal.name = <span class="string">@"ChangedAnimalName"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个与<code>__ASPECTS_ARE_BEING_CALLED__</code>的内部逻辑有关，里面会对调用的方法添加前缀<code>aspect__</code>进行调用，以调用到原始的<code>IMP</code>，但是<code>category</code> hook后破坏了这个流程。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101182740.png" alt=""></p>
<p>根据上述图示，实际只有<code>aspects__setName</code>，没有<code>aspects__lx_setName</code>，导致找不到方法而crash</p>
<h3 id="基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下："><a href="#基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：" class="headerlink" title="基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下："></a>基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：</h3><figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [Animal aspect_hookSelector:<span class="keyword">@selector</span>(testInstanceMethod) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook testInstanceMethod"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [object_getClass([Animal <span class="keyword">class</span>]) aspect_hookSelector:<span class="keyword">@selector</span>(testClassMethod) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook testClassMethod"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [animal testInstanceMethod];</span><br><span class="line">        <span class="comment">// crash: "+[Animal testClassMethod]: unrecognized selector sent to class 0x1000114a0"</span></span><br><span class="line">        [Animal testClassMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的调用在日常开发中非常正常，但是它会导致crash。它是由于<code>aspect_swizzleClassInPlace</code>方法中的逻辑缺陷导致的。</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_swizzleClassInPlace(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// Animal类对象与Animal元类对象会得到同一个字符串。</span></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"aspect_swizzleClassInPlace %@ %p"</span>, klass, object_getClass(klass));</span><br><span class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</span><br><span class="line">        <span class="comment">// 类对象和元类对象得到同一个className，这里后加入的会被错误的过滤掉。</span></span><br><span class="line">        <span class="keyword">if</span> (![swizzledClasses containsObject:className]) &#123;</span><br><span class="line">            aspect_swizzleForwardInvocation(klass);</span><br><span class="line">            [swizzledClasses addObject:className];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> klass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看到，它的去重逻辑只是简单的字符串判断，取Animal的<code>元类</code>和<code>类</code>名得到同一个字符串<code>Animal</code>，导致后添加的被过滤，当调用后被hook的方法后，执行<code>_objc_msgForward</code>，因为后hook的<code>aspect_swizzleForwardInvocation</code>被过滤了没有执行，所以找不到<code>forwardInvocation:</code>的<code>IMP</code>，导致了crash。</p>
<h3 id="objc-msgForward会出现冲突的问题"><a href="#objc-msgForward会出现冲突的问题" class="headerlink" title="_objc_msgForward会出现冲突的问题"></a>_objc_msgForward会出现冲突的问题</h3><p>内部是通过消息转发机制来实现的，使用时要注意，避免与其它使用<code>_objc_msgForward</code>或相关逻辑的框架发生冲突。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>hook后的方法，通过原有消息机制找到<code>IMP</code>后，并不会直接调用。而是会进行消息转发进入到<code>__ASPECTS_ARE_BEING_CALLED__</code>方法，内部再通过key取出相应的<code>Coantiner</code>进行调用，相对于未hook之前，额外增加了调用成本。所以不建议对频繁调用的方法和在项目中大量使用。</p>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><p>框架内部为了保证线程安全，有进行加锁，但是使用的是自旋锁<code>OSSpinLock</code>，存在线程反转的问题，在iOS10已经被标记为弃用。</p>
<h3 id="对类方法的hook，需要使用object-getClass来获取元类对象进行hook"><a href="#对类方法的hook，需要使用object-getClass来获取元类对象进行hook" class="headerlink" title="对类方法的hook，需要使用object_getClass来获取元类对象进行hook"></a>对类方法的hook，需要使用object_getClass来获取元类对象进行hook</h3><p>这个不是框架问题，而是有些同学不知道如何对<code>类方法</code>进行hook，这里进行说明。</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要通过object_getClass来获取元类对象进行hook</span></span><br><span class="line">[object_getClass(Animal) aspect_hookSelector:<span class="keyword">@selector</span>(testClassMethod)     </span><br><span class="line">                                 withOptions:AspectPositionAfter </span><br><span class="line">                                  usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">&#125; error:null];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>M1设备的Xcode编译问题深究</title>
    <url>/2021/12/02/M1%E8%AE%BE%E5%A4%87%E7%9A%84Xcode%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E6%B7%B1%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><p>在<code>Apple</code>发布<code>M1</code>芯片之前，一直使用<code>Intel</code>的芯片，没有出现什么问题。发布<code>M1</code>芯片后，由于两者架构的不同（<code>M1</code>是<code>arm64</code>架构，<code>Intel</code>是<code>x86_64</code>的架构），导致很多软件运行出现了问题。我们在<code>M1</code>机型中使用<code>Xcode</code>编译模拟器时，可能会碰到如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld: in youpath&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon(UMComBaseEvent.o), building for iOS Simulator, but linking in object file built for iOS, file &#39;&#x2F;Users&#x2F;mtgj&#x2F;Desktop&#x2F;TestArch1&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon&#39; for architecture arm64</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld: warning: ignoring file YoupPth&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;FMDB&#x2F;FMDB.framework&#x2F;FMDB, building for iOS Simulator-x86_64 but attempting to link with file built for iOS Simulator-arm64</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_OBJC_CLASS_$_FMDatabaseQueue&quot;, referenced from:</span><br><span class="line">      objc-class-ref in SqflitePlugin.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>

<p>这些报错，都是是由于项目中存在<code>.a</code>或<code>.framework</code>静态库导致的。以前，我们创建静态库时，会分别打包出一份针对真机（arm64）和模拟器的（x86_64），然后将这两份合并成一个包后引入项目中进行使用。在<code>Intel</code>机型上，真机上使用<code>arm64</code>指令，模拟器（x86_64）中使用<code>x86_64</code>指令，所以不存在问题。但是在<code>M1</code>机型上，模拟器是以<code>arm64</code>运行的，显然再以<code>x86_64</code>运行就会出现问题。</p>
<a id="more"></a>

<blockquote>
<p>有同学可能会想到包中是有<code>arm64</code>指令（真机）的，拿给以<code>arm64</code>运行的模拟器使用不就可以了吗？ 实际上xcode底层并不是这样处理的，它真机就找真机的，模拟器就找模拟器的。</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><p>对于这类架构报错问题，网上的资料一般会告诉你两个解决方案：</p>
<ol>
<li>以Rosetta模式运行Xcode。</li>
<li>修改<code>Build Settings</code> -&gt; <code>Excluded Architectures</code>选项，添加Any iOS Simulator SDK选项，并设置值为arm64。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211202153049.png" alt=""></li>
</ol>
<p>这两种方案都能解决编译问题，但是也都存在问题。</p>
<blockquote>
<p>在iOS12及以后，不再支持iphone5及以下机型，而后续的机型都是arm64架构，所以这里不再对之前的armv6/armv7/armv7s/i386 等指令集进行说明。</p>
</blockquote>
<h3 id="Rosetta方案说明"><a href="#Rosetta方案说明" class="headerlink" title="Rosetta方案说明"></a>Rosetta方案说明</h3><p>以<code>Rosetta</code>模式运行是<code>M1</code>机器上<code>x86</code>软件无法运行的解决方案，它会将<code>x86</code>指令转译成<code>ARM</code>指令运行，这种转译显然是存在性能损耗的，损耗大概在<code>20%～30%</code>，详情可参考文章：<a href="https://www.huxiu.com/article/393879.html" target="_blank" rel="noopener">苹果换芯，成了开发者们的噩梦？</a>，不到万不得已，不推荐使用这种方案。</p>
<h3 id="Excluded-Architectures方案说明"><a href="#Excluded-Architectures方案说明" class="headerlink" title="Excluded Architectures方案说明"></a>Excluded Architectures方案说明</h3><p>修改<code>Excluded Architectures</code>选项也有它的问题。字面意思是排除架构的意思，我们设置在模拟器中排除<code>arm64</code>就能解决模拟器无法编译<code>arm64</code>的问题。</p>
<p>这样的设置能生效会让人有点费解，我们知道，在intel机型上，模拟器本来就是以<code>x86</code>方式运行的，排除<code>arm64</code>毫无影响。但是在<code>M1</code>机型上，模拟器是以<code>arm64</code>方式运行的，排除了<code>arm64</code>反而能跑，这不是把我的智商摁在地上摩擦么？，但是苹果就是这样干的，当在<code>M1</code>机型上，排除了模拟器的<code>arm64</code>架构后，模拟器还是会以<code>arm64</code>的方式运行，但是模拟器中的app是以<code>x86</code>的方式运行的，对苹果的这个骚操作我们不得不服。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211202161515.png" alt=""></p>
<blockquote>
<p>这种情况下，模拟器和应用会通过<code>XPC</code>进行通信，虽然理论上不会有问题，但通信时间会比较长，导致一些依赖计时器判断的逻辑会出问题，例如滑动手势，加速度的判断会出一些问题，导致模拟器里大部分情况下列表无法触发惯性滚动。 - by kem</p>
</blockquote>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>有时候在<code>Excluded Architectures</code>选项中排除了模拟器的<code>arm64</code>指令，依然无法编译通过，那么一般是项目设置和cocoapods的设置不一致导致，设置为一致后一般可以解决问题。可以通过在<code>Podfile</code>中添加如下内容来解决：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">      config.build_settings[<span class="string">'EXCLUDED_ARCHS[sdk=iphonesimulator*]'</span>] = <span class="string">"arm64"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h2 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h2><p>通过上述内容，我们知道了问题的由来，它是由于项目中存在<code>.a</code>或<code>.framework</code>，它们提供的指令集不完整导致的。Apple对于这类问题，也提供了解决方案，请由我细细道来。</p>
<p>以Xcode13为例，在我们创建静态库时，选择真机编译出来的包只包含<code>arm64</code>指令，选择模拟器编译出来的会同时包含<code>arm64</code>和<code>x86_64</code>指令。我看一些网上的教程，教别人将模拟器部分的<code>arm64</code>移除，其实大可不必。因为要支持<code>M1</code>机器正常跑模拟器，模拟器必须同时包含<code>arm64</code>和<code>x86_64</code>指令。</p>
<p>2019年的<code>WWDC</code>，<code>apple</code>提供了一种新的框架封装格式<code>XCFramework</code>。简单理解就是以前使用<code>lipo</code>合并不同指令集的包，现在则使用新的指令合并成<code>XCFramework</code>格式。</p>
<p>打包成<code>framework</code>，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree Release-iphoneos/TestFramework.framework</span></span><br><span class="line">Release-iphoneos/TestFramework.framework</span><br><span class="line">├── Headers</span><br><span class="line">│   ├── TestFramework.h</span><br><span class="line">│   └── TestManager.h</span><br><span class="line">├── Info.plist</span><br><span class="line">├── Modules</span><br><span class="line">│   └── module.modulemap</span><br><span class="line">└── TestFramework</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree Release-iphonesimulator/TestFramework.framework</span></span><br><span class="line">Release-iphonesimulator/TestFramework.framework</span><br><span class="line">├── Headers</span><br><span class="line">│   ├── TestFramework.h</span><br><span class="line">│   └── TestManager.h</span><br><span class="line">├── Info.plist</span><br><span class="line">├── Modules</span><br><span class="line">│   └── module.modulemap</span><br><span class="line">├── TestFramework</span><br><span class="line">└── _CodeSignature</span><br><span class="line">    ├── CodeDirectory</span><br><span class="line">    ├── CodeRequirements</span><br><span class="line">    ├── CodeRequirements-1</span><br><span class="line">    ├── CodeResources</span><br><span class="line">    └── CodeSignature</span><br></pre></td></tr></table></figure>
<p>打包成<code>XCFramework</code>后，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree TestFramework.xcframework</span></span><br><span class="line">TestFramework.xcframework</span><br><span class="line">├── Info.plist</span><br><span class="line">├── ios-arm64</span><br><span class="line">│   └── TestFramework.framework</span><br><span class="line">│       ├── Headers</span><br><span class="line">│       │   ├── TestFramework.h</span><br><span class="line">│       │   └── TestManager.h</span><br><span class="line">│       ├── Info.plist</span><br><span class="line">│       ├── Modules</span><br><span class="line">│       │   └── module.modulemap</span><br><span class="line">│       └── TestFramework</span><br><span class="line">└── ios-arm64_x86_64-simulator</span><br><span class="line">    └── TestFramework.framework</span><br><span class="line">        ├── Headers</span><br><span class="line">        │   ├── TestFramework.h</span><br><span class="line">        │   └── TestManager.h</span><br><span class="line">        ├── Info.plist</span><br><span class="line">        ├── Modules</span><br><span class="line">        │   └── module.modulemap</span><br><span class="line">        ├── TestFramework</span><br><span class="line">        └── _CodeSignature</span><br><span class="line">            ├── CodeDirectory</span><br><span class="line">            ├── CodeRequirements</span><br><span class="line">            ├── CodeRequirements-1</span><br><span class="line">            ├── CodeResources</span><br><span class="line">            └── CodeSignature</span><br></pre></td></tr></table></figure>
<p>从上述可以看出，<code>XCFramework</code>就是把两个不同指令集的<code>framework</code>放入了同一个文件夹(<code>.xcframework</code>)，并生成了一个配置文件<code>Info.plist</code>。这样生成的<code>XCFramework</code>就可以完美的解决<code>M1</code>机器无法编译模拟器的问题。</p>
<p><code>XCFramework</code>的创建指令也很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -- 针对.a --</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指令：</span></span><br><span class="line">xcodebuild -create-xcframework -library &lt;path&gt; [-headers &lt;path&gt;] [-library &lt;path&gt; [-headers &lt;path&gt;]...] -output &lt;path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 样例：</span></span><br><span class="line">xcodebuild -create-xcframework -library youpath/TestFramework.a -headers youpath/TestFramework -library youpath/TestFramework.a -headers youpath/TestFramework -output youpath/TestFramework.xcframework</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -- 针对.framework --</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指令：</span></span><br><span class="line">xcodebuild -create-xcframework -framework &lt;path&gt; [-framework &lt;path&gt;...] -output &lt;path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 样例：</span></span><br><span class="line">xcodebuild -create-xcframework -framework Release-iphoneos/TestFramework.framework -framework Release-iphonesimulator/TestFramework.framework -output TestFramework.xcframework</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决<code>M1</code>机型无法编译模拟器的关键就是针对模拟器的包要同时包含<code>arm64</code>和<code>x86_64</code>指令集。如果使用只支持<code>x86_64</code>指令集的模拟器包，就算打包成<code>XCFramework</code>也会依然存在这个问题。</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以现在的情况，很多第三方框架，并没有使用<code>XCFramework</code>，而项目中只要有一个框架没有支持模拟器的<code>arm64</code>指令，那么在<code>M1</code>机器上，模拟器只能以<code>Rosetta</code>模式运行应用，对这一块的普遍支持估计要等M1普及以后了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.huxiu.com/article/393879.html" target="_blank" rel="noopener">苹果换芯，成了开发者们的噩梦？</a></li>
<li><a href="https://blog.csdn.net/tony_vip/article/details/105889734" target="_blank" rel="noopener">armv6、armv7、armv7s、armv8、armv64及其i386、x86_64区别</a></li>
<li><a href="https://juejin.cn/post/6844904031937101838" target="_blank" rel="noopener">细说iOS静态库和动态库</a></li>
<li><a href="https://juejin.cn/post/6844904021430370312" target="_blank" rel="noopener">关于Xcode11的XCFrameworks框架</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议是怎么实现的？</title>
    <url>/2021/12/23/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上层应用开发中，<code>HTTP</code>协议可以说是最常见，使用最频繁的网络协议了。在网上也有非常多的文章进行解读，但是大部分都是讲解<code>HTTP</code>协议的内容和使用，很少有人讲<code>HTTP</code>协议是怎么实现的。网络协议可以涉及很大的广度和深度，不是一篇文章就能讲清楚的，我这里更多的是提供一个思路供读者来思考。本篇文章会基于<code>iOS</code>平台来进行说明，但是并不代表这篇文章只针对<code>iOS</code>开发，因为协议是跨平台的，其中涉及到的编程思想也是。本文会分四个部分进行讲解：</p>
<ol>
<li>第一部分：数据是如何在网络上进行传输的。这部分主要让你对<code>网络模型</code>和各层协议有一个基础的了解，如果您对这部分比较了解，可以直接从第二部分看起。</li>
<li>第二部分：<code>HTTP</code>协议数据是如何转换为<code>TCP</code>数据收发的。</li>
<li>第三部分：<code>HTTP</code>协议中<code>Request</code>和<code>Response</code>的解析和相关逻辑处理。</li>
<li>第四部分：修改<code>HTTP</code>底层实现，完成自有需求。</li>
</ol>
<a id="more"></a>

<h2 id="数据是如何在网络上进行传输的"><a href="#数据是如何在网络上进行传输的" class="headerlink" title="数据是如何在网络上进行传输的"></a>数据是如何在网络上进行传输的</h2><p>数据遵循网络协议进行收发，讲到网络协议，就绕不开<code>OSI模型</code>和<code>TCP/IP参考模型</code>，它们有不同的层次划分，<code>OSI模型</code>分为7层，<code>TCP/IP参考模型</code>分为4层。网上有很多将<code>TCP/IP参考模型</code>映射到<code>OSI模型</code>的说法，由于<code>TCP/IP参考模型</code>和<code>OSI模型</code>不能精确地匹配，还没有一个完全正确，或者说权威的答案，一般认为的对应关系图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211225201250.png" alt=""></p>
<p>HTTP协议属于最上层<code>应用层</code>，<code>网络模型</code>是比较抽象的，在实际编码时，上层应用的开发者一般只接触到应用层，开发者只需要把一个<code>HTTP Reques</code>丢入网络框架，请求完成后就会返回一个<code>HTTP Response</code>，但是它的底层是怎么实现的类？我们先看下图：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223163145.png" alt=""><br>从上图我们可以看到HTTP数据是如何在客户端与服务端之间交互的，网络模型虽然很复杂，但是从某个角度看，可以说是”套娃”，在<code>RFC 1122</code>中描述的沿着不同的层应用数据的封装递减图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223151159.png" alt=""><br>上图中最上层的<code>Data</code>数据代表应用层协议数据，在<code>HTTP</code>协议中，<code>HTTP</code>的<code>request</code>报文和<code>response</code>报文都包含有<code>header</code>，<code>TCP</code>和<code>IP</code>也都有<code>header</code>，它们通过层层”套娃”后发送。</p>
<p>现在我们对数据如何通过网络传输稍微有了一个整体的概念，但是细节是不清楚的。从上述内容中，可以看到，<code>HTTP</code>数据是转换为<code>TCP</code>数据进行传输，对于<code>传输层</code>及以下的内容在这里就不做说明，这里主要讲<code>应用层</code>的<code>HTTP数据</code>是如何通过<code>传输层</code>传输的，以及如何解析的。</p>
<h2 id="HTTP协议数据是如何转换为TCP数据收发的"><a href="#HTTP协议数据是如何转换为TCP数据收发的" class="headerlink" title="HTTP协议数据是如何转换为TCP数据收发的"></a><code>HTTP</code>协议数据是如何转换为<code>TCP</code>数据收发的</h2><p>一般来讲，各系统都会给用户提供<code>HTTP</code>网络框架，例如<code>iOS</code>的<code>NSURLSession</code>，在系统的<code>HTTP</code>网络框架之上，开发者社区又会开发出各种易用版本的封装，例如<code>AFNetworking</code>。对上层开发者来说，<code>HTTP</code>协议的使用一般就是一个框架封装好的<code>Request</code>对象，甚至只是一个<code>URL</code>，使用框架请求完成后，返回一个<code>Response</code>对象，它的底层实现是隐藏的。</p>
<p>我们都知道，计算机的底层是二进制，数据传输也不例外。要把<code>Request</code>对象从主机传输到服务器，那么必须把它转换为二进制，那么它是怎么转换的？又是怎么传输的？</p>
<h3 id="HTTP协议是怎么转换成二进制的？"><a href="#HTTP协议是怎么转换成二进制的？" class="headerlink" title="HTTP协议是怎么转换成二进制的？"></a>HTTP协议是怎么转换成二进制的？</h3><p>网络框架的<code>Request</code>对象为了易用性，经过了层层封装，要传输出去，必须将它转换为二进制数据：<code>Request对象 -&gt; 符合HTTP协议的Request字符串 -&gt; 二进制数据</code>。</p>
<p>HTTP协议中的请求报文：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223155455.png" alt=""><br>响应报文：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223170116.png" alt=""></p>
<p>按照图示请求报文格式，我们可以将<code>Request</code>对象转换为符合<code>HTTP</code>协议的字符串并转换为字节流。样例代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 创建NSURLRequest</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将NSURLRequest转换为二进制数据（这里只针对POST和GET请求进行说明）</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)httpRequestDataWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> * requestStrFrmt = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="built_in">NSURL</span> * url = request.URL;</span><br><span class="line">    <span class="built_in">NSString</span> *requestURI = url.path;</span><br><span class="line">    <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"POST"</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!url.path || url.path.length == <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = <span class="string">@"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"GET"</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.path.length &gt; <span class="number">0</span>  &amp;&amp; url.query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>, url.path, url.query];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.path.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = url.path;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = url.query;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestURI = <span class="string">@"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [requestStrFrmt appendFormat:<span class="string">@"%@ %@ HTTP/1.1\r\n"</span>, request.HTTPMethod, requestURI];</span><br><span class="line">    <span class="keyword">if</span> ([request.allHTTPHeaderFields objectForKey:<span class="string">@"Host"</span>] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"Host: %@\r\n"</span>, url.host];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析请求头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> * key <span class="keyword">in</span> request.allHTTPHeaderFields.allKeys) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"%@: %@\r\n"</span>, key, request.allHTTPHeaderFields[key]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析请求数据（body）</span></span><br><span class="line">    <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"POST"</span>] &amp;&amp; request.HTTPBody) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"Content-Length: %@\r\n"</span>, @(request.HTTPBody.length)];</span><br><span class="line">        <span class="comment">//请求头以两个CRLF结束</span></span><br><span class="line">        [requestStrFrmt appendString:<span class="string">@"\r\n"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *headerData = [requestStrFrmt dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSMutableData</span> * requestData = [<span class="built_in">NSMutableData</span> dataWithData:headerData];</span><br><span class="line">        [requestData appendData:request.HTTPBody];</span><br><span class="line">        <span class="keyword">return</span> requestData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//请求头以两个CRLF结束</span></span><br><span class="line">        [requestStrFrmt appendString:<span class="string">@"\r\n"</span>];</span><br><span class="line">        <span class="keyword">return</span> [requestStrFrmt dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打印出NSURLRequest报文的文本数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> httpRequestDataWithRequest:request];</span><br><span class="line"><span class="built_in">NSString</span> *requestText = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, requestText);</span><br></pre></td></tr></table></figure>
<p>调用通过上述代码，我们可以得到<code>request</code>报文的文本数据。样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure>
<p><code>response</code>报文可以参考<code>request</code>报文进行分析，为了避免篇幅过长，这里就不再做说明了。</p>
<h3 id="HTTP二进制数据是怎么传输的？"><a href="#HTTP二进制数据是怎么传输的？" class="headerlink" title="HTTP二进制数据是怎么传输的？"></a>HTTP二进制数据是怎么传输的？</h3><p>在各操作系统中，通常会为应用程序提供一组应用程序接口，称为套接字接口（socket API），主要作用就是实行进程间通信和网络编程。大白话就是：套接字是用C语言写成的应用程序开发库，它就是一个库。</p>
<p>套接字中的网络套接字，包含有流式套接字（<code>SOCK-STREAM</code>），它使用<code>TCP</code>协议来实现字节流的传输。通过<code>socket</code>框架，将包含<code>HTTP</code>数据的<code>TCP</code>字节流发送给服务端，服务端通过<code>socket</code>框架拿到包含<code>HTTP</code>数据的<code>TCP</code>字节流后，根据<code>HTTP</code>协议进行解析，解析后又被服务端的HTTP网络框架返回，图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223163025.png" alt=""><br>上述图示只包含<code>request</code>报文部分，并不包含<code>response</code>报文部分，由于<code>response</code>报文的数据传输和这个并无太大区别，这里就不再做额外说明了。</p>
<h2 id="HTTP协议中Request和Response的解析和逻辑处理"><a href="#HTTP协议中Request和Response的解析和逻辑处理" class="headerlink" title="HTTP协议中Request和Response的解析和逻辑处理"></a><code>HTTP</code>协议中<code>Request</code>和<code>Response</code>的解析和逻辑处理</h2><p>看到这里，我们对HTTP实现应该有了较明朗的了解，但是这其中还是有一些细节需要补充。<br>用过<code>Socket</code>的同学应该都知道，它基于<code>TCP</code>是流式传输，会有<code>半包</code>和<code>粘包</code>问题。一般通过对数据添加<code>Header</code>来解决这些问题。我们知道，<code>HTTP</code>数据包含两部分，分别是<code>Header</code>和<code>Body</code>，<code>HTTP</code>协议定义<code>Header</code>和<code>Body</code>之间包含两个<code>CRLF</code>，一个<code>CRLF</code>是一个回车加一个换行：<code>\r\n</code>。通过这个标识，我们可以从<code>TCP流</code>中把<code>HTTP</code>数据的<code>Header</code>分离出来。然后再解析出<code>Header</code>中的<code>Content-Length</code>字段，它就是<code>body</code>的长度，读取这个长度的内容，就可以把Body解析出来。</p>
<blockquote>
<p>在HTTP/1.1版本，Body的解析还和Transfer-Encoding字段有关，这里就不讨论了。</p>
</blockquote>
<p>当然<code>HTTP协议</code>不只是包含数据解析部分，还有很多逻辑控制部分，它的响应头和和请求头中有很多控制字段，例如缓存相关的<code>Etag</code>，<code>Last-Modified</code>等，和数据压缩相关的<code>Content-Encoding</code>，<code>Accept-Encoding</code>等。系统的网络框架实现了这些控制字段的逻辑，让用户可以开箱即用。</p>
<h2 id="修改HTTP底层实现，完成自有需求。"><a href="#修改HTTP底层实现，完成自有需求。" class="headerlink" title="修改HTTP底层实现，完成自有需求。"></a>修改<code>HTTP</code>底层实现，完成自有需求。</h2><p>对HTTP上层的修改是很常见的，例如<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNewwork</a>就在HTTP协议之上，添加了自定义缓存逻辑，可以通过<code>cacheTimeInSeconds</code>方法来控制缓存时间。但是对HTTP底层的修改却比较少见，我对这部分的了解，是基于一个特殊需求。</p>
<p>我们都知道手机可以通过<code>WiFi</code>或者<code>蜂窝网络</code>通道来收发数据，一般情况下，同时连接WiFi和蜂窝网络时，路由会让流量只走<code>WiFi</code>通道。但是对于一些WiFi连接工具软件来讲，需要在<code>无法上网的WiFi</code>下进行数据获取，以满足WiFi认证上网的需求，这种情况下<code>蜂窝网络</code>是可以访问网络的，那么可以让HTTP请求不走默认的<code>WiFi</code>通道，通过<code>蜂窝网络</code>来请求数据吗？上层的HTTP网络框架是没有这个功能的，但是底层的<code>socket</code>框架却提供这个功能，它可以让数据无视路由，从特定接口收发。我们完全可以在socket之上，自己实现HTTP协议中<code>request</code>,<code>response</code>的解析和逻辑处理，以达成这个功能的支持。当然对HTTP协议的全量支持是无法承受的开发成本，但是满足自我需求的简单实现还是可以的。我把这功能封装成了一个框架：<a href="https://github.com/xx-li/XXSocketReqeust" target="_blank" rel="noopener">XXSocketReqeust</a>，使用方式如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">_manager = [[XXSocketRequestManager alloc] init];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>]];</span><br><span class="line"><span class="comment">/// 使用XXNetworkInterfaceCellular，这个HTTP请求会无视路由，强制走蜂窝网络通道进行请求。</span></span><br><span class="line">XXSocketDataTask *task = [_manager dataTaskWithRequest:request viaInterface:XXNetworkInterfaceCellular completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error is :%@\n response is %@"</span>, error, response);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"responseObject: %@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">&#125;];</span><br><span class="line">[task start];</span><br></pre></td></tr></table></figure>
<p>感兴趣的同学可以<a href="https://github.com/xx-li/XXSocketReqeust.git" target="_blank" rel="noopener">下载</a>看看。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很多时候网络协议是高冷的，通用的网络协议为了通用和满足各种需求，是非常复杂的。但是我们完全可以针对自己的业务自制协议，或者对协议进行魔改，以满足自我的需求，这其中的难度并没有你想象中的那么高。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/xx-li/XXSocketReqeust" target="_blank" rel="noopener">XXSocketReqeust</a></li>
<li><a href="https://xie.infoq.cn/article/6f7af61d2f01eee65cee5fdcf" target="_blank" rel="noopener">一篇让你彻底了解 http 请求报文和响应报文的结构</a></li>
<li><a href="https://juejin.cn/post/6857287743966281736" target="_blank" rel="noopener">「查缺补漏」巩固你的HTTP知识体系</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7" target="_blank" rel="noopener">网络套接字</a></li>
<li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#TCP/IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">互联网协议套件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32059190" target="_blank" rel="noopener">OSI 7层模型和TCP/IP 4层模型</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>使用swift懒加载需要注意的陷阱</title>
    <url>/2021/12/27/%E4%BD%BF%E7%94%A8swift%E6%87%92%E5%8A%A0%E8%BD%BD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>修改老代码后，发现UITableView会在创建cell时闪退，原因是在调用<code>dequeueReusableCell(withIdentifier:)</code>创建cell时返回了nil。但是检查代码，确认在<code>viewDidLoad</code>注册了这个cell，按道理不应该返回nil。后面分析才发现，由于<code>lazy var</code>不是线程安全的，在碰到viewDidLoad的某个特殊调用时机时就会出现这个问题，而且代码可能在大部分场景正常运行，然后出现一些看起来莫名其妙的bug！</p>
<a id="more"></a>

<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>我把问题代码简化后如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TestTableViewController: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">/// 使用懒加载创建tableView</span></span><br><span class="line">    lazy var tableView: <span class="built_in">UITableView</span> = &#123;</span><br><span class="line">        print(<span class="string">"start init testLabel, isViewLoaded \(self.isViewLoaded)"</span>)</span><br><span class="line">        let tableView = <span class="built_in">UITableView</span>.init(frame: <span class="keyword">self</span>.view.bounds)</span><br><span class="line">        print(<span class="string">"created tableView \(tableView)"</span>)</span><br><span class="line">        tableView.delegate = <span class="keyword">self</span></span><br><span class="line">        tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        print(<span class="meta">#function)</span></span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">        </span><br><span class="line">        print(<span class="meta">#function, <span class="meta-string">"tableView \(tableView) register cell"</span>)</span></span><br><span class="line">        <span class="comment">// 注册cell</span></span><br><span class="line">        tableView.register(<span class="built_in">UITableViewCell</span>.self, forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension TestTableViewController: <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span> &#123;</span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">        let cell = <span class="keyword">self</span>.tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)!</span><br><span class="line">        cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式如下</span></span><br><span class="line">@IBAction func showTestTableViewVC(_ sender: Any) &#123;</span><br><span class="line">    let testVC = TestTableViewController.init()</span><br><span class="line">    <span class="comment">// 引起问题的关键代码</span></span><br><span class="line">    testVC.tableView.isScrollEnabled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">self</span>.navigationController?.pushViewController(testVC, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你已经一眼就看出了问题所在，那么就没有必要看下去了。如果你没有看出来，也不要着急，这个问题确实挺隐蔽的。上述代码运行后，会出现报错：<code>TestTableViewController.swift:29: Fatal error: Unexpectedly found nil while unwrapping an Optional value</code>。那么这个问题是怎么产生的类？</p>
<h2 id="问题是怎么产生的？"><a href="#问题是怎么产生的？" class="headerlink" title="问题是怎么产生的？"></a>问题是怎么产生的？</h2><p>首先我们要清楚两个知识点：</p>
<ol>
<li><code>lazy var</code>懒加载不是线程安全的</li>
<li>在<code>UIViewController</code>中，成员变量<code>view</code>没有初始化及<code>viewDidLoad</code>方法被调用之前，只要调用了成员变量<code>view</code>，就会立即初始化<code>view</code>并调用<code>viewDidLoad</code>方法。 </li>
</ol>
<blockquote>
<p>第二点有点隐蔽，例如在<code>viewDidLoad</code>方法调用之前调用<code>self.view.bounds</code>就会触发。</p>
</blockquote>
<p>上述代码运行后的Log输出如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211227172817.png" alt=""></p>
<p>在调用<code>let testVC = TestTableViewController.init()</code>初始化控制器后，我们立即调用了<code>testVC.tableView.isScrollEnabled = false</code>，这个时候会进入<code>tableView</code>的懒加载部分：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">lazy var tableView: <span class="built_in">UITableView</span> = &#123;</span><br><span class="line">    print(<span class="string">"start init testLabel, isViewLoaded \(self.isViewLoaded)"</span>)</span><br><span class="line">    <span class="comment">// 注意，这里调用了self.view，会导致`viewDidLoad`被提前调用！</span></span><br><span class="line">    let tableView = <span class="built_in">UITableView</span>.init(frame: <span class="keyword">self</span>.view.bounds)</span><br><span class="line">    print(<span class="string">"created tableView \(tableView)"</span>)</span><br><span class="line">    tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">return</span> tableView</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    print(<span class="meta">#function)</span></span><br><span class="line">    view.addSubview(tableView)</span><br><span class="line">    </span><br><span class="line">    print(<span class="meta">#function, <span class="meta-string">"tableView \(tableView) register cell"</span>)</span></span><br><span class="line">    <span class="comment">// 注册cell</span></span><br><span class="line">    tableView.register(<span class="built_in">UITableViewCell</span>.self, forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先定义这次要创建的<code>tableView</code>为<code>A</code>。这部分懒加载代码由于错误的调用了<code>self.view</code>，导致<code>self.view</code>初始化和<code>viewDidLoad</code>方法被提前调用，此时成员变量<code>tableView</code>还没有被初始化完成，而<code>viewDidLoad</code>方法中又调用了<code>tableView</code>，由于<code>lazy</code>不是线程安全的，所以又递归进入了上述初始化<code>tableView</code>的逻辑，这个时候<code>self.view</code>已经被创建了，所以会初始化完成，我们定义这次创建的<code>tableView</code>为<code>B</code>，这个时候控制器持有的<code>tableView</code>对象是<code>B</code>，它会在<code>viewDidLoad</code>方法的这次调用中注册cell。<br>上述逻辑跑完后，<code>A</code>才紧随其后完成创建，并替换<code>B</code>成为控制器的新成员变量，而且由于<code>viewDidLoad</code>已经被调用过了，在<code>self.navigationController?.pushViewController(testVC, animated: true)</code>方法调用后，<code>viewDidLoad</code>不会再被调用，所以<code>A</code>是没有注册cell的。</p>
<p>运行到这时，控制器持有了<code>A</code>，而控制器的<code>view</code>通过<code>addSubview</code>持有了它的子视图<code>B</code>，图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211227194208.png" alt=""><br>其中<code>B</code>对象在<code>viewDidLoad</code>方法中注册了<code>cell</code>，而<code>A</code>对象并没有注册，所以在代理方法中创建<code>cell</code>时返回了<code>nil</code>，导致了<code>crash</code>。如果对这部分不理解，可以多看几遍代码和日志，理顺下调用流程。</p>
<p>crash位置代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="comment">// self.tableView是对象A，它并没有注册cell。</span></span><br><span class="line">    <span class="comment">// 代理方法传递过来的tableView是对象B，它注册了cell，直接使用它则不会crash</span></span><br><span class="line">    let cell = <span class="keyword">self</span>.tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)!</span><br><span class="line">    cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个问题的隐蔽性在于存在两个<code>UITableView</code>对象，如果在代理方法中不使用<code>self.tableView</code>而是使用代理方法传递过来的<code>tableView</code>，那么程序不会crash，而且显示正常。而后续会不会出现奇奇怪怪的问题，就完全看你的运气了。</p>
<p>当然这个问题埋的隐蔽性并不止于此，当外部不调用<code>tableView</code>属性时，例如不像样例代码那样调用<code>testVC.tableView.isScrollEnabled = false</code>，那么在<code>viewDidLoad</code>方法中会正常执行<code>tableView</code>的初始化，一切都是正常的。但是一旦哪位同事在外部调用了一次，那么潘多拉魔盒就打开了～</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决这种问题，需要我们有良好的编码规范。首先，要强化<code>lazy</code>不是线程安全的概念，在懒加载中只做这个变量初始化的事情，尽量避免其它变量及逻辑的混入。在<code>UIViewController</code>及其子类的懒加载逻辑中，避免对<code>view</code>的调用。我看很多人喜欢在懒加载逻辑中调用<code>view.addSubView()</code>或<code>view.bounds</code>，这是不太对的，因为在<code>isViewLoaded</code>为<code>false</code>的情况下，对<code>view</code>的调用就代表着<code>viewDidLoad</code>方法的提前调用，这让程序的逻辑变得有些混乱，除非你能保证在<code>viewDidLoad</code>之后调用这个属性。</p>
<p>其次，在编码过程中，要注意权限的控制，设计合适的接口，这样对使用者更友好，也能规避很多异常场景，当然这对开发者的要求较高，需要平常多加修炼和积累了。</p>
<h2 id="关于OC"><a href="#关于OC" class="headerlink" title="关于OC"></a>关于OC</h2><p>另外需要注意的是，<code>OC</code>的懒加载也有同样的问题。但是<code>OC</code>可以优化写法避免出现这个问题，而<code>Swift</code>不行。</p>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UITableView *)tableView &#123;</span><br><span class="line">    if (!_tableView) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一种用法：这样调用会出现异常</span><br><span class="line">&#x2F;&#x2F;        _tableView &#x3D; [[UITableView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">        &#x2F;&#x2F; 第二种用法：这样是正常的</span><br><span class="line">        _tableView &#x3D; [[UITableView alloc] init];</span><br><span class="line">        _tableView.frame &#x3D; self.view.bounds;</span><br><span class="line"></span><br><span class="line">        _tableView.delegate &#x3D; self;</span><br><span class="line">        _tableView.dataSource &#x3D; self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _tableView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的第二种用法不会出现问题，是由于在<code>_tableView.frame = self.view.bounds;</code>这行代码才引入的<code>self.view</code>，此时<code>_tableView</code><br>已经有值，后续代码不会执行。</p>
<p>虽然没有问题，但是不推荐这样使用，因为它还是引起了<code>viewDidLoad</code>的提前执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/29761706/swift-is-lazy-var-thread-safe" target="_blank" rel="noopener">Swift - is lazy var thread-safe?</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结 - 时间一天天的流逝，最终留下了什么？</title>
    <url>/2022/01/01/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E6%97%B6%E9%97%B4%E4%B8%80%E5%A4%A9%E5%A4%A9%E7%9A%84%E6%B5%81%E9%80%9D%EF%BC%8C%E6%9C%80%E7%BB%88%E7%95%99%E4%B8%8B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>往年断断续续的有做过年终总结和年终计划，大多是象征性的做一做，好像是一个仪式。随着年龄的增大，责任越来越多，压力也越来越大。这让我开始思考：时间一天天的流逝，最终留下了什么？<br>很多人被工作与生活裹携着前进，一直在低头赶路，却忘记了抬头看看方向和欣赏一下周围的风景，等到某一天才发现，身边已满是荆棘，寸步难行。而这个年终总结，就是我”抬头看路”的一部分。我会从个人成长，家庭，工作，业余生活来进行总结。</p>
<a id="more"></a>

<h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p>我自认为是一个爱学习的人，从事互联网行业以来，一直都是从事iOS的相关工作，除了iOS方向，我系统学习过Android，Python，React，JS，Go，Flutter等，浅尝即止的就不说了，每一项都投入了较多时间，在这些技术的学习高峰，估计能达到中级开发者的开发效率吧。但是随着时间的流逝，其中大部分都忘的差不多了，如果面试官问我相关问题，我大概率是答不出来的，重新去做相关事情也需要去温习才能想起，很多人可能也有类似的感觉。<br>所以从今年开始，对这方面的思考越来越多。首先，每个人的精力是有限的，要定好自己的技术方向，在基本盘稳固，有余力的情况下再做其它方向的拓展。其次，要更高效及有效的学习。</p>
<h3 id="定技术方向"><a href="#定技术方向" class="headerlink" title="定技术方向"></a>定技术方向</h3><p>今年年初确定技术平台为iOS &amp; Flutter，技术目标为成为大前端和架构方面的专家。目标很宏伟，需要一步步实施，在iOS方面，主要做了这些：</p>
<ul>
<li>完成李明杰老师《iOS底层原理班》视频课程的学习，并全程做笔记和总结。</li>
<li>完成李明杰老师《Swift编程从入门到精通》视频课程的学习，并全程做笔记和总结。</li>
</ul>
<p>李明杰老师的视频质量很高，让我接触到很多新东西（毕竟都搞汇编去分析了），但是很多都是底层和比较冷门的内容，现在已经忘了很多了，通过视频学习是非常耗时的，可能对初学者或求职者性价比会高一些吧。以后对熟悉领域的巩固和深入，会优先选择文字而不是视频～</p>
<p>在Flutter方面，主要做了这些：</p>
<ul>
<li>完成了对个人项目《购房计算器》的改版</li>
<li>完成了一个Flutter外包项目并上架。</li>
<li>打造了自己的快速开发框架，整了个VSCode插件生成模版代码，对开发效率提高挺多。</li>
</ul>
<p>现在对于Flutter的学习都是集中在应用层面，经过今年的学习和实践，现在已经可以用Flutter完成复杂的UI和需求，基本上原生能做的都能用Fluter做好，效率也更高。Flutter的劣势是做极致体验时干不过原生，原生项目嵌入Flutter的成本较高，对直播等这类场景不友好等，明年会把更多精力放入Flutter底层原理及它与原生交互部分，并做高质量的博文输出。</p>
<h3 id="更高效及有效的学习"><a href="#更高效及有效的学习" class="headerlink" title="更高效及有效的学习"></a>更高效及有效的学习</h3><p>今年的学习过程中，自己有犯一些错误，第一个是想尽快把学习在预定时间内搞完，牺牲掉了学习的质量。第二个是对自己自视太高，制定了不符实际的计划，最终导致计划烂在一次次的失败之中。在后半段，对学习思路进行了调整，改为以输出倒逼输入的模式，通过输出高质量的博文来进行学习。今年总共写了5篇博文，有3篇是12月份写的，其中一篇被老司机技术周报收纳并上了掘金社区的周榜，这对我是莫大的激励。还有就是尽量选择工作内容强相关的内容进行学习，会在工作中得到一次又一次的巩固。</p>
<h2 id="关于家庭"><a href="#关于家庭" class="headerlink" title="关于家庭"></a>关于家庭</h2><p>由于结婚很早，我现在是两个小孩的父亲，大的已经读小学了，是非常活泼好动的性格，在学校的表现和在家做作业的情况都让我和老婆苦恼。上半年尝试过各种办法无效后，我想出一个方案，规定每天在学校里不能扣分并在晚上八点半前完成全部作业，违反则罚站20分钟马步，如果连续违反则每次附加10分钟。为了避免小孩的逆反心理，我一起罚站并监督罚站纪律（子不教父之过），老婆检查并判定作业是否完成，执行半个月后取得了很好的成效，就是我的胳膊和腿差点废掉了。下半年，儿子班级换了班主任，完全不一样的管理风格，严格和认真程度高了不止一个量级，加上中间一段时间的松懈，儿子又暴露出来了很多问题，所以最近两个月又和老婆一起严抓习惯和学业，事情又逐步在往好的方向上发展。<br>受益于今年没有什么加班，个人也很少去应酬，给家庭的时间较多，但是感觉自己做的还是不够好，带小孩是一场修行，期望明年在小孩问题上要更多的关注，更多的思考，更多的沟通，更认真的执行，给家人做更好的榜样。</p>
<h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>由于公司的经营状况不佳以及裁员，上半年没什么工作任务，下半年公司则处在比较动荡的状态之中。这种状态下，业务需求不多，没有什么加班。中途试图在公司推进Flutter，我把公司现有App用Flutter重新进行了架构，完成了大部分基础组件的搭建，以及上层20%左右的业务内容。后面准备向同事推广，推进公司App的Flutter化，但是架不住裁员后都去复习面试题了。我想，年后，我也该去找工作了～</p>
<h2 id="业余生活"><a href="#业余生活" class="headerlink" title="业余生活"></a>业余生活</h2><p>我是一个路亚爱好者，由于工作和带小孩，没什么时间，经常在晚上小孩睡着后去河边甩几竿，或者周末早上三四点起床，钓到八九点回来，然后送小孩去上兴趣班。玩归玩，但是不能影响正事。今年钓得最爽的一次是在沩水2个小时钓了50条鳜鱼。在资江也钓了很多斑鳜，资江是鹅卵石河床，环境和风景一流，就算钓不到鱼也是一种美的享受，在青山与溪流之中，感受着那微风拂面和阳光，那是我”突然的自我”。</p>
<h2 id="展望2022"><a href="#展望2022" class="headerlink" title="展望2022"></a>展望2022</h2><p>在新的一年，我要多做一些高质量的输出。期望家人都能健健康康，不求达到多高的成就，只希望能做更好的自己。最后就日常列一个新年flag吧：</p>
<ul>
<li>最高优先级严格执行家庭管理和教育半年，给两个崽养成良好的行为习惯。</li>
<li>完成15编高质量的博文</li>
<li>做一个个人项目并日活1000+</li>
</ul>
<p>最后，一句话送给自己：永远不要高估自己短期内能做的事，也永远不要低估自己长期能做的事。</p>
]]></content>
  </entry>
</search>
