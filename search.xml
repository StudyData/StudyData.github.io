<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flutter定制上下拉刷新功能</title>
    <url>/2020/07/09/Flutter%E5%AE%9A%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>项目中需要定制一个基于Gif图片的下拉刷新功能，调研发现<br>Flutter支持上下拉刷新的框架很多，其中有两个比较有名的有<a href="https://pub.dev/packages/flutter_easyrefresh" target="_blank" rel="noopener">flutter_easyrefresh</a>和<a href="https://pub.dev/packages/pull_to_refresh" target="_blank" rel="noopener">pull_to_refresh</a>，两个框架功能都很强大，都能满足需求，其中flutter_easyrefresh在github的star更多，lib包大小为<code>644KB</code>，pull_to_refresh在pub.dev的评分更高，lib包大小为<code>172KB</code>，综合考虑后，选择基于pull_to_refresh来实现框架功能。</p>
<a id="more"></a>

<h2 id="下拉刷新GIF图片的生成"><a href="#下拉刷新GIF图片的生成" class="headerlink" title="下拉刷新GIF图片的生成"></a>下拉刷新GIF图片的生成</h2><p>下拉刷新需要控制Gif图片的播放，所以需要引入组件<a href="https://pub.dev/packages/flutter_gifimage" target="_blank" rel="noopener">flutter_gifimage</a>，gifimage支持加载本地和网络的gif图片，但是不支持加载图片列表的方式来执行gif动画，所以我们需要将图片列表生成为gif图片（UI小姐姐只给了图片列表）。<br>网上有很多网站可以生成gif，但是都有图片数量限制。 下载一个生成gif的软件来生成又显得很麻烦，我们选择使用Python的Pillow库来创建gif图片。Pillow是PIL的python3版本，功能强大，可以很好的完成需求。创建脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_frame</span><span class="params">(path)</span>:</span></span><br><span class="line">    png = Image.open(path).convert(<span class="string">'RGBA'</span>)</span><br><span class="line">    background = Image.new(<span class="string">'RGBA'</span>, png.size, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>))</span><br><span class="line">    alpha_composite = Image.alpha_composite(background, png)</span><br><span class="line">    <span class="keyword">return</span> alpha_composite</span><br><span class="line"></span><br><span class="line">image_list = []</span><br><span class="line">im0 = gen_frame(<span class="string">'refresh_images/Loading_00@2x.png'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">57</span>):</span><br><span class="line">    path = <span class="string">'refresh_images/Loading_0'</span> + str(i) + <span class="string">"@2x.png"</span></span><br><span class="line">    image_list.append(gen_frame(path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成透明图片需要加两个个参数：transparency=0, disposal=2</span></span><br><span class="line">im0.save(<span class="string">'GIF.gif'</span>, save_all=<span class="literal">True</span>, append_images=image_list, loop=<span class="number">0</span>, duration=<span class="number">34</span>, transparency=<span class="number">0</span>, disposal=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述脚本对Gif背景进行了处理，以生成一张透明背景的gif图片</p>
</blockquote>
<h2 id="Gif下拉刷新组件头部的实现"><a href="#Gif下拉刷新组件头部的实现" class="headerlink" title="Gif下拉刷新组件头部的实现"></a>Gif下拉刷新组件头部的实现</h2><p>pull_to_refresh中提供了抽象类RefreshIndicator与RefreshIndicator，与material提供的重名，所以需要隐藏。 import部分代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span></span><br><span class="line">    <span class="keyword">hide</span> RefreshIndicator, RefreshIndicatorState;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br></pre></td></tr></table></figure>

<p>最终下拉刷新的Header实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span></span><br><span class="line">    <span class="keyword">hide</span> RefreshIndicator, RefreshIndicatorState;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_gifimage/flutter_gifimage.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GifHeader</span> <span class="keyword">extends</span> <span class="title">RefreshIndicator</span> </span>&#123;</span><br><span class="line">  GifHeader() : <span class="keyword">super</span>(height: <span class="number">72.0</span>, refreshStyle: RefreshStyle.Follow);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GifHeaderState createState() =&gt; _GifHeaderState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GifHeaderState</span> <span class="keyword">extends</span> <span class="title">RefreshIndicatorState</span>&lt;<span class="title">GifHeader</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  GifController _gifController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">//value可以理解成Gif图片里面的第几帧</span></span><br><span class="line">    _gifController = GifController(</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onModeChange(RefreshStatus mode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == RefreshStatus.refreshing) &#123;</span><br><span class="line">     <span class="comment">//min和max都可以理解成Gif图片里面的第几帧，这里表示低0帧到第44帧</span></span><br><span class="line">      _gifController.repeat(</span><br><span class="line">          min: <span class="number">0</span>, max: <span class="number">44</span>, period: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onModeChange(mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; endRefresh() &#123;</span><br><span class="line">    <span class="keyword">return</span> _gifController.animateTo(<span class="number">44</span>, duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> resetValue() &#123;</span><br><span class="line">    <span class="comment">// reset not ok , the plugin need to update lowwer</span></span><br><span class="line">    _gifController.value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">super</span>.resetValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildContent(BuildContext context, RefreshStatus mode) &#123;</span><br><span class="line">    <span class="keyword">return</span> GifImage(</span><br><span class="line">      image: AssetImage(<span class="string">"images/pull_refresh.gif"</span>),</span><br><span class="line">      controller: _gifController,</span><br><span class="line">      height: <span class="number">72.0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _gifController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置Gif的<code>value</code>（帧）时，不能超过Gif的最大帧数，不然超出的帧数是显示一个有颜色的空白页面</p>
</blockquote>
<h2 id="集成进入项目"><a href="#集成进入项目" class="headerlink" title="集成进入项目"></a>集成进入项目</h2><p>pull_to_refresh提供了全局的统一配置类<code>RefreshConfiguration</code>，用它来包裹MaterialApp则可以全局生效，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RefreshConfiguration(</span><br><span class="line">      headerBuilder: () =&gt; GifHeader(), <span class="comment">// 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个</span></span><br><span class="line">      footerBuilder: () =&gt; ClassicFooter(), <span class="comment">// 配置默认底部指示器</span></span><br><span class="line">      headerTriggerDistance: <span class="number">72.0</span>, <span class="comment">// 头部触发刷新的越界距离</span></span><br><span class="line">      <span class="comment">//  springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9),         // 自定义回弹动画,三个属性值意义请查询flutter api</span></span><br><span class="line">      maxOverScrollExtent: <span class="number">100</span>, <span class="comment">//头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性</span></span><br><span class="line">      maxUnderScrollExtent: <span class="number">0</span>, <span class="comment">// 底部最大可以拖动的范围</span></span><br><span class="line">      enableScrollWhenRefreshCompleted:</span><br><span class="line">          <span class="keyword">true</span>, <span class="comment">//这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true</span></span><br><span class="line">      enableLoadingWhenFailed: <span class="keyword">true</span>, <span class="comment">//在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多</span></span><br><span class="line">      hideFooterWhenNotFull: <span class="keyword">false</span>, <span class="comment">// Viewport不满一屏时,禁用上拉加载更多功能</span></span><br><span class="line">      <span class="comment">// 当列表无法充满全屏的时候，加载更多跟在列表后面</span></span><br><span class="line">      shouldFooterFollowWhenNotFull: (status) =&gt; <span class="keyword">true</span>,</span><br><span class="line">      enableBallisticLoad: <span class="keyword">true</span>, <span class="comment">// 可以通过惯性滑动触发加载更多</span></span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">        home: HomePage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局配置好后，则可以在列表进行集成了：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:my_flutter/message/notice_list_page/notice_ist_cell.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:my_flutter/message/notice_list_page/notice_list_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:pull_to_refresh/pull_to_refresh.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoticeListPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NoticeListPageState createState() =&gt; _NoticeListPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NoticeListPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NoticeListPage</span>&gt; </span>&#123;</span><br><span class="line">  RefreshController _refreshController =</span><br><span class="line">      RefreshController(initialRefresh: <span class="keyword">true</span>);</span><br><span class="line">  <span class="built_in">List</span>&lt;NoticeListModel&gt; list = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onRefresh() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// monitor network fetch</span></span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>));</span><br><span class="line">    <span class="comment">// 这里可以添加逻辑判断，如果无更多数据：_refreshController.loadNoData();</span></span><br><span class="line">    <span class="comment">// 如果加载失败： 设置_refreshController.refreshFailed()</span></span><br><span class="line">    _refreshController.refreshCompleted();</span><br><span class="line">    </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      list = _getList();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _onLoading() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// monitor network fetch</span></span><br><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>));</span><br><span class="line">    <span class="comment">// if failed,use loadFailed(),if no data return,use LoadNodata()</span></span><br><span class="line">    _refreshController.loadComplete();</span><br><span class="line">    <span class="keyword">if</span> (mounted)</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        list.addAll(_getList());</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SmartRefresher(</span><br><span class="line">        enablePullDown: <span class="keyword">true</span>,</span><br><span class="line">        enablePullUp: list.length &gt; <span class="number">0</span>,</span><br><span class="line">        controller: _refreshController,</span><br><span class="line">        onRefresh: _onRefresh,</span><br><span class="line">        onLoading: _onLoading,</span><br><span class="line">        child: ListView.builder(</span><br><span class="line">          itemBuilder: (c, i) =&gt; NoticeListCell(model: list[i]),</span><br><span class="line">          itemExtent: <span class="number">100.0</span>,</span><br><span class="line">          itemCount: list.length,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;NoticeListModel&gt; _getList() &#123;</span><br><span class="line">      <span class="keyword">return</span> [NoticeListModel(),NoticeListModel()];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Github Pages搭建博客及使用</title>
    <url>/2018/01/08/Github-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文基于Hexo进行说明。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>确保电脑中是安装有<code>Node.js</code>、<code>Git</code></li>
<li>hexo安装：<code>npm install -g hexo-cli</code></li>
</ul>
<h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>在 _config.yml 中修改大部份的配置。配置说明见<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官方文档</a></p>
<p>主要配置参数：</p>
<ul>
<li>网站</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title	网站标题</span><br><span class="line">subtitle	网站副标题</span><br><span class="line">description	网站描述</span><br><span class="line">author	您的名字</span><br><span class="line">language	网站使用的语言</span><br></pre></td></tr></table></figure>

<ul>
<li>配置对应的Github Pages</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/StudyData/StudyData.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<ul>
<li>网址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;blog.devlxx.com</span><br></pre></td></tr></table></figure>

<ul>
<li>配置评论</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disqus_shortname: devlxx</span><br><span class="line">disqus: true</span><br></pre></td></tr></table></figure>

<h3 id="日常用法"><a href="#日常用法" class="headerlink" title="日常用法"></a>日常用法</h3><ul>
<li>创建新博文：<code>$ hexo new [layout] &lt;title&gt;</code>，如<code>hexo new &quot;Github Pages搭建博客及使用</code>，执行后，会在<code>source/_posts</code>目录下创建<code>hexo new &quot;Github Pages搭建博客及使用.md</code>文件<ul>
<li>创建草稿使用特殊布局：<code>draft</code>, 建立时会保存在<code>source/_drafts</code>文件夹，可以执行<code>$ hexo publish [layout] &lt;title&gt;</code>移动到<code>source/_posts</code>目录</li>
</ul>
</li>
<li>生成静态文件：<code>hexo generate</code></li>
<li>本地查看：<code>hexo server -p 5000</code>，执行后，打开<code>http://localhost:5000/</code>即可查看博客效果。</li>
<li>部署：<code>hexo deploy</code></li>
<li>可以通过在文章中插入<code>&lt;!--more--&gt;</code>来设置在文章列表中展示的内容。<code>&lt;!--more--&gt;</code>上面内容均会展示在在列表中，下面的会被收起。（for <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a> 主题）</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h4><p>使用自己的域名逼格更高，域名绑定需要做两部分工作。</p>
<h5 id="Github-Pages域名绑定设置"><a href="#Github-Pages域名绑定设置" class="headerlink" title="Github Pages域名绑定设置"></a>Github Pages域名绑定设置</h5><p>使用一个自定义域名去重定向你的 GitHub Pages，你必须创建和提交一个包含自定义域名的 CNAME 文件到你的 GitHub Pages 存储库中。</p>
<ul>
<li>进入Github Pages仓库：<code>https://github.com/StudyData/StudyData.github.io</code></li>
<li>添加一个新文件，命名为 CNAME （全部大写！），放在 Pages 分支的根目录下。</li>
<li>在新文件中，添加一行，指定自定义域名的空子域名。例如，使用 blog.example.com 而不是 <a href="https://blog.example.com" target="_blank" rel="noopener">https://blog.example.com</a> 。</li>
</ul>
<blockquote>
<p>请注意，在 CNAME 文件中只允许有一个域名。</p>
</blockquote>
<h5 id="域名服务商设置"><a href="#域名服务商设置" class="headerlink" title="域名服务商设置"></a>域名服务商设置</h5><p>以万网为例</p>
<ul>
<li>点击添加解析</li>
<li>记录类型：<code>CHAME</code></li>
<li>主机记录：<code>blog</code></li>
<li>记录值：<code>studydata.github.io</code></li>
</ul>
<h4 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h4><p>hexo支持各种评论，常见的有1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment等，评估那个适合自己，申请相关服务后在根目录的<code>_config.yml</code>中进行配置，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">devlxx</span></span><br><span class="line"><span class="attr">disqus:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>畅言对国内支持较好，可以微信，QQ登录，配置如下：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#畅言app id</span></span><br><span class="line"><span class="attr">changyan_appid:</span> <span class="string">'xxxx'</span></span><br><span class="line"><span class="comment">#畅言app key</span></span><br><span class="line"><span class="attr">changyan_conf:</span> <span class="string">'xxxxxxxxxxxxxxxxxx'</span></span><br></pre></td></tr></table></figure>

<h4 id="资源文件使用"><a href="#资源文件使用" class="headerlink" title="资源文件使用"></a>资源文件使用</h4><ul>
<li>在根目录的<code>_config.yml</code>中进行配置:</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个<code>markdown</code>文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们</p>
<ul>
<li>也可以在source目录下创建一个资源目录<code>assets</code>，然后通过类似于<code>![](/assets/image.jpg)</code>的方法访问它们。</li>
</ul>
<h4 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h4><p>主题都放置在<code>themes/</code>目录下，一般从<a href="https://www.github.com" target="_blank" rel="noopener">github</a>上找到自己心仪的主题，clone到此目录下。然后在<code>_config.yml</code>配置相应的主题。 如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-yilia</span></span><br></pre></td></tr></table></figure>
<p><code>hexo-theme-yilia</code>为clone下来的项目的文件名。</p>
<h4 id="如何使用主题"><a href="#如何使用主题" class="headerlink" title="如何使用主题"></a>如何使用主题</h4><p>每个主题基本都有自己说明文档，一般通过修改主题中的<code>themes/theme_name/_config.yml</code>文件来实现主题修改。</p>
<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><ul>
<li><p>有人会把整个<code>hexo目录</code>放入<code>GitHub Pages</code>仓库，这是不对的，指定<code>hexo d</code>会将生成的博文相关静态文件上传到<code>Github Pages</code>，hexo目录一般用另外一个私有仓库放置，里面可以有你的草稿，主题等。</p>
</li>
<li><p>执行<code>hexo d</code>会将仓库先清空，如果有加入<code>CNAME</code>文件也会被清空，可以将<code>CNAME</code>放入<code>source/</code>目录下，上传的时候会一并传上去。</p>
</li>
<li><p>执行<code>hexo g</code>出现警告<code>WARN  No layout:xxx</code>，然后执行<code>hexo s</code>运行本地博客无内容。解决方法：</p>
<ul>
<li>是否配置的主题在<code>theme</code>下存在，检查下<code>themes/themeName/layout/</code>文件夹里是否有<code>index.js</code>文件，以及目录结构是否与实际主题的layout保持一致</li>
</ul>
</li>
<li><p>执行<code>hexo g</code>报错：<code>Error: The module &#39;/Users/lixinxing/Documents/BlogBackup/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#39;
was compiled against a different Node.js version using</code></p>
<ul>
<li>一般是node的版本发生了变化，删除目录下的<code>node_modules</code>文件，然后执行<code>npm install</code>重新安装即可。</li>
<li>依然不行，可以执行<code>npm i -g hexo-cli</code>再跑跑试试。 </li>
</ul>
</li>
<li><p>执行<code>hexo g</code>报错：<code>ERROR Plugin load failed: hexo-generator-json-content</code></p>
<ul>
<li>可能是node版本过低，升级node版本即可。</li>
</ul>
</li>
<li><p>hexo将整个目录都上传了上去，一般是设置了submodule导致的。</p>
<ul>
<li>把<code>.deploy_git</code>文件夹删除</li>
<li>执行<code>hexo clean</code>删除public目录后，再重新执行命令上传即可。</li>
</ul>
</li>
</ul>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo主题yilia</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView的Cookie问题</title>
    <url>/2018/05/08/WKWebView%E7%9A%84Cookie%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>WKWebView与App不在同一个进程运行，不会从App的标准Cookie容器<code>NSHTTPCookieStorage</code>读取Cookie。跨进程的数据同步是一个麻烦及容易出现问题的场景，Apple在iOS11之前没有专门的API用于Cookie操作，在iOS11之后提供了<code>WKHTTPCookieStore</code>，但是自测发现存在一些奇怪的bug，无法使用，此部分后续会做说明。</p>
<p>网上关于WKWebView的Cookie同步我有查到多种方案，但是均无法解决跨域请求的Cookie问题，后来发现使用WKProcessPool可以解决跨域问题。</p>
<a id="more"></a>

<h3 id="UIWebView为什么没有Cookie同步问题？"><a href="#UIWebView为什么没有Cookie同步问题？" class="headerlink" title="UIWebView为什么没有Cookie同步问题？"></a>UIWebView为什么没有Cookie同步问题？</h3><p>网络请求完成后，会返回一个Response，如果Response中带有<code>Set-Cookie</code>字段，如：<code>&quot;Set-Cookie&quot; = &quot;wifi_jsessionid=3aea4df28ab14b4e8714132cb911c15a; Domain=.pingan.com.cn; Path=/&quot;;</code>，操作系统就会将此条Cookie信息写入到<code>NSHTTPCookieStorage</code>中</p>
<p>当UIWebView中有任意请求时（App进程中的请求也是一样），会去NSHTTPCookieStorage查找对应的Cookie信息，如果存在<strong>符合条件</strong>的Cookie信息，就会在请求头中带上此条Cookie信息。所以UIWebView进行跨域请求是没有任何问题的，只要NSHTTPCookieStorage有<strong>符合条件</strong>的Cookie信息即可带上。</p>
<h3 id="WKWebView-Cookie同步一般解决方案"><a href="#WKWebView-Cookie同步一般解决方案" class="headerlink" title="WKWebView Cookie同步一般解决方案"></a>WKWebView Cookie同步一般解决方案</h3><p>WKWebView上请求不会自动带上<code>NSHTTPCookieStorage</code>中的Cookie, 目前的主要解决方案是通过手动的方式直接在请求头上带上Cookie或者使用JS脚本进行Cookie注入：</p>
<h4 id="在请求头中设置Cookie-解决首个请求Cookie带不上的问题"><a href="#在请求头中设置Cookie-解决首个请求Cookie带不上的问题" class="headerlink" title="在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:"></a>在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> * webView = [<span class="built_in">WKWebView</span> new]; </span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> * request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://h5.qzone.qq.com/mqzone/index"</span>]]; </span><br><span class="line"></span><br><span class="line">[request addValue:<span class="string">@"skey=skeyValue"</span> forHTTPHeaderField:<span class="string">@"Cookie"</span>]; </span><br><span class="line">[webView loadRequest:request];</span><br></pre></td></tr></table></figure>

<p>此方法只适合解决简单针对性的场景。</p>
<h4 id="通过document-cookie设置Cookie解决后续页面-同域-Ajax、iframe请求的Cookie问题"><a href="#通过document-cookie设置Cookie解决后续页面-同域-Ajax、iframe请求的Cookie问题" class="headerlink" title="通过document.cookie设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:"></a>通过<code>document.cookie</code>设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKUserContentController</span>* userContentController = <span class="built_in">WKUserContentController</span>.new;</span><br><span class="line"><span class="comment">//不设定Domain，则会将domain默认设为请求的URL的Domain</span></span><br><span class="line"><span class="built_in">WKUserScript</span> * cookieScript = [[<span class="built_in">WKUserScript</span> alloc] </span><br><span class="line">    initWithSource: <span class="string">@"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';"</span></span><br><span class="line">    injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// again, use stringWithFormat: in the above line to inject your values programmatically</span></span><br><span class="line">[userContentController addUserScript:cookieScript];</span><br><span class="line"><span class="built_in">WKWebViewConfiguration</span>* webViewConfig = <span class="built_in">WKWebViewConfiguration</span>.new;</span><br><span class="line">webViewConfig.userContentController = userContentController;</span><br><span class="line"><span class="built_in">WKWebView</span> * webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="comment">/*set your values*/</span>) configuration:webViewConfig];</span><br></pre></td></tr></table></figure>

<p>设定Cookie的辅助方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cookieString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@;domain=%@;path=%@"</span>,</span><br><span class="line">                        <span class="keyword">self</span>.name,</span><br><span class="line">                        <span class="keyword">self</span>.value,</span><br><span class="line">                        <span class="keyword">self</span>.domain,</span><br><span class="line">                        <span class="keyword">self</span>.path ?: <span class="string">@"/"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secure) &#123;</span><br><span class="line">        string = [string stringByAppendingString:<span class="string">@";secure=true"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Cookie注入无法跨域，此方法无法解决跨域请求的Cookie问题。</p>
<h3 id="WKProcessPool同步方案解决跨域问题"><a href="#WKProcessPool同步方案解决跨域问题" class="headerlink" title="WKProcessPool同步方案解决跨域问题"></a>WKProcessPool同步方案解决跨域问题</h3><p>苹果开发者文档对WKProcessPool的定义是：<a href="https://developer.apple.com/documentation/webkit/wkprocesspool" target="_blank" rel="noopener">A WKProcessPool object represents a pool of Web Content process.</a> 通过让所有WKWebView共享同一个WKProcessPool实例，可以实现多个 WKWebView之间共享Cookie（session Cookie and persistent Cookie）数据。</p>
<p>既然可以多个WKWebView共享一个WKProcessPool实例，那么是不是可以先访问跨域的URL，将Cookie注入，不就得到了一个有跨域Cookie的WKProcessPool实例吗？再用此实例去访问原始的Web页面，不就可以解决跨域访问的Cookie问题了吗？ 经过实测，此方案是OK的。 样例如下：</p>
<p>可以创建一个单例管理WKProcessPool。如果Cookie更新了，更新WKProcessPool即可同步。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateProcessPool &#123;</span><br><span class="line">    _isUpdatePooling = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_webView) &#123;</span><br><span class="line">        _webView.navigationDelegate = <span class="literal">nil</span>;</span><br><span class="line">        [_webView removeFromSuperview];</span><br><span class="line">        _webView = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_delegate &amp;&amp; [_delegate respondsToSelector:<span class="keyword">@selector</span>(willUpdateCookieWithPool)]) &#123;</span><br><span class="line">        [_delegate willUpdateCookieWithPool];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JS注入</span></span><br><span class="line">    <span class="built_in">NSString</span> *jsStr = [<span class="keyword">self</span> updateCookieScriptString];</span><br><span class="line">    <span class="comment">//JS注入的domain（跨域注入会失败）</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.pingan.com.cn/"</span>];</span><br><span class="line">    <span class="built_in">WKUserScript</span> * cookieScript =</span><br><span class="line">    [[<span class="built_in">WKUserScript</span> alloc] initWithSource:jsStr</span><br><span class="line">                           injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class="line">                        forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line">    <span class="built_in">WKUserContentController</span>* userContentController = <span class="built_in">WKUserContentController</span>.new;</span><br><span class="line">    [userContentController addUserScript:cookieScript];</span><br><span class="line">    <span class="built_in">WKWebViewConfiguration</span>* configuration = <span class="built_in">WKWebViewConfiguration</span>.new;</span><br><span class="line">    configuration.userContentController = userContentController;</span><br><span class="line">    configuration.processPool = <span class="keyword">self</span>.pool;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span> configuration:configuration];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication].keyWindow addSubview:webView];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">3</span>];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">    _webView = webView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="built_in">WKNavigation</span> *)navigation &#123;</span><br><span class="line">    LOG_INFO(<span class="string">"WEB"</span>, <span class="string">@"didFinishNavigation :%@"</span>, navigation);</span><br><span class="line">    webView.navigationDelegate = <span class="literal">nil</span>;</span><br><span class="line">    [webView removeFromSuperview];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">void</span>(^block)(<span class="built_in">WKProcessPool</span> *pool) <span class="keyword">in</span> _handlers) &#123;</span><br><span class="line">            block(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        [_handlers removeAllObjects];</span><br><span class="line">        _isUpdatePooling = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_delegate &amp;&amp; [_delegate respondsToSelector:<span class="keyword">@selector</span>(didUpdateCookieWithPool)]) &#123;</span><br><span class="line">        [_delegate didUpdateCookieWithPool];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line">- (<span class="keyword">void</span>)getCookieWithProcessPoolHandler:(<span class="keyword">void</span>(^)(<span class="built_in">WKProcessPool</span> *pool))handler &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isUpdatePooling) &#123;</span><br><span class="line">        [_handlers addObject:handler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler(_pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于WKProcessPool只能在初始化时传入有效，所以调用有一点特殊：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">PAWFWebProcessPoolManager *cookieManager = [PAWFWebProcessPoolManager sharedManager];</span><br><span class="line">[cookieManager getCookieWithProcessPoolHandler:^(<span class="built_in">WKProcessPool</span> * _Nonnull pool) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>.webView = [<span class="keyword">self</span> creatWebViewWithPool:pool];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.webView];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:<span class="keyword">self</span>.URL];</span><br><span class="line">    [<span class="keyword">self</span>.webView loadRequest:request];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">WKWebView</span> *)creatWebViewWithPool:(<span class="built_in">WKProcessPool</span> *)pool &#123;</span><br><span class="line">    <span class="built_in">WKWebViewConfiguration</span>* configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">    configuration.processPool = pool;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kScreenWidth, <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.contentView.frame) - kGrwonStatusBarHeight);</span><br><span class="line">    <span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:frame configuration:configuration];</span><br><span class="line">    wkWebView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> wkWebView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WKHTTPCookieStore同步cookie问题"><a href="#WKHTTPCookieStore同步cookie问题" class="headerlink" title="WKHTTPCookieStore同步cookie问题"></a>WKHTTPCookieStore同步cookie问题</h3><p><code>WKHTTPCookieStore</code>，存在一些奇怪的bug，完全无法使用，已知问题如下：</p>
<h4 id="无法正常写入cookie的Bug："><a href="#无法正常写入cookie的Bug：" class="headerlink" title="无法正常写入cookie的Bug："></a>无法正常写入cookie的Bug：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *cookieProperties = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"wifi_jsessionid"</span> forKey:<span class="built_in">NSHTTPCookieName</span>];</span><br><span class="line">[cookieProperties setObject:jsessionid forKey:<span class="built_in">NSHTTPCookieValue</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@".pingan.com.cn"</span> forKey:<span class="built_in">NSHTTPCookieDomain</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@""</span> forKey:<span class="built_in">NSHTTPCookieOriginURL</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"/"</span> forKey:<span class="built_in">NSHTTPCookiePath</span>];</span><br><span class="line">[cookieProperties setObject:<span class="string">@"0"</span> forKey:<span class="built_in">NSHTTPCookieVersion</span>];</span><br><span class="line"><span class="built_in">NSHTTPCookie</span> *cookie = [<span class="built_in">NSHTTPCookie</span> cookieWithProperties:cookieProperties];</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKWebsiteDataStore</span> *store = [<span class="built_in">WKWebsiteDataStore</span> defaultDataStore];</span><br><span class="line">[store.httpCookieStore setCookie:cookie completionHandler:^&#123;</span><br><span class="line">    [store.httpCookieStore getAllCookies:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; * _Nonnull cookies) &#123;</span><br><span class="line">        <span class="comment">//读取不到写入的cookie。 </span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>使用迂回方式解决写入问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加observer代理</span></span><br><span class="line">[store.httpCookieStore addObserver:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：网络不畅通时，存在不回调的情况。网络ok后才会调用。原因不明</span></span><br><span class="line">- (<span class="keyword">void</span>)cookiesDidChangeInCookieStore:(<span class="built_in">WKHTTPCookieStore</span> *)cookieStore &#123;</span><br><span class="line">    <span class="built_in">WKWebsiteDataStore</span> *store = [<span class="built_in">WKWebsiteDataStore</span> defaultDataStore];</span><br><span class="line">    [store.httpCookieStore getAllCookies:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; * _Nonnull cookies) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">"WEB"</span>, <span class="string">@"cookiesDidChangeInCookieStore: %@"</span>, cookies);</span><br><span class="line">        <span class="comment">//参考链接：https://forums.developer.apple.com/thread/97194</span></span><br><span class="line">        <span class="comment">//此时才能看到Cookie被写入了</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：-140191"><a href="#cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：-140191" class="headerlink" title="cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：#140191"></a>cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：<a href="https://bugs.webkit.org/show_bug.cgi?id=140191" target="_blank" rel="noopener">#140191</a></h4><ul>
<li>自测添加跨域的cookie, Cookie添加成功后进行跨域访问，cookie无法生效。</li>
<li>自测添加正常cookie也无法生效。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">Can I set the cookies to be used by a WKWebView?
</a></li>
<li><a href="https://juejin.im/entry/5880ac602f301e006980d1f5" target="_blank" rel="noopener">WKWebView 那些坑</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS crash文件符号化</title>
    <url>/2018/02/27/iOS-crash%E6%96%87%E4%BB%B6%E7%AC%A6%E5%8F%B7%E5%8C%96/</url>
    <content><![CDATA[<p>carsh文件符号化需要<code>symbolicatecrash</code>脚本、<code>.crash</code>文件、产生crash的app对应的<code>.dSYM</code>文件。脚本可以通过<code>.dSYM</code>文件对<code>.crash</code>文件进行格式化。</p>
<a id="more"></a>

<h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><h4 id="查找symbolicatecrash脚本"><a href="#查找symbolicatecrash脚本" class="headerlink" title="查找symbolicatecrash脚本"></a>查找<code>symbolicatecrash</code>脚本</h4><p>执行命令：<code>find /Applications/Xcode.app/ -name symbolicatecrash</code>， 返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/WatchSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br><span class="line">/Applications/Xcode.app//Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>

<p>找到四个结果，随意使用一个即可，这里使用：<code>/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</code></p>
<h4 id="提取crash文件"><a href="#提取crash文件" class="headerlink" title="提取crash文件"></a>提取<code>crash</code>文件</h4><ul>
<li>连上发生crash的手机，在Xcode的Window -&gt; Devices and Simulator 下，选中发生crash的设备，点击<code>View Device Logs</code>按钮</li>
<li>找到对应的crash日志，点击右键，选择<code>Export Log</code>导出。</li>
</ul>
<blockquote>
<p>不是所有的crash，都能产生crash日志。 没有crash日志只能通过其它方式debug.</p>
</blockquote>
<h4 id="提取dSYM文件"><a href="#提取dSYM文件" class="headerlink" title="提取dSYM文件"></a>提取<code>dSYM</code>文件</h4><ul>
<li>如果是xcode上打的包，在Xcode的Window -&gt; Organizer下，选中对应的app</li>
<li>选中对应的包，点击右键，选择Show in Finder，找到对应的<code>.xcarchive</code>文件</li>
<li>点击右键，选择<code>显示包内容</code>，在dSYMs文件夹中找到对应的<code>.dSYM</code>文件</li>
</ul>
<blockquote>
<p>如果使用脚本打包，注意<code>.dSYM</code>文件的存档</p>
</blockquote>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul>
<li>建立目录，将上述三个文件放入同一个目录</li>
<li>进入指定目录，执行<code>./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash</code>，会生成格式化的<code>crash</code>文件。</li>
</ul>
<blockquote>
<p>如果出现报错<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code>执行<code>export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer</code>修复。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS的ipa包重签名</title>
    <url>/2016/04/23/iOS%E7%9A%84ipa%E5%8C%85%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p>日常开发中，我们需要一个Apple账号用于发布App到AppStore，一个企业账号用于内部发布测试及给客户演示。但是Apple限制<code>Bundle Identifier</code>是不能重复的。所以我们有时候需要使用企业证书对个人证书发布的ipa包进行重签名。(注：当然你也可以用于其他用途，但是有被Apple封杀的风险)</p>
<h3 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h3><p>为了能对整个流程进行更好的说明，这里设置一些模拟数据</p>
<ul>
<li>App 在AppStore的<em>Bundle Identifier</em>:<code>com.test.AppStore</code></li>
<li>企业证书的名称：<code>iPhone Distribution: Shenzhen Test Technology Co., Ltd.</code></li>
<li>企业证书对应的Prefix：<code>828E9CDH56</code></li>
<li>企业账号用于发布的<em>Provisioning Profiles</em>文件名：<code>TestDistributionForEnterprise.mobileprovision</code></li>
<li>企业账号用于发布的<em>Provisioning Profiles</em>对应的<em>Bundle Identifier</em>：<code>com.test.enterprise</code></li>
</ul>
<blockquote>
<p>注：如果重签名后需要支持消息推送服务，需要把对应的Identifiers勾选<code>Push Notifications</code>服务</p>
</blockquote>
<a id="more"></a>

<h3 id="重签名流程"><a href="#重签名流程" class="headerlink" title="重签名流程"></a>重签名流程</h3><h4 id="创建entitlements-plist授权文件"><a href="#创建entitlements-plist授权文件" class="headerlink" title="创建entitlements.plist授权文件"></a>创建<code>entitlements.plist</code>授权文件</h4><ul>
<li><code>entitlements.plist</code>文件内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;keychain-access-groups&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;828E9CDH56.*&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;key&gt;get-task-allow&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;false&#x2F;&gt;</span><br><span class="line">    &lt;key&gt;application-identifier&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;828E9CDH56.com.test.enterprise&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;com.apple.developer.team-identifier&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;828E9CDH56&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;aps-environment&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;production&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure></li>
<li>图示如下：<br><img src="http://7xqwu9.com1.z0.glb.clouddn.com/entitlements.png" alt=""></li>
</ul>
<h3 id="ipa文件处理"><a href="#ipa文件处理" class="headerlink" title="ipa文件处理"></a>ipa文件处理</h3><ul>
<li>使用个人账号证书打包（和往常上传AppStore一样操作），导出ipa文件，文件名为<code>test.ipa</code>。</li>
<li>将<code>test.ipa</code>后缀改成<code>zip</code>并进行解压得到一个文件<code>Payload</code></li>
<li>删除<code>Payload/test.app/_CodeSignature</code> 以及 <code>Payload/test.app/embedded.mobileprovision</code>两个文件</li>
</ul>
<h4 id="替换证书配置文件（文件名为embedded，不能自定义）"><a href="#替换证书配置文件（文件名为embedded，不能自定义）" class="headerlink" title="替换证书配置文件（文件名为embedded，不能自定义）"></a>替换证书配置文件（文件名为embedded，不能自定义）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp TestDistributionForEnterprise.mobileprovision Payload&#x2F;test.app&#x2F;embedded.mobileprovision</span><br></pre></td></tr></table></figure>

<h4 id="重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）"><a href="#重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）" class="headerlink" title="重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）"></a>重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certifierName&#x3D;&quot;iPhone Distribution: Shenzhen Test Technology Co., Ltd.&quot;</span><br><span class="line">codesign -f -s $certifierName  --entitlements entitlements.plist Payload&#x2F;test.app</span><br></pre></td></tr></table></figure>

<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r resignTest.ipa Payload</span><br></pre></td></tr></table></figure>

<p>这样就得到了一个新的文件<code>resignTest.ipa</code>，可以企业发布给任何人安装，同时<em>Bundle Identifier</em>依然是<code>com.test.AppStore</code></p>
<blockquote>
<p><strong>注意：</strong><br>1、如果不在Payload所在目录进行打包，如<code>xxx/Payload</code>，则会导致打包出来的安装包无法安装，原因不明。<br>2、如果之前有安装过对应App测试版本，会导致安装失败，可能是缓存导致的问题。</p>
</blockquote>
<h4 id="Extension支持"><a href="#Extension支持" class="headerlink" title="Extension支持"></a>Extension支持</h4><p>在iOS开发中，Extension越来越多，尤其是很多app添加了Today Extension，在重签名的时候需要对extension进行处理，如果有多个extension，那么每个extension都要做重签名处理。对extension进行重签名流程如下：</p>
<ul>
<li>找到<code>PlugIns</code>目录下对应的Extension文件</li>
<li>与对app进行重签名一样，删除Extension里面的<code>_CodeSignature</code>目录，删除<code>embedded.mobileprovision</code>文件。</li>
<li>使用codesign命令进行重签名，证书与主app一致。命令也一样，修改对应的entitlements.plist和指定目录即可。 例：<code>codesign -f -s $certifierName  --entitlements extension_entitlements.plist Payload/test.app/PlugIns/extension.appex</code></li>
</ul>
<p>这里有两个注意事项：</p>
<ul>
<li>先对Extension进行签名，再对主app进行签名，不然会报错说codesign内容被修改之类的错误</li>
<li>重签名的时候注意证书的传参，如果对证书名字中有空格又没有用””引起来，会导致找不到证书。</li>
<li>如果报错<code>This application&#39;s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.</code>，那么应该是安装了一个同样bundle id的app， 把它删掉重新安装就可以了。</li>
</ul>
<h4 id="企业发布"><a href="#企业发布" class="headerlink" title="企业发布"></a>企业发布</h4><ul>
<li>按照常规的企业发布方式来即可<blockquote>
<p><strong>注意：</strong>1、企业发布后出现在有些机型可以安装成功，有些机型安装失败，刚开始怀疑是打的包有问题，后来发现是由于用于安装的plist文件里面的<code>display-image</code>以及<code>full-size-image</code>链接有问题，修复后OK<br>2、如果出现有的手机能安装， 有的手机不能安装， 那可能是.mobileprovision没有被正确替换导致的。</p>
</blockquote>
</li>
</ul>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>我把整个流程用<code>Python</code>做了一个脚本，功能流程如下 <code>打包ipa</code>–&gt;<code>重签名</code>–&gt;<code>上传服务器</code>–&gt;<code>发送邮件</code>，<a href="https://github.com/xx-li/iOSAutoPackaging" target="_blank" rel="noopener">点此可以下载</a>。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Xcode模板加速及规范开发</title>
    <url>/2020/06/29/%E4%BD%BF%E7%94%A8Xcode%E6%A8%A1%E6%9D%BF%E5%8A%A0%E9%80%9F%E5%8F%8A%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>前言：开发效率和质量是每位开发人员永恒的追求，而Xcode的模板功能可以帮助你更好的达成这个目标，更难能可贵的是它还能在一定程度上帮助你统一实现逻辑和开发规范。</p>
<a id="more"></a>

<h2 id="为什么需要使用模板"><a href="#为什么需要使用模板" class="headerlink" title="为什么需要使用模板"></a>为什么需要使用模板</h2><p>在日常开发中，经常会碰到开发类似功能的情况，我们可以使用面向对象编程的继承来对相同部分进行封装，利用多态来进行特定功能区分，这样可以提高开发效率和质量。当然也有函数式开发和面向协议编程等，但是万变不离其宗，大家都在提模块化，组件化，以提高开发效率、质量、可维护性等。但是不管使用哪种框架和编码方式，都不可能干掉所有的重复代码和重复逻辑，依然会存在很多复制、粘贴等重复操作。例如我们在项目基础框架之上实现两个列表模块A和B，那么A和B模块中大部分的代码文件都是类似的，里面的内容也都是类似的。</p>
<p>为了减少这些重复操作导致的效率低下，我们可以使用Dash或Gist等工具，创建代码片段，来快速的复制粘贴代码，但是这些只限定于单个文件内的文本编辑。如果你所做的项目对某一类功能的实现已经有了固定套路，例如一个常见的列表页面，包含下拉刷新、加载更多等功能，你选择了MVC或MVVM等架构模式，那么在单个项目内，每个列表页面的代码（在一个文件或多个文件中）将会大量相似，每次都要重复的创建类似的文件，写类似的实现。如果是多人开发，还可能会在大体框架基础下搞出好几套大同小异的代码来，而这样的害处是显而易见的。</p>
<h2 id="如何使用模板加速开发？"><a href="#如何使用模板加速开发？" class="headerlink" title="如何使用模板加速开发？"></a>如何使用模板加速开发？</h2><h3 id="模板工具"><a href="#模板工具" class="headerlink" title="模板工具"></a>模板工具</h3><p>在软件开发中，要提高效率，就得把重复的工作交给电脑来做，电脑会做的又快又好。针对上面提到的问题，我们完全可以创建一套模板，然后通过脚本或者IDE来批量生成代码，生成代码后，只需要修改其中的少量代码就可以完成全部功能，这样就避免了大量的文件创建和代码复制粘贴操作，也避免了一些由于操作失误导致的bug，同时也避免了一些不同开发人员的不同实现逻辑的问题。</p>
<p>我了解到有两种实现方案：</p>
<ol>
<li><a href="https://seongbrave.github.io/gckit/guide/" target="_blank" rel="noopener">介绍 | Gckit-CLI</a><br><img src="gckit.png" alt=""></li>
<li>Xcode自定义模板</li>
</ol>
<p>我刚开始是使用的<code>Gckit-CLI工</code>工具，但是发现<code>Xcode</code>原生支持自定义模板后，我转向了使用<code>Xcode自定义模板</code>，因为集成在IDE中使用起来更加的便捷。所以这里我只介绍<code>Xcode自定义模板</code>功能的使用，对<code>Gckit-CLI</code>感兴趣的可以去它的<a href="https://seongbrave.github.io/gckit/guide/" target="_blank" rel="noopener">官网</a>自行查看。</p>
<h3 id="Xcode自定义模板的使用"><a href="#Xcode自定义模板的使用" class="headerlink" title="Xcode自定义模板的使用"></a>Xcode自定义模板的使用</h3><h4 id="Xcode系统默认模板说明"><a href="#Xcode系统默认模板说明" class="headerlink" title="Xcode系统默认模板说明"></a>Xcode系统默认模板说明</h4><p>Xcode在创建项目或文件时，就是使用了Xcode自带的模板功能。 它包含<code>iOS</code>、<code>watchOS</code>、<code>tvOS</code>、<code>macOS</code>菜单，在iOS菜单下又分为<code>Source</code>、<code>User Interface</code>等类别，类别里面有<code>Cocoa Touch Class</code>、<code>Swift File</code>等模块，图示如下：</p>
<p><img src="creat_file.png" alt=""></p>
<p>这些模板的路径位置如下：</p>
<ul>
<li>iOS 平台模版的位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>watchOS 平台的模版位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>tvOS 平台的模版位置：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>macOS 平台文件模版的位置：<br><code>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates</code></li>
</ul>
<blockquote>
<p>这里我们仅拿iOS平台模板来进行说明</p>
</blockquote>
<p>我们看iOS平台模板的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── File\ Templates</span><br><span class="line">│   ├── Apple\ Watch</span><br><span class="line">│   ├── Playground</span><br><span class="line">│   ├── Resource</span><br><span class="line">│   ├── Source</span><br><span class="line">│   └── User\ Interface</span><br><span class="line">└── Project\ Templates</span><br><span class="line">    └── iOS</span><br></pre></td></tr></table></figure>
<p><code>Project\ Templates</code>是创建项目的模板，这里不做说明。<code>File\ Templates</code>目录下的内容就是上面图示中<code>iOS</code>菜单下的内容，例如我们根据<code>Source</code> -&gt; <code>Cocoa Touch Class</code>的模板创建文件，会进入如下页面：<br><img src="creat_file_next.png" alt=""></p>
<h5 id="Xcode模板页面的生成"><a href="#Xcode模板页面的生成" class="headerlink" title="Xcode模板页面的生成"></a>Xcode模板页面的生成</h5><p><code>Cocoa Touch Class</code>模板文件目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── File\ Templates</span><br><span class="line">│   ├── Source</span><br><span class="line">│   │   ├── Cocoa\ Touch\ Class.xctemplate  # Cocoa Touch Class模板文件目录</span><br><span class="line">│   │   │   ├── NSObjectObjective-C</span><br><span class="line">│   │   │   ├── NSObjectSwift</span><br><span class="line">│   │   │   ├── TemplateIcon.png</span><br><span class="line">│   │   │   ├── TemplateIcon@2x.png</span><br><span class="line">│   │   │   ├── TemplateInfo.plist   # 根据此文件生成页面和匹配模板目录</span><br><span class="line">│   │   │   ├── UICollectionReusableViewObjective-C</span><br><span class="line">│   │   │   ├── UICollectionReusableViewXIBObjective-C</span><br><span class="line">│   │   │   │   ├── UICollectionReusableViewObjective-C</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.h</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.m</span><br><span class="line">│   │   │   |   │   ├── ___FILEBASENAME___.xib</span><br><span class="line">│   │   │   ├── ...</span><br><span class="line">├── ...</span><br><span class="line">│   ├── ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述页面对应<code>Cocoa Touch Class.xctemplate</code>目录下的<code>TemplateInfo.plist</code>文件，这个页面是根据此文件生成的。 我们看下<code>TemplateInfo.plist</code>文件的内容（内容太多，只贴出部分，上面的注释是作者添加的）：</p>
<figure class="highlight plist"><table><tr><td class="code"><pre><span class="line">··· 省略部分</span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span> # 这里对应中间的子类输入控件</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>cocoaTouchSubclass<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Required<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  # 必须展示这个控件在页面上</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Subclass of:<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  # 左边的说明文本</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>What class to subclass in the new file<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">key</span>&gt;</span>    # UI样式类型是class类型，可以输入值，也可以选择值</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>class<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">key</span>&gt;</span>   # 默认选择的值是NSObject</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>NSObject<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>FallbackHeader<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>#import <span class="symbol">&amp;lt;</span>UIKit/UIKit.h<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Values<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  # 可选择的列表</span><br><span class="line">			<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>NSObject<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UIView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UIViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UITableViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UITableViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>UICollectionReusableView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Suffixes<span class="tag">&lt;/<span class="name">key</span>&gt;</span> # 输入匹配相关</span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UIViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>ViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UITableViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>TableViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UITableViewCell<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>TableViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionViewController<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionViewCell<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionViewCell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>UICollectionReusableView<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>CollectionReusableView<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dict</span>&gt;</span>   # 对应最底部的语言选择按钮</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>languageChoice<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Required<span class="tag">&lt;/<span class="name">key</span>&gt;</span> # 必须展示这个控件在页面上</span><br><span class="line">			<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Language:<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  # 左边的说明文本</span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>The implementation language<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">key</span>&gt;</span>   #UI样式是popup，弹出列表选择值</span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>popup<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">string</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>Values<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">array</span>&gt;</span> # 可选择的列表</span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>MainTemplateFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>___FILEBASENAME___.swift<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">string</span>&gt;</span>___FILEBASENAME___.m<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span>&gt;</span>AllowedTypes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.swift-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">key</span>&gt;</span>Objective-C<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.objective-c-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">string</span>&gt;</span>public.objective-c-plus-plus-source<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">··· 省略部分</span><br></pre></td></tr></table></figure>

<h5 id="模板的匹配"><a href="#模板的匹配" class="headerlink" title="模板的匹配"></a>模板的匹配</h5><p>用户在上述页面填写和选择了内容后，点击<code>Next</code>创建，就进入了模板匹配逻辑。假如用户在<code>Subclass of</code>选项中输入或选择了<code>UICollectionReusableView</code>，不勾选<code>Also create XIB file</code>勾选框，在<code>Language</code>选项中选择<code>Objective-C</code>，那么Xcode就会将这两个值按顺序拼接起来，得到文件名：<code>UICollectionReusableViewObjective-C</code>，然后会在<code>TemplateInfo.plist</code>文件所在目录中，搜索文件名为<code>UICollectionReusableViewObjective-C</code>的文件夹，如果有就取这个文件夹内模板文件来生成代码（有几个文件就生成几个）。如果没搜索到，就进行默认创建。</p>
<h5 id="模板代码如何生成"><a href="#模板代码如何生成" class="headerlink" title="模板代码如何生成"></a>模板代码如何生成</h5><p>在上面流程中，已经匹配到了<code>UICollectionReusableViewObjective-C</code>模板，这个模板存在两个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UICollectionReusableViewObjective-C</span><br><span class="line">├── ___FILEBASENAME___.h</span><br><span class="line">└── ___FILEBASENAME___.m</span><br></pre></td></tr></table></figure>

<p>其中<code>___FILEBASENAME___.h</code>的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;___FILEHEADER___</span><br><span class="line"></span><br><span class="line">___IMPORTHEADER_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<p>Xcode会使用用户在创建页面输入的类名来替换文件名中的<code>___FILEBASENAME___</code>，使用用户在<code>Subclass of</code>中输入的内容来替换<code>___VARIABLE_cocoaTouchSubclass___</code>，使用之前设置好的文件注释头来替换<code>___FILEHEADER___</code>，全部替换完成后写入文件输出，呈现给用户的就是创建文件完成。到此为止，通过模板创建文件整个流程全部走完了。</p>
<blockquote>
<p>Xcode模板的相关配置和字段较多，可以根据里面的内容和展示的页面和行为来猜测每个字段的含义，然后依葫芦画瓢来学习Xcode模板是如何工作的。（如果您有找到这方面的文档，请评论区告诉我）</p>
</blockquote>
<h4 id="如何创建Xcode自定义模板"><a href="#如何创建Xcode自定义模板" class="headerlink" title="如何创建Xcode自定义模板"></a>如何创建Xcode自定义模板</h4><p>自定义模板和系统模板的实现和使用基本是一样的。将自定义模板放在特定目录下时，Xcode就会将自定义模板加载出来。</p>
<blockquote>
<p>修改模板后要重启xcode才能生效。</p>
</blockquote>
<p>自定义模板的路径是：<code>~/Library/Developer/Xcode/Templates</code>(如果不存在<code>Templates</code>目录，就手动创建一个。)<br>在此路径下，我们创建一个<code>Custom</code>目录，将系统模板中的<code>Cocoa\ Touch\ Class.xctemplate</code>目录复制到<code>Custom</code>目录下，这样在工程中新建文件就可以看到自定义的Custom目录及它下面的<code>Cocoa\ Touch\ Class</code>模板了：<br><img src="creat_file_custom.png" alt=""></p>
<p>到了这一步，你就会清楚自定义模板的套路了，剩下的就是依葫芦画瓢来实现自己的模板了。</p>
<p>我根据个人常用编程习惯，创建了一套模板，大家可以下载进行参考。下载地址： <a href="https://github.com/xx-li/CustomTemplates" target="_blank" rel="noopener">GitHub - xx-li/CustomTemplates: Xcode rapid development templates</a>，</p>
<p>使用图示：<br><img src="xcode_template_demo.gif" alt=""></p>
<h4 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h4><p>由于模板的匹配是目录匹配方式，所以每一个选项都会对应一个新的目录，例如一个2*2的选项，就会需要四个模板目录来进行匹配。当我们对模板进行功能细分时，就需要创建大量的模板，而每一个模板可能有大量内容是相似的，修改一个基础逻辑就要对所有的模板文件进行修改。为了解决这种问题，可以使用脚本来创建模板。</p>
<p>在上面的仓库中<a href="https://github.com/xx-li/CustomTemplates" target="_blank" rel="noopener">CustomTemplates</a>，有用Python写的模板生成脚本。因为是用于个人项目，生成的代码缺乏基础框架支持，并不能直接使用，您可以参考编写适用于自己的脚本和模板。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/infinum/iOS-VIPER-Xcode-Templates" target="_blank" rel="noopener">iOS-VIPER-Xcode-Templates</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建一个Flutter Plugin</title>
    <url>/2020/06/15/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAFlutter-Plugin/</url>
    <content><![CDATA[<h2 id="什么是plugin"><a href="#什么是plugin" class="headerlink" title="什么是plugin"></a>什么是plugin</h2><p><code>Flutter</code>和<code>Dart</code>生态系统的软件包有两种模板，分别是<code>packages</code>和<code>plugin</code>，其中plugin包含<code>Android</code>、<code>iOS</code>平台特定实现，一般需要Flutter端与Android或iOS进行通讯交互（类比Hybrid或RN中JS与Native的交互），以实现特定功能。 </p>
<h2 id="创建plugin"><a href="#创建plugin" class="headerlink" title="创建plugin"></a>创建plugin</h2><p>一般使用命令创建Plugin：<code>flutter create —org com.example —template=plugin hello</code>，执行命令后，会在当前目录下生成一个<code>hello</code>文件夹，里面是一个plugin的简单demo实现。iOS可以使用OC和Swift，Android可以使用Java和kotlin进行代码编写，命令默认使用swift及kotlin，如需修改，使用<code>-i</code>及<code>-o</code>命令。例如要创建一个使用OC及java的plugin，命令为：<code>flutter create —org com.example —template=plugin -a java -o objc hello</code>。</p>
<h2 id="平台通道数据类型及编解码器"><a href="#平台通道数据类型及编解码器" class="headerlink" title="平台通道数据类型及编解码器"></a>平台通道数据类型及编解码器</h2><p>在平台通道进行数据传输时，Flutter它会自动对这些值进行序列化和反序列化。 下表展示了如何在平台端接收 Dart 值，反之亦然：</p>
<p><img src="args.jpg" alt=""></p>
<h3 id="创建一个样例Demo"><a href="#创建一个样例Demo" class="headerlink" title="创建一个样例Demo"></a>创建一个样例Demo</h3><p>为了更好的说明流程，这里创建一个禁用截屏功能的plugin进行说明，plugin提供三个功能：<code>全局添加水印</code>、<code>截屏监控</code>、<code>禁用截屏</code>。其中<code>全局添加水印</code>为在Flutter当前页面栈的最上层添加一个半透、有水印、穿透触摸事件的全遮盖页面，为纯dart实现，不需要与平台进行交互； <code>截屏监控</code>为当平台监听到截屏行为后，立即通知Flutter端，是一个持续通讯的过程；<code>禁用截屏</code>为Flutter端通知平台执行禁用操作（只支持Android平台）。<br>此plugin已经开发完成并发布到官方pub，可以在<a href="https://github.com/xx-li/disable_screenshots" target="_blank" rel="noopener">GitHub - disable_screenshots</a>下载并查看源码。</p>
<a id="more"></a>

<ol>
<li>创建命令：<code>flutter create --org com.devlxx --template=plugin disable_screenshots</code></li>
<li>执行命令后会生成如下目录：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── disable_screenshots</span><br><span class="line">│   ├── CHANGELOG.md</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── android</span><br><span class="line">│   ├── disable_screenshots.iml</span><br><span class="line">│   ├── example</span><br><span class="line">│   ├── ios</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── pubspec.lock</span><br><span class="line">│   ├── pubspec.yaml</span><br><span class="line">│   └── test</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>pubspec.yaml：plugin的配置文件。里面有字段：<code>name</code>、<code>description</code>、<code>version</code>、<code>homepage</code>，这些均是字面意思，很好理解。另外有字段<code>environment</code>，指定插件的使用环境，最关键的是有一个flutter字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The following section is specific to Flutter.</span><br><span class="line">flutter:</span><br><span class="line">  # This section identifies this Flutter project as a plugin project.</span><br><span class="line">  # The &#39;pluginClass&#39; and Android &#39;package&#39; identifiers should not ordinarily</span><br><span class="line">  # be modified. They are used by the tooling to maintain consistency when</span><br><span class="line">  # adding or updating assets for this project.</span><br><span class="line">  plugin:</span><br><span class="line">    platforms:</span><br><span class="line">      android:</span><br><span class="line">        package: com.devlxx.disable_screenshots</span><br><span class="line">        pluginClass: DisableScreenshotsPlugin</span><br><span class="line">      ios:</span><br><span class="line">        pluginClass: DisableScreenshotsPlugin</span><br></pre></td></tr></table></figure>
<p>这个字段说明了plugin支持的平台以及各平台的入口class，这个需要能一一对应。默认会给你创建好，不要随意修改这里及类名即可。</p>
</li>
<li><p><code>README.md</code>  : 项目说明。当发布到官方的<code>pub.dev</code>后，插件的Readme栏目内容即为此文件内容。</p>
</li>
<li><p><code>lib</code>：plugin<code>Flutter</code>端的实现</p>
</li>
<li><p><code>ios</code>：plugin<code>ios</code>端的实现</p>
</li>
<li><p><code>android</code>：plugin<code>android</code>端的实现</p>
</li>
<li><p><code>example</code>：plugin的使用demo，可以运行此demo进行测试，另外demo里面也有<code>README.md</code>文件，当发布到官方的<code>pub.dev</code>后，插件的Example栏目内容即为此文件内容。</p>
</li>
</ul>
<ol start="3">
<li>Flutter与iOS、Android通讯原理<br>Flutter只是一个UI框架，与平台相关的功能只能由平台来原生实现，这就需要Flutter与原生进行相互通讯。它们通过PlatformChannel进行互相通讯，核心原理是：<ul>
<li>Flutter通过PlatformChannel将要传递的数据编码后，跨线程发送到宿主（iOS或Android）</li>
<li>宿主接收到PlatformChannel的消息后，执行原生API。</li>
<li>宿主执行完原生API后，将数据编码并原路返回给应用程序的Flutter部分<br>图示如下：<br><img src="PlatformChannels.png" alt=""></li>
</ul>
</li>
</ol>
<p>PlatformChannel有三种类型，分别是：<code>BasicMessageChannel</code>、<code>MethodChannel</code>、<code>EventChannel</code>。其中<code>BasicMessageChannel</code>接收一个MessageCodec<T>作为其编解码器的实现，允许我们使用自定义的消息编解码进行异步消息传递，这里不对其做说明。</p>
<pre><code>- `MethodChannel`：用于Flutter主动调用平台端的方法，并获得相应的返回值，例如获取系统电量、发起Toast等，可以说是“一次性”的调用。这里将通过它来告知平台端禁用截屏功能
- `EventChannel`，用于传递事件。例如Flutter要监听电量变化，平台端可以将监听到的电量变化情况持续的通过`EventChannel`传递给Flutter端。这里将通过它来`截屏监控`功能。</code></pre><h3 id="disable-screenshots的禁用截屏功能实现（MethodChannel）"><a href="#disable-screenshots的禁用截屏功能实现（MethodChannel）" class="headerlink" title="disable_screenshots的禁用截屏功能实现（MethodChannel）"></a><code>disable_screenshots</code>的<code>禁用截屏</code>功能实现（MethodChannel）</h3><ol>
<li><p>Flutter端实现<br>创建命令会在<code>lib</code>目录下生成一个<code>disable_screenshots.dart</code>文件，里面会有一个默认的<code>MethodChannel</code>实现样例，我们对其进行修改，修改后的核心源码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line"><span class="keyword">final</span> MethodChannel methodChannel = <span class="keyword">const</span> MethodChannel(<span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过MethodChannel将方法名和参数编码后发到平台端</span></span><br><span class="line">methodChannel.invokeMethod(<span class="string">"disableScreenshots"</span>, &#123;<span class="string">"disable"</span>: disable&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android端实现（kotlin）<br>创建命令会在<code>android</code>目录下的<code>/src/main/kotlin/com/devlxx/disable_screenshots/</code>生成一个<code>DisableScreenshotsPlugin.kt</code>文件，其中实现<code>禁用截屏</code>的核心代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToEngine</span><span class="params">(applicationContext: <span class="type">Context</span>, messenger: <span class="type">BinaryMessenger</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext</span><br><span class="line">	  <span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line">    <span class="keyword">this</span>.channel = MethodChannel(messenger, <span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>)</span><br><span class="line">    <span class="comment">//handle指向了this，this必须实现onMethodCall方法</span></span><br><span class="line">    <span class="keyword">this</span>.channel.setMethodCallHandler(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodCall</span><span class="params">(<span class="meta">@NonNull</span> call: <span class="type">MethodCall</span>, <span class="meta">@NonNull</span> result: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (call.method == <span class="string">"disableScreenshots"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> disable = call.argument&lt;<span class="built_in">Boolean</span>&gt;(<span class="string">"disable"</span>) == <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 禁止截屏需要获取到当前的activity，如何获取到activity请自行查看源码，这里不做说明。</span></span><br><span class="line">      <span class="keyword">if</span> (disable) &#123;</span><br><span class="line">	    activity.window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);</span><br><span class="line">	    println(<span class="string">"禁用截屏"</span>)</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 允许截屏</span></span><br><span class="line">	    activity.window.clearFlags(WindowManager.LayoutParams.FLAG_SECURE)</span><br><span class="line">	    println(<span class="string">"允许截屏"</span>)</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">// 调用后，Flutter端的invokeMethod会收到调用的结果，结果为一个空字符串</span></span><br><span class="line">      result.success(<span class="string">""</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.notImplemented()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS端实现。（iOS无法实现禁止截屏功能，这里仅做说明）<br>创建命令会在<code>ios</code>目录下的<code>Classes/</code>下生成一个<code>DisableScreenshotsPlugin.swift</code>文件，其中实现<code>禁用截屏</code>的核心代码为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(with registrar: FlutterPluginRegistrar)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="type">SwiftDisableScreenshotsPlugin</span>()</span><br><span class="line">    <span class="comment">// 1. 创建一个MethodChannel</span></span><br><span class="line">    <span class="keyword">let</span> methodChannel = <span class="type">FlutterMethodChannel</span>(name: <span class="string">"com.devlxx.DisableScreenshots/disableScreenshots"</span>, binaryMessenger: registrar.messenger())</span><br><span class="line">    registrar.addMethodCallDelegate(instance, channel: methodChannel)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">FlutterPlugin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="number">_</span> call: FlutterMethodCall, result: @escaping FlutterResult)</span></span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //iOS平台无法实现禁用截屏功能，这里仅做MethodChannel的使用说明</span></span><br><span class="line"><span class="comment">        if call.method == "disableScreenshots" &#123;</span></span><br><span class="line"><span class="comment">            if let arg = call.arguments as? Dictionary&lt;String, Any&gt;, let disable = arg["disable"] as? Bool &#123;</span></span><br><span class="line"><span class="comment">                if disable &#123;</span></span><br><span class="line"><span class="comment">                    //禁用截屏</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    //允许截屏</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                print("【SwiftDisableScreenshotsPlugin】disableScreenshots 收到错误参数")</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            result(FlutterMethodNotImplemented)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        result(<span class="type">FlutterMethodNotImplemented</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="disable-screenshots的截屏监控功能实现（EventChannel）"><a href="#disable-screenshots的截屏监控功能实现（EventChannel）" class="headerlink" title="disable_screenshots的截屏监控功能实现（EventChannel）"></a><code>disable_screenshots</code>的<code>截屏监控</code>功能实现（EventChannel）</h3><ol>
<li><p>Flutter端实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建EventChannel</span></span><br><span class="line"><span class="keyword">final</span> EventChannel eventChannel = <span class="keyword">const</span> EventChannel(<span class="string">'com.devlxx.DisableScreenshots/observer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 监听平台端发来的事件</span></span><br><span class="line">_eventChannel.receiveBroadcastStream().listen((event) &#123;</span><br><span class="line">  <span class="comment">//平台端发来事件后会调用到这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android端实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建EventChannel</span></span><br><span class="line"><span class="keyword">val</span> eventChannel = EventChannel(messenger, <span class="string">"com.devlxx.DisableScreenshots/observer"</span>)</span><br><span class="line"><span class="comment">// 2. handle指向了this，this必须实现onListen及onCancel方法。</span></span><br><span class="line">eventChannel.setStreamHandler(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onListen</span><span class="params">(arguments: <span class="type">Any</span>?, events: <span class="type">EventChannel</span>.<span class="type">EventSink</span>?)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"开始监听"</span>)</span><br><span class="line">    <span class="comment">// 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端</span></span><br><span class="line">    eventSink = events</span><br><span class="line">    <span class="comment">// 5. ScreenShotListenManager为一个实现了监听截屏功能的Manager</span></span><br><span class="line">    screenShotListenManager = ScreenShotListenManager.newInstance(applicationContext)</span><br><span class="line">    screenShotListenManager.setListener &#123; imagePath -&gt;</span><br><span class="line">      println(<span class="string">"监听到截屏，截屏图片地址是：<span class="variable">$imagePath</span>"</span>)</span><br><span class="line">      <span class="comment">// 6. 发送事件给Flutter端，告知监听到了截屏行为。</span></span><br><span class="line">      eventSink?.success(<span class="string">"监听到截屏行为"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    screenShotListenManager.startListen()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventChannel被取消</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancel</span><span class="params">(arguments: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    screenShotListenManager.stopListen()</span><br><span class="line">    eventSink = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS端实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> eventSink: <span class="type">FlutterEventSink?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册使用此插件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(with registrar: FlutterPluginRegistrar)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="type">SwiftDisableScreenshotsPlugin</span>()</span><br><span class="line">    <span class="comment">// 1. 创建EventChannel</span></span><br><span class="line">    <span class="keyword">let</span> channel = <span class="type">FlutterEventChannel</span>(</span><br><span class="line">        name: <span class="string">"com.devlxx.DisableScreenshots/observer"</span>,</span><br><span class="line">        binaryMessenger: registrar.messenger()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 2. 设置handler为SwiftDisableScreenshotsPlugin，它必须实现onListen及onCancel方法</span></span><br><span class="line">    channel.setStreamHandler(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="number">6</span>. 发送事件给<span class="type">Flutter</span>端，告知监听到了截屏行为。</span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">callScreenshots</span><span class="params">()</span></span> &#123;</span><br><span class="line">    eventSink!(<span class="string">"监听到截屏行为"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SwiftDisableScreenshotsPlugin</span>: <span class="title">FlutterStreamHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onListen</span><span class="params">(withArguments arguments: <span class="keyword">Any</span>?, eventSink events: @escaping FlutterEventSink)</span></span> -&gt; <span class="type">FlutterError?</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端</span></span><br><span class="line">        eventSink = events</span><br><span class="line">        <span class="comment">// 5. iOS端实现截屏监听功能很简单，添加相应通知的监听即可。</span></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">            <span class="keyword">self</span>,</span><br><span class="line">            selector: #selector(callScreenshots),</span><br><span class="line">            name: <span class="type">UIApplication</span>.userDidTakeScreenshotNotification,</span><br><span class="line">            object: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EventChannel被取消</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCancel</span><span class="params">(withArguments arguments: <span class="keyword">Any</span>?)</span></span> -&gt; <span class="type">FlutterError?</span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">        eventSink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>综合MethodChannel及EventChannel的三端实现来看，它们的使用还是比较简单的，对于开发者来说，挑战在于需要对三端都熟悉，并写出高质量的代码。<br>在实际开发时，可以先用相应的开发者工具打开Example目录下的iOS及Android的项目，分别进行平台特定代码的开发、调试。当iOS及Android的平台代码编写完成后，再直接运行Example项目，进行Flutter端的功能开发及整体的调试。</p>
<h3 id="全局添加水印"><a href="#全局添加水印" class="headerlink" title="全局添加水印"></a>全局添加水印</h3><p>全局添加水印不涉及平台端，为纯Flutter端实现。和常规的Flutter Dart代码编写没什么差异，这里不做说明，具体实现可以直接查看源码。</p>
<h2 id="发布plugin"><a href="#发布plugin" class="headerlink" title="发布plugin"></a>发布plugin</h2><p>当plugin的三端代码写好后，需要进行发布。plugin的发布非常简单，分为两步。<br>第一步为检查项目是否OK，执行命令：<code>flutter packages pub publish --dry-run</code>后，会提示项目是否存在遗漏或者异常部分，如果有异常，根据提示进行修复即可。例如此项目在执行此命令时，有提示存在问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Package validation found the following potential issue:</span><br><span class="line">* Your pubspec.yaml includes an &quot;author&quot; section which is no longer used and may be removed.</span><br></pre></td></tr></table></figure>
<p>这个是Flutter的一个bug，默认创建的模板会包含一个author字段，但是却无法检查通过，将pubspec.yaml中的author字段删除即可检查通过。</p>
<p>检查通过后，可以执行第二步，执行命令：<code>flutter packages pub publish</code>进行发布。执行后，根据命令行会提示进行操作，需要注意的是有一个验证身份的操作，将命令行出现的网址在浏览器中打开，然后在此页面登录自己的Google账号，这样就会将这个plugin与你的账号进行绑定及身份验证，操作完成后即发布成功，命令行输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Do you want to publish disable_screenshots 0.0.1 (y&#x2F;N)? y</span><br><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br><span class="line">In a web browser, go to https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?access_type&#x3D;offline&amp;approval_prompt&#x3D;force&amp;response_type&#x3D;code&amp;client_id&#x3D;81fds5108-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A54755&amp;scope&#x3D;openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email</span><br><span class="line">Then click &quot;Allow access&quot;.</span><br><span class="line"></span><br><span class="line">Waiting for your authorization...</span><br><span class="line">Authorization received, processing...</span><br><span class="line">Successfully authorized.</span><br><span class="line">Uploading...</span><br><span class="line">Successfully uploaded package.</span><br></pre></td></tr></table></figure>

<p>plugin发布成功后并不能立即在官方的<a href="https://pub.dev/" target="_blank" rel="noopener">pub</a>中搜到，它需要一段时间来处理，但是可以直接输入地址看到：<a href="https://pub.dev/flutter/packages?q=disable_screenshots" target="_blank" rel="noopener">https://pub.dev/flutter/packages?q=disable_screenshots</a></p>
<h2 id="发布失败问题处理"><a href="#发布失败问题处理" class="headerlink" title="发布失败问题处理"></a>发布失败问题处理</h2><p>有时候会上传失败，提示<code>Failed to upload the package</code>。失败有可能是如下几种情况导致：</p>
<h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>以为package是发布到google的服务器上，如果无法科学上网，肯定是会失败的。有些同学开启代理后依然无法上传成功，那么需要检查终端是否走的代理（终端默认不走代理）。<br>此时需要给终端设置代理，也就是<code>命令行代理</code>。<br>在<code>mac</code>平台中，在<code>.bash_profile</code>文件中加入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端走代理</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">proxy_on</span></span>()&#123;</span><br><span class="line">    <span class="built_in">export</span> http_proxy=http://127.0.0.1:1087  <span class="comment">#填写您本地的实际代理端口</span></span><br><span class="line">    <span class="built_in">export</span> https_proxy=http://127.0.0.1:1087  <span class="comment">#填写您本地的实际代理端口</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"已开启代理"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">proxy_off</span></span>()&#123;</span><br><span class="line">    <span class="built_in">unset</span> http_proxy</span><br><span class="line">    <span class="built_in">unset</span> https_proxy</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"已关闭代理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打开终端后使用<code>proxy_on</code>，即可开启命令行代理。<br>当然你也可以使用<code>软路由科学上网</code>等其他方式让所有程序都走代理。</p>
<h3 id="镜像配置导致的问题"><a href="#镜像配置导致的问题" class="headerlink" title="镜像配置导致的问题"></a>镜像配置导致的问题</h3><p>很多同学使用pub的国内镜像来提高package拉取的速度，但是这些镜像设置会导致上传失败。 上传时将这些镜像配置关闭即可。</p>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p>一直失败无法找到原因时，可以使用命令<code>flutter packages pub publish --verbose</code>显示详细log，以分析问题出现的原因。例如有时候会出现异常log：<code>HTTP response 400 Bad Request for POST https://storage.googleapis.com</code>，这个并不是网络问题导致的，而是权限问题，添加<code>subo</code>执行：<code>sudo flutter packages pub publish --verbose</code> 。 即可上传成功</p>
<h3 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h3><p>如果上述操作都无法解决问题，可以去官方仓库的<a href="https://github.com/flutter/flutter/issues/16658" target="_blank" rel="noopener">issue</a>中查找答案或提问。</p>
<h2 id="引用plugin"><a href="#引用plugin" class="headerlink" title="引用plugin"></a>引用plugin</h2><p>plugin开发完后，我们可以选择多种方式将plugin提供给其它开发者使用：<br>    - 从本地路径引入<br>    - 从Git仓库引入<br>    - 从官方pub引入（需要先发布到官方pub）<br>    - 从指定源引入</p>
<h3 id="本地路径引入"><a href="#本地路径引入" class="headerlink" title="本地路径引入"></a>本地路径引入</h3><p>plugin中的Example引入plugin就是通过本地路径方式引入的，这种方式很方便本地修改和调试，进入方式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">disable_screenshots:</span></span><br><span class="line">	  <span class="comment"># 当前pubspec.yaml文件的上一级目录是plugin所在目录</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">../</span></span><br></pre></td></tr></table></figure>

<h3 id="从Git仓库引入"><a href="#从Git仓库引入" class="headerlink" title="从Git仓库引入"></a>从Git仓库引入</h3><p>顾名思义，直接从Git仓库拉取plugin，可以指定分支及路径。企业内部引用可以使用此种方式。样例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">disable_screenshots:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">https://github.com/xx-li/disable_screenshots</span></span><br><span class="line">		<span class="attr">path:</span> <span class="string">path/to/disable_screenshots</span>  <span class="comment">#这里只做说明，实际disable_screenshots插件在根目录，不需要指定路径。</span></span><br></pre></td></tr></table></figure>


<h3 id="官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using-packages-Flutter"><a href="#官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using-packages-Flutter" class="headerlink" title="官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using packages  - Flutter"></a>官方pub引入及指定源引入这里不做说明，详情可以看官方教程：<a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages" target="_blank" rel="noopener">Using packages  - Flutter</a></h3><h2 id="问题备忘"><a href="#问题备忘" class="headerlink" title="问题备忘"></a>问题备忘</h2><ol>
<li>在老的flutter项目中，在iOS平台运行可能出现编译问题无法运行。这个是由于老的flutter项目里面没有使用到swift，所以没有briging文件，但是插件使用了swift，所以会编译失败，这种情况直接使用xcode在iOS项目中创建一个swift文件，会自动生成briding文件。<br><img src="bridging.png" alt=""></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/huiger/ScreenShotDemo" target="_blank" rel="noopener">GitHub - huiger/ScreenShotDemo: 🔥Android 手机应用内截屏, 截屏监听</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/Experimental:-Create-Flutter-Plugin" target="_blank" rel="noopener">Experimental: Create Flutter Plugin · flutter/flutter Wiki · GitHub</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages" target="_blank" rel="noopener">Using packages  - Flutter</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages" target="_blank" rel="noopener">Developing packages &amp; plugins  - Flutter</a></li>
<li><a href="https://flutter.dev/docs/development/platform-integration/platform-channels#example-project" target="_blank" rel="noopener">Writing custom platform-specific code  - Flutter</a></li>
<li><a href="https://fiissh.tech/2019/flutter-basic-message-channel.html" target="_blank" rel="noopener">Flutter 开发（14）：BasicMessageChannel 的使用 | 肥言肥语</a></li>
<li><a href="https://stackoverflow.com/questions/60048704/how-to-get-activity-and-context-in-flutter-plugin" target="_blank" rel="noopener">dart - How to get Activity and Context in Flutter plugin - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>对独立开发的思考</title>
    <url>/2021/03/01/%E5%AF%B9%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="独立开发经历"><a href="#独立开发经历" class="headerlink" title="独立开发经历"></a>独立开发经历</h3><h5 id="第一个小程序项目"><a href="#第一个小程序项目" class="headerlink" title="第一个小程序项目"></a>第一个小程序项目</h5><p>我在17年的时候买人生的第一套房，是一套二手房，当时对二手房的各项交易费用一知半解，感觉自己就像一头屠宰桌上的猪，任人宰割。刚好那个时候微信小程序开始兴起，基于学习兴趣和需求，做了一个计算购房费用的小程序（在微信上搜索“首付款计算器”可以看到）。做出来后找了一个中介朋友，让他以激活码的方式帮我销售，收入五五分成，他帮我销售了几份后反馈有的客户没法安装（微信版本异常），有的客户有异常问题（非技术问题）。那个时候刚好工作比较忙，又觉得整这些事情太麻烦了（收益低），就没有更新和维护这个项目了。</p>
<h5 id="第二个跨平台项目"><a href="#第二个跨平台项目" class="headerlink" title="第二个跨平台项目"></a>第二个跨平台项目</h5><p>在20年的时候，由于年龄的逐渐增长，开始考虑去扩展一些额外的收入点。那个时候刚好在学习<code>Flutter</code>，就想用<code>Flutter</code>对之前的项目进行重构，做市面上<code>最专业的购房费用计算器</code>。当时的初衷是想从开发到发布，系统的学习一项新技能，另外就是看能不能赚点钱。但是实际情况和我预想的有点偏差，我增加了很多预想之外的需求。</p>
<a id="more"></a>

<p>一开始只想支持长沙的新房和二手房费用计算，但是做到后面想支持北上广深，因为这意味着更大的市场。为了支持不同城市，我对计算层进行了重构，引入了词法分析，支持不同的城市根据配置数据进行费用计算（不同城市的费用不一样），而这又引入了新的问题，配置下发和更新需要接口提供支持。<br>然后我决定用<code>Go</code>开发后台，我自学了<code>Go</code>的语法和<code>Beego</code>框架，然后又学习了<code>Docker</code>，编写了部署脚本，把后台部署在了自己购买的云服务器上面。</p>
<p>后面想到都有接口了，干脆开发一套用户体系，对计算结果进行收藏和管理吧，于是开发了用户体系，对计算层又进行了修改，支持修改和列表显示，加入了版本升级、用户反馈等常规功能。</p>
<p>这些对于技术人来说，都是轻车熟路，不熟悉的地方查查文档也能解决。最麻烦的地方在于不同城市的费用计算规则，一般人觉得购房就是一些税费什么的很简单，但是我当时是想做市面上最专业的购房计算器，需要支持住宅、商业的计算，然后购房者、卖房者有个人（非中国籍、中国籍）、公司（大公司、小公司）、机构等各种情况，实际上是非常复杂的。我伪装成购房者在各大购房平台咨询中介费用问题，但是有些问题中介也不清楚，还有些问题不同中介回复的不一样，最终没有办法，只有跑到当地的房管局进行咨询确认，所以最终这个项目只支持了长沙和深圳的费用计算。</p>
<p>项目完成后iOS端顺利发布到了AppStore，Android端在各大应用商店发布需要软著，后面就没有发了，自己通过云存储部署了一个简单的H5页面来进行Android端的分发。在这里不得不说AppStore的强大，在我没有做推广的情况下，还是有一定的下载量（付费下载），让我收回了购买Apple开发者账号的成本。</p>
<h3 id="对独立开发的反思"><a href="#对独立开发的反思" class="headerlink" title="对独立开发的反思"></a>对独立开发的反思</h3><p>以上是我做项目的前期，但是我完全没有考虑清楚项目后期的事情，那就是维护和营销。在我们的工作中，经常接触到这两个词，也知道是什么意思，但是在自己的个人项目中，你对这两个词有可能会有完全不一样的理解。我开始思考自己这个项目的意义，是用于学习技术还是为了赚钱？是为了做一个好的产品还是为了炫技？</p>
<p>所幸我看了一篇公众号文章<a href="https://mp.weixin.qq.com/s/pNbyg3BPF1iaHBeMYWc8zQ" target="_blank" rel="noopener">和软件开发相关的一些思考</a>，作者叫<code>liuyubobobo</code>，我很喜欢的一位开发者。文章中有一小段视频：<a href="https://v.qq.com/x/page/p3124yg5fm7.html" target="_blank" rel="noopener">97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？</a>，我觉得自己就像是这个视频中的程序员，讲着一堆牛逼的技术术语，但实际上却不知道如何做好一个项目。后面经过思考，我发现自己犯了如下错误：</p>
<ol>
<li>没有想清楚是要学习还是要赚钱。抱着又想学习又想赚钱的想法，两头都没有做好。</li>
<li>盲目的给项目引入了过多的技术，导致后续维护成本很高。个人开发者没有必要维护自己的后台，更没有必要维护一套自建的用户体系，使用对应平台的云接口，稳定，开发效率高。</li>
<li>进入了一个自己不熟悉的领域（房产），我需要学习新的知识，还要跟上数据更新的步伐，不停的去学习。我分析一些做的好的个人开发者，都是做的工具类的软件，不需要把精力花费在陌生领域的学习，可以把精力集中在打磨产品的体验方面。</li>
<li>选择以App的承载方式来做这个项目是错误的，微信小程序才是最好的方案。（给好几个朋友推荐，都是反问，你为什么不做成微信小程序类？）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做一个好的产品，应该从用户体验出发，去思考能给用户提供什么？能给用户带来什么？然后再倒推用什么技术，在人力与资源受限时，我们要学会借力于平台，使用稳定可靠的技术。让用户打开我们产品的时候，都会说：太好了，这就是我想要的！而不是坐在那里，想着自己有什么吊炸天的技术，然后怎么把它卖出去。<br>另外关于营销，我觉得其中的学问是不亚于技术的，需要持续的学习和实践，像我17年的小程序项目那样，能找到一个专业的销售人员绑定在一起，对产品的销售是很有帮助的。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><a href="http://qiniu.devlxx.com/index.html" target="_blank" rel="noopener">个人项目下载地址</a></li>
<li><a href="https://v.qq.com/x/page/p3124yg5fm7.html" target="_blank" rel="noopener">97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？</a></li>
<li><a href="https://mp.weixin.qq.com/s/pNbyg3BPF1iaHBeMYWc8zQ" target="_blank" rel="noopener">和软件开发相关的一些思考</a></li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Aspects框架的源码解读及问题解析</title>
    <url>/2021/10/18/Aspects%E6%A1%86%E6%9E%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS日常开发中，对某些方法进行hook是很常见的操作。最常见的是使用Category在<code>+load</code>中进行方法swizzle，它是针对类的，会改变这个类所有实例的行为。但是有时候我们只想针对单个实例进行hook，这种方法就显得无力了。而<code>Aspects</code>框架可以搞定这个问题。<br>它的原理是通过<code>Runtime</code>动态的创建子类，把实例的<code>isa</code>指针指向新创建的子类，然后在子类中对hook的方法进行处理，这样就支持了对单个实例的hook。<code>Aspects</code>框架支持对类和实例的hook，API很易用，可以方便的让你在任何地方进行hook，是线程安全的。但是<code>Aspects</code>框架也有一些缺陷，一不小心就会掉坑里面，我会通过源码解析进行说明。</p>
<a id="more"></a>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>我主要使用图示对<code>Aspects</code>的源码进行说明，建议参考源码一起查看。要看懂这些内容，需要对<code>isa指针</code>，<code>消息转发机制</code>，<code>runtime</code>有一定的了解，本文中不会对这些内容展开来讲，因为要把这些东西讲清楚，每一项都需要单独写一篇文章了。</p>
<h3 id="主要流程解析"><a href="#主要流程解析" class="headerlink" title="主要流程解析"></a>主要流程解析</h3><ol>
<li>它第一个流程是使用关联对象添加<code>Container</code>，在这个过程中会进行一些前置条件的判断，例如这个方法是否支持被hook等，如果条件验证通过，就会把这次hook的信息保存起来，在方法调用的时候，查询出来使用。</li>
<li>第二个流程是动态创建子类，如果是针对类的hook，则不会走这一步。</li>
<li>第三步是替换这个类的<code>forwardInvocation:</code>方法为<code>__ASPECTS_ARE_BEING_CALLED__</code>，这个方法内部会查找到之前创建的Container，然后根据Container中的逻辑进行实际的调用。</li>
<li>第四步是将原有方法的<code>IMP</code>改为<code>_objc_msgForward</code>，改完后当调用原有方法时，就会调用<code>_objc_msgForward</code>，从而触发<code>forwardInvocation:</code>方法。</li>
</ol>
<p>我对它的流程做了一个简化的图示，标有每个流程的序号，后面会对每个流程进行解析。流程如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101110315.png" alt=""></p>
<p>图示中的<code>取出对象类型</code>，是指的调用hook的对象的类型，如果是<code>实例对象</code>，那么就走<code>类</code>路径；如果是<code>类</code>对象，则走<code>元类</code>路径；如果是<code>kvo</code>等实际类型不一致的情况，则走<code>其它子类</code>路径。</p>
<h3 id="①添加Container流程"><a href="#①添加Container流程" class="headerlink" title="①添加Container流程"></a>①添加Container流程</h3><p>这个流程中，把hook的逻辑封装成Container，并使用关联对象进行保存。这个过程中会判断hook的方法是否被支持、判断被hook类的继承关系、验证回调block正确性等操作。具体图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101112238.png" alt=""></p>
<p>关键代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    aspect_performLocked(^&#123; <span class="comment">// 加锁</span></span><br><span class="line">        <span class="comment">// hook前置条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 用selector作key，通过关联对象获得Container对象。</span></span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="comment">// 内部会判断block与hook的selector是否匹配，不匹配返回nil。</span></span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="comment">// 添加identifier，包含了hook的类型和回调。 </span></span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *disallowedSelectorList;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        disallowedSelectorList = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"retain"</span>, <span class="string">@"release"</span>, <span class="string">@"autorelease"</span>, <span class="string">@"forwardInvocation:"</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里对不支持hook的方法进行过滤</span></span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Selector %@ is blacklisted."</span>, selectorName];</span><br><span class="line">        AspectError(AspectErrorSelectorBlacklisted, errorDescription);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dealloc只支持AspectPositionBefore类型下调用</span></span><br><span class="line">    AspectOptions position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@"dealloc"</span>] &amp;&amp; position != AspectPositionBefore) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = <span class="string">@"AspectPositionBefore is the only valid position when hooking dealloc."</span>;</span><br><span class="line">        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="keyword">self</span>.class instancesRespondToSelector:selector]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to find selector -[%@ %@]."</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class), selectorName];</span><br><span class="line">        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里禁止有继承关系的类hook同一个方法，代码量较多，不是关键内容，这里不贴出</span></span><br><span class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// AspectsContainer内部添加AspectIdentifier的实现。</span></span><br><span class="line"><span class="comment">/// 这里可以看出对同一个方法的多次hook都会被调用，不会出现后面hook的覆盖前面的情况。</span></span><br><span class="line">- (<span class="keyword">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(aspect);</span><br><span class="line">    <span class="built_in">NSUInteger</span> position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionBefore:  <span class="keyword">self</span>.beforeAspects  = [(<span class="keyword">self</span>.beforeAspects ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionInstead: <span class="keyword">self</span>.insteadAspects = [(<span class="keyword">self</span>.insteadAspects?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionAfter:   <span class="keyword">self</span>.afterAspects   = [(<span class="keyword">self</span>.afterAspects  ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从源码中可以看到，不支持的hook方法有<code>[NSSet setWithObjects:@&quot;retain&quot;, @&quot;release&quot;, @&quot;autorelease&quot;, @&quot;forwardInvocation:&quot;, nil];</code>。其中<code>retain</code>, <code>release</code>, <code>autorelease</code>在arc下是被禁用的，框架本身是<code>hook</code>了<code>forwardInvocation:</code>进行实现的，所以对它的hook也不支持。</li>
<li><code>dealloc</code>只支持<code>AspectPositionBefore</code>类型，使用<code>AspectPositionInstead</code>会导致系统默认的<code>dealloc</code>操作被替换无法执行而出现问题。 <code>AspectPositionAfter</code>类型，调用时对象可能已经已经被释放了，从而引发野指针错误。</li>
<li><code>Aspects</code>禁止有继承关系的类hook同一个方法，具体可以参见它的一个<a href="https://github.com/steipete/Aspects/issues/2" target="_blank" rel="noopener">issue</a>，它报告了这样操作会导致死循环，我会在文章后面再进行说明。</li>
<li><code>Aspects</code>使用<code>block</code>进行hook的调用，涉及到方法参数的传递和返回值问题，所以其中会对block进行校验。</li>
</ol>
<h3 id="②runtime创建子类"><a href="#②runtime创建子类" class="headerlink" title="②runtime创建子类"></a>②runtime创建子类</h3><p>iOS中的<code>KVO</code>就是通过<code>runtime</code>动态创建子类，然后在子类中重写对应的<code>setter</code>方法来实现的，<code>Aspects</code>支持对单个实例的hook原理与此有一些类似。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101141441.png" alt=""><br>具体说明请查看源码中的注释</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行hook</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// 针对实例类型，会通过runtime动态创建子类。类类型则直接hook。</span></span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">	Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">	<span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经被hook过的类，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">		<span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是元类(MetaClass)，则代表是对类进行hook。（非单个实例）</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="comment">// 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// 可能是一个KVO对象等情况，传入实际的类型进行hook。</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个实例的情况，动态创建子类进行hook.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">		aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">        <span class="comment">// 重写class方法，返回之前的类型，而不是新创建的子类。避免hook后，类型判断出现问题。</span></span><br><span class="line">		aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">		objc_registerClassPair(subclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">	<span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③替换forwardInvocation"><a href="#③替换forwardInvocation" class="headerlink" title="③替换forwardInvocation:"></a>③替换forwardInvocation:</h3><p>这部分就是把原有的<code>forwardInvocation:</code>替换为自定义的实现：<code>__ASPECTS_ARE_BEING_CALLED__</code>。源码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> AspectsForwardInvocationSelectorName = <span class="string">@"__aspects_forwardInvocation:"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// If there is no method, replace will act like class_addMethod.</span></span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(<span class="string">@"Aspects: %@ is now aspect aware."</span>, <span class="built_in">NSStringFromClass</span>(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换后的对应关系图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101143612.png" alt=""></p>
<h3 id="④hook方法交换IMP"><a href="#④hook方法交换IMP" class="headerlink" title="④hook方法交换IMP:"></a>④hook方法交换IMP:</h3><p>图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101144025.png" alt=""></p>
<p>第③步和第④步可能有些同学会感到疑惑，为什么要替换<code>forwardInvocation</code>以及为什么要将hook的方法的<code>IMP</code>替换为<code>_objc_msgForward</code>，这个和iOS的<code>消息转发机制</code>有关，可以自行查找相关资料，这里就不做说明了。需要注意的是有些框架也是通过iOS的消息发送机制来做一些操作，例如<code>JSPatch</code>，使用的时候需要注意，避免发生冲突。</p>
<h3 id="被hook方法的调用流程"><a href="#被hook方法的调用流程" class="headerlink" title="被hook方法的调用流程"></a>被hook方法的调用流程</h3><p>当hook注入后，对hook方法进行调用时，调用流程就会发生变化。图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101145147.png" alt=""></p>
<p>从上述解析过程中，我们可以看到<code>Aspects</code>这个框架是设计的很巧妙的，从中可以看到非常多<code>runtime</code>知识的应用。但是作者并不推荐在实际项目中进行使用：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101145635.png" alt=""></p>
<p>因为Apsects对类的底层进行了修改，这种修改是基础方面的修改，需要考虑到各种场景和边界问题，一旦某方面考虑不周，就会引发出一些未知问题。另外这个框架是有缺陷的，很久没有进行更新了，我对它的已知问题点进行了总结，在下面进行说明。如果有未总结到位的，欢迎补充。</p>
<h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><h3 id="基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。"><a href="#基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。" class="headerlink" title="基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。"></a>基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。</h3><p>之前这样会出现死循环，后面作者进行了修改，对这个行为进行了<code>禁止</code>并加了错误提示。详见这个<a href="https://github.com/steipete/Aspects/issues/2" target="_blank" rel="noopener">issue</a></p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __PRETTY_FUNCTION__);</span><br><span class="line">    [<span class="keyword">super</span> foo]; <span class="comment">// 导致死循环的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    [B aspect_hookSelector:<span class="keyword">@selector</span>(foo) atPosition:AspectPositionBefore withBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSArray</span> *arguments) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"before -[B foo]"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [A aspect_hookSelector:<span class="keyword">@selector</span>(foo) atPosition:AspectPositionBefore withBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSArray</span> *arguments) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"before -[A foo]"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    B *b = [[B alloc] init];</span><br><span class="line">    [b foo]; <span class="comment">// 调用后死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道，<code>super</code>是从它的父类开始查找方法，然后传入<code>self</code>进行调用。 根据我们之前对源码的解析，在这里调用<code>[super foo]</code>后会从父类查找<code>foo</code>的<code>IMP</code>，查到后发现父类的<code>IMP</code>已经被替换为<code>_objc_msgForward</code>，然后传入<code>self</code>调用。 因为是传入的<code>self</code>，所以实际会调用到它自身的<code>forwardInvocation:</code>，这样就导致了死循环。</p>
<h3 id="针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。"><a href="#针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。" class="headerlink" title="针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。"></a>针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。</h3><p>这里通过代码进行说明，以Animal对象为例：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testKVO &#123;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"Animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"observeValueForKeyPath keypath:%@ name:%@"</span>, keyPath, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [animal testKVO];</span><br><span class="line">        <span class="comment">// 这里如果改为针对类进行hook，则不会存在问题，因为类hook修改的是Animal类，而实例hook修改的是NSKVONotifying_Animal类</span></span><br><span class="line">        [animal aspect_hookSelector:<span class="keyword">@selector</span>(setName:) </span><br><span class="line">                        withOptions:AspectPositionAfter </span><br><span class="line">                         usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo, <span class="built_in">NSString</span> *name)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="comment">// 这里会crash</span></span><br><span class="line">        animal.name = <span class="string">@"ChangedAnimalName"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常原因分析图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101165246.png" alt=""></p>
<p>上面是继承链和方法调用流程的图示，可以看出，<code>_NSSetObjectValueAndNotify</code>是被<code>aspects__setName:</code>调用的，<code>_NSSetObjectValueAndNotify</code>的内部实现逻辑是取调用它的<code>selector</code>，去父类查找方法，即<code>aspects__setName:</code>方法，而<code>Animal</code>对象并没有这个方法的实现，这就导致了crash。</p>
<h3 id="与category的共存问题"><a href="#与category的共存问题" class="headerlink" title="与category的共存问题"></a>与category的共存问题</h3><p>先用<code>aspects</code>进行hook，再使用<code>category</code>进行hook，会导致crash。反之则没有问题。样例代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span>(<span class="title">hook</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)categoryHook;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span>(<span class="title">hook</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)categoryHook &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">super</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(setName:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(lx_setName:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lx_setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span> lx_setName:name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [Animal aspect_hookSelector:<span class="keyword">@selector</span>(setName:) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo, <span class="built_in">NSString</span> *name)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [Animal categoryHook];</span><br><span class="line">        <span class="comment">// 调用后crash：[Animal lx_setName:]: unrecognized selector sent to instance 0x100608dc0</span></span><br><span class="line">        animal.name = <span class="string">@"ChangedAnimalName"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个与<code>__ASPECTS_ARE_BEING_CALLED__</code>的内部逻辑有关，里面会对调用的方法添加前缀<code>aspect__</code>进行调用，以调用到原始的<code>IMP</code>，但是<code>category</code> hook后破坏了这个流程。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211101182740.png" alt=""></p>
<p>根据上述图示，实际只有<code>aspects__setName</code>，没有<code>aspects__lx_setName</code>，导致找不到方法而crash</p>
<h3 id="基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下："><a href="#基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：" class="headerlink" title="基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下："></a>基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：</h3><figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceMethod;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        [Animal aspect_hookSelector:<span class="keyword">@selector</span>(testInstanceMethod) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook testInstanceMethod"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [object_getClass([Animal <span class="keyword">class</span>]) aspect_hookSelector:<span class="keyword">@selector</span>(testClassMethod) withOptions:AspectPositionBefore usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"aspects hook testClassMethod"</span>);</span><br><span class="line">        &#125; error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [animal testInstanceMethod];</span><br><span class="line">        <span class="comment">// crash: "+[Animal testClassMethod]: unrecognized selector sent to class 0x1000114a0"</span></span><br><span class="line">        [Animal testClassMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的调用在日常开发中非常正常，但是它会导致crash。它是由于<code>aspect_swizzleClassInPlace</code>方法中的逻辑缺陷导致的。</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_swizzleClassInPlace(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// Animal类对象与Animal元类对象会得到同一个字符串。</span></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"aspect_swizzleClassInPlace %@ %p"</span>, klass, object_getClass(klass));</span><br><span class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</span><br><span class="line">        <span class="comment">// 类对象和元类对象得到同一个className，这里后加入的会被错误的过滤掉。</span></span><br><span class="line">        <span class="keyword">if</span> (![swizzledClasses containsObject:className]) &#123;</span><br><span class="line">            aspect_swizzleForwardInvocation(klass);</span><br><span class="line">            [swizzledClasses addObject:className];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> klass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看到，它的去重逻辑只是简单的字符串判断，取Animal的<code>元类</code>和<code>类</code>名得到同一个字符串<code>Animal</code>，导致后添加的被过滤，当调用后被hook的方法后，执行<code>_objc_msgForward</code>，因为后hook的<code>aspect_swizzleForwardInvocation</code>被过滤了没有执行，所以找不到<code>forwardInvocation:</code>的<code>IMP</code>，导致了crash。</p>
<h3 id="objc-msgForward会出现冲突的问题"><a href="#objc-msgForward会出现冲突的问题" class="headerlink" title="_objc_msgForward会出现冲突的问题"></a>_objc_msgForward会出现冲突的问题</h3><p>内部是通过消息转发机制来实现的，使用时要注意，避免与其它使用<code>_objc_msgForward</code>或相关逻辑的框架发生冲突。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>hook后的方法，通过原有消息机制找到<code>IMP</code>后，并不会直接调用。而是会进行消息转发进入到<code>__ASPECTS_ARE_BEING_CALLED__</code>方法，内部再通过key取出相应的<code>Coantiner</code>进行调用，相对于未hook之前，额外增加了调用成本。所以不建议对频繁调用的方法和在项目中大量使用。</p>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><p>框架内部为了保证线程安全，有进行加锁，但是使用的是自旋锁<code>OSSpinLock</code>，存在线程反转的问题，在iOS10已经被标记为弃用。</p>
<h3 id="对类方法的hook，需要使用object-getClass来获取元类对象进行hook"><a href="#对类方法的hook，需要使用object-getClass来获取元类对象进行hook" class="headerlink" title="对类方法的hook，需要使用object_getClass来获取元类对象进行hook"></a>对类方法的hook，需要使用object_getClass来获取元类对象进行hook</h3><p>这个不是框架问题，而是有些同学不知道如何对<code>类方法</code>进行hook，这里进行说明。</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)testClassMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要通过object_getClass来获取元类对象进行hook</span></span><br><span class="line">[object_getClass(Animal) aspect_hookSelector:<span class="keyword">@selector</span>(testClassMethod)     </span><br><span class="line">                                 withOptions:AspectPositionAfter </span><br><span class="line">                                  usingBlock:^(<span class="keyword">id</span>&lt;AspectInfo&gt; aspectInfo)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"aspects hook setName"</span>);</span><br><span class="line">&#125; error:null];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>M1设备的Xcode编译问题深究</title>
    <url>/2021/12/02/M1%E8%AE%BE%E5%A4%87%E7%9A%84Xcode%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E6%B7%B1%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><p>在<code>Apple</code>发布<code>M1</code>芯片之前，一直使用<code>Intel</code>的芯片，没有出现什么问题。发布<code>M1</code>芯片后，由于两者架构的不同（<code>M1</code>是<code>arm64</code>架构，<code>Intel</code>是<code>x86_64</code>的架构），导致很多软件运行出现了问题。我们在<code>M1</code>机型中使用<code>Xcode</code>编译模拟器时，可能会碰到如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld: in youpath&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon(UMComBaseEvent.o), building for iOS Simulator, but linking in object file built for iOS, file &#39;&#x2F;Users&#x2F;mtgj&#x2F;Desktop&#x2F;TestArch1&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon&#39; for architecture arm64</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld: warning: ignoring file YoupPth&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;FMDB&#x2F;FMDB.framework&#x2F;FMDB, building for iOS Simulator-x86_64 but attempting to link with file built for iOS Simulator-arm64</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_OBJC_CLASS_$_FMDatabaseQueue&quot;, referenced from:</span><br><span class="line">      objc-class-ref in SqflitePlugin.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>

<p>这些报错，都是是由于项目中存在<code>.a</code>或<code>.framework</code>静态库导致的。以前，我们创建静态库时，会分别打包出一份针对真机（arm64）和模拟器的（x86_64），然后将这两份合并成一个包后引入项目中进行使用。在<code>Intel</code>机型上，真机上使用<code>arm64</code>指令，模拟器（x86_64）中使用<code>x86_64</code>指令，所以不存在问题。但是在<code>M1</code>机型上，模拟器是以<code>arm64</code>运行的，显然再以<code>x86_64</code>运行就会出现问题。</p>
<a id="more"></a>

<blockquote>
<p>有同学可能会想到包中是有<code>arm64</code>指令（真机）的，拿给以<code>arm64</code>运行的模拟器使用不就可以了吗？ 实际上xcode底层并不是这样处理的，它真机就找真机的，模拟器就找模拟器的。</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><p>对于这类架构报错问题，网上的资料一般会告诉你两个解决方案：</p>
<ol>
<li>以Rosetta模式运行Xcode。</li>
<li>修改<code>Build Settings</code> -&gt; <code>Excluded Architectures</code>选项，添加Any iOS Simulator SDK选项，并设置值为arm64。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211202153049.png" alt=""></li>
</ol>
<p>这两种方案都能解决编译问题，但是也都存在问题。</p>
<blockquote>
<p>在iOS12及以后，不再支持iphone5及以下机型，而后续的机型都是arm64架构，所以这里不再对之前的armv6/armv7/armv7s/i386 等指令集进行说明。</p>
</blockquote>
<h3 id="Rosetta方案说明"><a href="#Rosetta方案说明" class="headerlink" title="Rosetta方案说明"></a>Rosetta方案说明</h3><p>以<code>Rosetta</code>模式运行是<code>M1</code>机器上<code>x86</code>软件无法运行的解决方案，它会将<code>x86</code>指令转译成<code>ARM</code>指令运行，这种转译显然是存在性能损耗的，损耗大概在<code>20%～30%</code>，详情可参考文章：<a href="https://www.huxiu.com/article/393879.html" target="_blank" rel="noopener">苹果换芯，成了开发者们的噩梦？</a>，不到万不得已，不推荐使用这种方案。</p>
<h3 id="Excluded-Architectures方案说明"><a href="#Excluded-Architectures方案说明" class="headerlink" title="Excluded Architectures方案说明"></a>Excluded Architectures方案说明</h3><p>修改<code>Excluded Architectures</code>选项也有它的问题。字面意思是排除架构的意思，我们设置在模拟器中排除<code>arm64</code>就能解决模拟器无法编译<code>arm64</code>的问题。</p>
<p>这样的设置能生效会让人有点费解，我们知道，在intel机型上，模拟器本来就是以<code>x86</code>方式运行的，排除<code>arm64</code>毫无影响。但是在<code>M1</code>机型上，模拟器是以<code>arm64</code>方式运行的，排除了<code>arm64</code>反而能跑，这不是把我的智商摁在地上摩擦么？，但是苹果就是这样干的，当在<code>M1</code>机型上，排除了模拟器的<code>arm64</code>架构后，模拟器还是会以<code>arm64</code>的方式运行，但是模拟器中的app是以<code>x86</code>的方式运行的，对苹果的这个骚操作我们不得不服。图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211202161515.png" alt=""></p>
<blockquote>
<p>这种情况下，模拟器和应用会通过<code>XPC</code>进行通信，虽然理论上不会有问题，但通信时间会比较长，导致一些依赖计时器判断的逻辑会出问题，例如滑动手势，加速度的判断会出一些问题，导致模拟器里大部分情况下列表无法触发惯性滚动。 - by kem</p>
</blockquote>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>有时候在<code>Excluded Architectures</code>选项中排除了模拟器的<code>arm64</code>指令，依然无法编译通过，那么一般是项目设置和cocoapods的设置不一致导致，设置为一致后一般可以解决问题。可以通过在<code>Podfile</code>中添加如下内容来解决：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">      config.build_settings[<span class="string">'EXCLUDED_ARCHS[sdk=iphonesimulator*]'</span>] = <span class="string">"arm64"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h2 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h2><p>通过上述内容，我们知道了问题的由来，它是由于项目中存在<code>.a</code>或<code>.framework</code>，它们提供的指令集不完整导致的。Apple对于这类问题，也提供了解决方案，请由我细细道来。</p>
<p>以Xcode13为例，在我们创建静态库时，选择真机编译出来的包只包含<code>arm64</code>指令，选择模拟器编译出来的会同时包含<code>arm64</code>和<code>x86_64</code>指令。我看一些网上的教程，教别人将模拟器部分的<code>arm64</code>移除，其实大可不必。因为要支持<code>M1</code>机器正常跑模拟器，模拟器必须同时包含<code>arm64</code>和<code>x86_64</code>指令。</p>
<p>2019年的<code>WWDC</code>，<code>apple</code>提供了一种新的框架封装格式<code>XCFramework</code>。简单理解就是以前使用<code>lipo</code>合并不同指令集的包，现在则使用新的指令合并成<code>XCFramework</code>格式。</p>
<p>打包成<code>framework</code>，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree Release-iphoneos/TestFramework.framework</span></span><br><span class="line">Release-iphoneos/TestFramework.framework</span><br><span class="line">├── Headers</span><br><span class="line">│   ├── TestFramework.h</span><br><span class="line">│   └── TestManager.h</span><br><span class="line">├── Info.plist</span><br><span class="line">├── Modules</span><br><span class="line">│   └── module.modulemap</span><br><span class="line">└── TestFramework</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree Release-iphonesimulator/TestFramework.framework</span></span><br><span class="line">Release-iphonesimulator/TestFramework.framework</span><br><span class="line">├── Headers</span><br><span class="line">│   ├── TestFramework.h</span><br><span class="line">│   └── TestManager.h</span><br><span class="line">├── Info.plist</span><br><span class="line">├── Modules</span><br><span class="line">│   └── module.modulemap</span><br><span class="line">├── TestFramework</span><br><span class="line">└── _CodeSignature</span><br><span class="line">    ├── CodeDirectory</span><br><span class="line">    ├── CodeRequirements</span><br><span class="line">    ├── CodeRequirements-1</span><br><span class="line">    ├── CodeResources</span><br><span class="line">    └── CodeSignature</span><br></pre></td></tr></table></figure>
<p>打包成<code>XCFramework</code>后，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree TestFramework.xcframework</span></span><br><span class="line">TestFramework.xcframework</span><br><span class="line">├── Info.plist</span><br><span class="line">├── ios-arm64</span><br><span class="line">│   └── TestFramework.framework</span><br><span class="line">│       ├── Headers</span><br><span class="line">│       │   ├── TestFramework.h</span><br><span class="line">│       │   └── TestManager.h</span><br><span class="line">│       ├── Info.plist</span><br><span class="line">│       ├── Modules</span><br><span class="line">│       │   └── module.modulemap</span><br><span class="line">│       └── TestFramework</span><br><span class="line">└── ios-arm64_x86_64-simulator</span><br><span class="line">    └── TestFramework.framework</span><br><span class="line">        ├── Headers</span><br><span class="line">        │   ├── TestFramework.h</span><br><span class="line">        │   └── TestManager.h</span><br><span class="line">        ├── Info.plist</span><br><span class="line">        ├── Modules</span><br><span class="line">        │   └── module.modulemap</span><br><span class="line">        ├── TestFramework</span><br><span class="line">        └── _CodeSignature</span><br><span class="line">            ├── CodeDirectory</span><br><span class="line">            ├── CodeRequirements</span><br><span class="line">            ├── CodeRequirements-1</span><br><span class="line">            ├── CodeResources</span><br><span class="line">            └── CodeSignature</span><br></pre></td></tr></table></figure>
<p>从上述可以看出，<code>XCFramework</code>就是把两个不同指令集的<code>framework</code>放入了同一个文件夹(<code>.xcframework</code>)，并生成了一个配置文件<code>Info.plist</code>。这样生成的<code>XCFramework</code>就可以完美的解决<code>M1</code>机器无法编译模拟器的问题。</p>
<p><code>XCFramework</code>的创建指令也很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -- 针对.a --</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指令：</span></span><br><span class="line">xcodebuild -create-xcframework -library &lt;path&gt; [-headers &lt;path&gt;] [-library &lt;path&gt; [-headers &lt;path&gt;]...] -output &lt;path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 样例：</span></span><br><span class="line">xcodebuild -create-xcframework -library youpath/TestFramework.a -headers youpath/TestFramework -library youpath/TestFramework.a -headers youpath/TestFramework -output youpath/TestFramework.xcframework</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -- 针对.framework --</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指令：</span></span><br><span class="line">xcodebuild -create-xcframework -framework &lt;path&gt; [-framework &lt;path&gt;...] -output &lt;path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 样例：</span></span><br><span class="line">xcodebuild -create-xcframework -framework Release-iphoneos/TestFramework.framework -framework Release-iphonesimulator/TestFramework.framework -output TestFramework.xcframework</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决<code>M1</code>机型无法编译模拟器的关键就是针对模拟器的包要同时包含<code>arm64</code>和<code>x86_64</code>指令集。如果使用只支持<code>x86_64</code>指令集的模拟器包，就算打包成<code>XCFramework</code>也会依然存在这个问题。</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以现在的情况，很多第三方框架，并没有使用<code>XCFramework</code>，而项目中只要有一个框架没有支持模拟器的<code>arm64</code>指令，那么在<code>M1</code>机器上，模拟器只能以<code>Rosetta</code>模式运行应用，对这一块的普遍支持估计要等M1普及以后了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.huxiu.com/article/393879.html" target="_blank" rel="noopener">苹果换芯，成了开发者们的噩梦？</a></li>
<li><a href="https://blog.csdn.net/tony_vip/article/details/105889734" target="_blank" rel="noopener">armv6、armv7、armv7s、armv8、armv64及其i386、x86_64区别</a></li>
<li><a href="https://juejin.cn/post/6844904031937101838" target="_blank" rel="noopener">细说iOS静态库和动态库</a></li>
<li><a href="https://juejin.cn/post/6844904021430370312" target="_blank" rel="noopener">关于Xcode11的XCFrameworks框架</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议是怎么实现的？</title>
    <url>/2021/12/23/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上层应用开发中，<code>HTTP</code>协议可以说是最常见，使用最频繁的网络协议了。在网上也有非常多的文章进行解读，但是大部分都是讲解<code>HTTP</code>协议的内容和使用，很少有人讲<code>HTTP</code>协议是怎么实现的。网络协议可以涉及很大的广度和深度，不是一篇文章就能讲清楚的，我这里更多的是提供一个思路供读者来思考。本篇文章会基于<code>iOS</code>平台来进行说明，但是并不代表这篇文章只针对<code>iOS</code>开发，因为协议是跨平台的，其中涉及到的编程思想也是。本文会分四个部分进行讲解：</p>
<ol>
<li>第一部分：数据是如何在网络上进行传输的。这部分主要让你对<code>网络模型</code>和各层协议有一个基础的了解，如果您对这部分比较了解，可以直接从第二部分看起。</li>
<li>第二部分：<code>HTTP</code>协议数据是如何转换为<code>TCP</code>数据收发的。</li>
<li>第三部分：<code>HTTP</code>协议中<code>Request</code>和<code>Response</code>的解析和相关逻辑处理。</li>
<li>第四部分：修改<code>HTTP</code>底层实现，完成自有需求。</li>
</ol>
<a id="more"></a>

<h2 id="数据是如何在网络上进行传输的"><a href="#数据是如何在网络上进行传输的" class="headerlink" title="数据是如何在网络上进行传输的"></a>数据是如何在网络上进行传输的</h2><p>数据遵循网络协议进行收发，讲到网络协议，就绕不开<code>OSI模型</code>和<code>TCP/IP参考模型</code>，它们有不同的层次划分，<code>OSI模型</code>分为7层，<code>TCP/IP参考模型</code>分为4层。网上有很多将<code>TCP/IP参考模型</code>映射到<code>OSI模型</code>的说法，由于<code>TCP/IP参考模型</code>和<code>OSI模型</code>不能精确地匹配，还没有一个完全正确，或者说权威的答案，一般认为的对应关系图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211225201250.png" alt=""></p>
<p>HTTP协议属于最上层<code>应用层</code>，<code>网络模型</code>是比较抽象的，在实际编码时，上层应用的开发者一般只接触到应用层，开发者只需要把一个<code>HTTP Reques</code>丢入网络框架，请求完成后就会返回一个<code>HTTP Response</code>，但是它的底层是怎么实现的类？我们先看下图：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223163145.png" alt=""><br>从上图我们可以看到HTTP数据是如何在客户端与服务端之间交互的，网络模型虽然很复杂，但是从某个角度看，可以说是”套娃”，在<code>RFC 1122</code>中描述的沿着不同的层应用数据的封装递减图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223151159.png" alt=""><br>上图中最上层的<code>Data</code>数据代表应用层协议数据，在<code>HTTP</code>协议中，<code>HTTP</code>的<code>request</code>报文和<code>response</code>报文都包含有<code>header</code>，<code>TCP</code>和<code>IP</code>也都有<code>header</code>，它们通过层层”套娃”后发送。</p>
<p>现在我们对数据如何通过网络传输稍微有了一个整体的概念，但是细节是不清楚的。从上述内容中，可以看到，<code>HTTP</code>数据是转换为<code>TCP</code>数据进行传输，对于<code>传输层</code>及以下的内容在这里就不做说明，这里主要讲<code>应用层</code>的<code>HTTP数据</code>是如何通过<code>传输层</code>传输的，以及如何解析的。</p>
<h2 id="HTTP协议数据是如何转换为TCP数据收发的"><a href="#HTTP协议数据是如何转换为TCP数据收发的" class="headerlink" title="HTTP协议数据是如何转换为TCP数据收发的"></a><code>HTTP</code>协议数据是如何转换为<code>TCP</code>数据收发的</h2><p>一般来讲，各系统都会给用户提供<code>HTTP</code>网络框架，例如<code>iOS</code>的<code>NSURLSession</code>，在系统的<code>HTTP</code>网络框架之上，开发者社区又会开发出各种易用版本的封装，例如<code>AFNetworking</code>。对上层开发者来说，<code>HTTP</code>协议的使用一般就是一个框架封装好的<code>Request</code>对象，甚至只是一个<code>URL</code>，使用框架请求完成后，返回一个<code>Response</code>对象，它的底层实现是隐藏的。</p>
<p>我们都知道，计算机的底层是二进制，数据传输也不例外。要把<code>Request</code>对象从主机传输到服务器，那么必须把它转换为二进制，那么它是怎么转换的？又是怎么传输的？</p>
<h3 id="HTTP协议是怎么转换成二进制的？"><a href="#HTTP协议是怎么转换成二进制的？" class="headerlink" title="HTTP协议是怎么转换成二进制的？"></a>HTTP协议是怎么转换成二进制的？</h3><p>网络框架的<code>Request</code>对象为了易用性，经过了层层封装，要传输出去，必须将它转换为二进制数据：<code>Request对象 -&gt; 符合HTTP协议的Request字符串 -&gt; 二进制数据</code>。</p>
<p>HTTP协议中的请求报文：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223155455.png" alt=""><br>响应报文：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223170116.png" alt=""></p>
<p>按照图示请求报文格式，我们可以将<code>Request</code>对象转换为符合<code>HTTP</code>协议的字符串并转换为字节流。样例代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 创建NSURLRequest</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将NSURLRequest转换为二进制数据（这里只针对POST和GET请求进行说明）</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)httpRequestDataWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> * requestStrFrmt = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="built_in">NSURL</span> * url = request.URL;</span><br><span class="line">    <span class="built_in">NSString</span> *requestURI = url.path;</span><br><span class="line">    <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"POST"</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!url.path || url.path.length == <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = <span class="string">@"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"GET"</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.path.length &gt; <span class="number">0</span>  &amp;&amp; url.query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>, url.path, url.query];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.path.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = url.path;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestURI = url.query;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestURI = <span class="string">@"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [requestStrFrmt appendFormat:<span class="string">@"%@ %@ HTTP/1.1\r\n"</span>, request.HTTPMethod, requestURI];</span><br><span class="line">    <span class="keyword">if</span> ([request.allHTTPHeaderFields objectForKey:<span class="string">@"Host"</span>] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"Host: %@\r\n"</span>, url.host];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析请求头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> * key <span class="keyword">in</span> request.allHTTPHeaderFields.allKeys) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"%@: %@\r\n"</span>, key, request.allHTTPHeaderFields[key]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析请求数据（body）</span></span><br><span class="line">    <span class="keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="string">@"POST"</span>] &amp;&amp; request.HTTPBody) &#123;</span><br><span class="line">        [requestStrFrmt appendFormat:<span class="string">@"Content-Length: %@\r\n"</span>, @(request.HTTPBody.length)];</span><br><span class="line">        <span class="comment">//请求头以两个CRLF结束</span></span><br><span class="line">        [requestStrFrmt appendString:<span class="string">@"\r\n"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *headerData = [requestStrFrmt dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSMutableData</span> * requestData = [<span class="built_in">NSMutableData</span> dataWithData:headerData];</span><br><span class="line">        [requestData appendData:request.HTTPBody];</span><br><span class="line">        <span class="keyword">return</span> requestData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//请求头以两个CRLF结束</span></span><br><span class="line">        [requestStrFrmt appendString:<span class="string">@"\r\n"</span>];</span><br><span class="line">        <span class="keyword">return</span> [requestStrFrmt dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打印出NSURLRequest报文的文本数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> httpRequestDataWithRequest:request];</span><br><span class="line"><span class="built_in">NSString</span> *requestText = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, requestText);</span><br></pre></td></tr></table></figure>
<p>调用通过上述代码，我们可以得到<code>request</code>报文的文本数据。样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure>
<p><code>response</code>报文可以参考<code>request</code>报文进行分析，为了避免篇幅过长，这里就不再做说明了。</p>
<h3 id="HTTP二进制数据是怎么传输的？"><a href="#HTTP二进制数据是怎么传输的？" class="headerlink" title="HTTP二进制数据是怎么传输的？"></a>HTTP二进制数据是怎么传输的？</h3><p>在各操作系统中，通常会为应用程序提供一组应用程序接口，称为套接字接口（socket API），主要作用就是实行进程间通信和网络编程。大白话就是：套接字是用C语言写成的应用程序开发库，它就是一个库。</p>
<p>套接字中的网络套接字，包含有流式套接字（<code>SOCK-STREAM</code>），它使用<code>TCP</code>协议来实现字节流的传输。通过<code>socket</code>框架，将包含<code>HTTP</code>数据的<code>TCP</code>字节流发送给服务端，服务端通过<code>socket</code>框架拿到包含<code>HTTP</code>数据的<code>TCP</code>字节流后，根据<code>HTTP</code>协议进行解析，解析后又被服务端的HTTP网络框架返回，图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211223163025.png" alt=""><br>上述图示只包含<code>request</code>报文部分，并不包含<code>response</code>报文部分，由于<code>response</code>报文的数据传输和这个并无太大区别，这里就不再做额外说明了。</p>
<h2 id="HTTP协议中Request和Response的解析和逻辑处理"><a href="#HTTP协议中Request和Response的解析和逻辑处理" class="headerlink" title="HTTP协议中Request和Response的解析和逻辑处理"></a><code>HTTP</code>协议中<code>Request</code>和<code>Response</code>的解析和逻辑处理</h2><p>看到这里，我们对HTTP实现应该有了较明朗的了解，但是这其中还是有一些细节需要补充。<br>用过<code>Socket</code>的同学应该都知道，它基于<code>TCP</code>是流式传输，会有<code>半包</code>和<code>粘包</code>问题。一般通过对数据添加<code>Header</code>来解决这些问题。我们知道，<code>HTTP</code>数据包含两部分，分别是<code>Header</code>和<code>Body</code>，<code>HTTP</code>协议定义<code>Header</code>和<code>Body</code>之间包含两个<code>CRLF</code>，一个<code>CRLF</code>是一个回车加一个换行：<code>\r\n</code>。通过这个标识，我们可以从<code>TCP流</code>中把<code>HTTP</code>数据的<code>Header</code>分离出来。然后再解析出<code>Header</code>中的<code>Content-Length</code>字段，它就是<code>body</code>的长度，读取这个长度的内容，就可以把Body解析出来。</p>
<blockquote>
<p>在HTTP/1.1版本，Body的解析还和Transfer-Encoding字段有关，这里就不讨论了。</p>
</blockquote>
<p>当然<code>HTTP协议</code>不只是包含数据解析部分，还有很多逻辑控制部分，它的响应头和和请求头中有很多控制字段，例如缓存相关的<code>Etag</code>，<code>Last-Modified</code>等，和数据压缩相关的<code>Content-Encoding</code>，<code>Accept-Encoding</code>等。系统的网络框架实现了这些控制字段的逻辑，让用户可以开箱即用。</p>
<h2 id="修改HTTP底层实现，完成自有需求。"><a href="#修改HTTP底层实现，完成自有需求。" class="headerlink" title="修改HTTP底层实现，完成自有需求。"></a>修改<code>HTTP</code>底层实现，完成自有需求。</h2><p>对HTTP上层的修改是很常见的，例如<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNewwork</a>就在HTTP协议之上，添加了自定义缓存逻辑，可以通过<code>cacheTimeInSeconds</code>方法来控制缓存时间。但是对HTTP底层的修改却比较少见，我对这部分的了解，是基于一个特殊需求。</p>
<p>我们都知道手机可以通过<code>WiFi</code>或者<code>蜂窝网络</code>通道来收发数据，一般情况下，同时连接WiFi和蜂窝网络时，路由会让流量只走<code>WiFi</code>通道。但是对于一些WiFi连接工具软件来讲，需要在<code>无法上网的WiFi</code>下进行数据获取，以满足WiFi认证上网的需求，这种情况下<code>蜂窝网络</code>是可以访问网络的，那么可以让HTTP请求不走默认的<code>WiFi</code>通道，通过<code>蜂窝网络</code>来请求数据吗？上层的HTTP网络框架是没有这个功能的，但是底层的<code>socket</code>框架却提供这个功能，它可以让数据无视路由，从特定接口收发。我们完全可以在socket之上，自己实现HTTP协议中<code>request</code>,<code>response</code>的解析和逻辑处理，以达成这个功能的支持。当然对HTTP协议的全量支持是无法承受的开发成本，但是满足自我需求的简单实现还是可以的。我把这功能封装成了一个框架：<a href="https://github.com/xx-li/XXSocketReqeust" target="_blank" rel="noopener">XXSocketReqeust</a>，使用方式如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">_manager = [[XXSocketRequestManager alloc] init];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>]];</span><br><span class="line"><span class="comment">/// 使用XXNetworkInterfaceCellular，这个HTTP请求会无视路由，强制走蜂窝网络通道进行请求。</span></span><br><span class="line">XXSocketDataTask *task = [_manager dataTaskWithRequest:request viaInterface:XXNetworkInterfaceCellular completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error is :%@\n response is %@"</span>, error, response);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"responseObject: %@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">&#125;];</span><br><span class="line">[task start];</span><br></pre></td></tr></table></figure>
<p>感兴趣的同学可以<a href="https://github.com/xx-li/XXSocketReqeust.git" target="_blank" rel="noopener">下载</a>看看。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很多时候网络协议是高冷的，通用的网络协议为了通用和满足各种需求，是非常复杂的。但是我们完全可以针对自己的业务自制协议，或者对协议进行魔改，以满足自我的需求，这其中的难度并没有你想象中的那么高。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/xx-li/XXSocketReqeust" target="_blank" rel="noopener">XXSocketReqeust</a></li>
<li><a href="https://xie.infoq.cn/article/6f7af61d2f01eee65cee5fdcf" target="_blank" rel="noopener">一篇让你彻底了解 http 请求报文和响应报文的结构</a></li>
<li><a href="https://juejin.cn/post/6857287743966281736" target="_blank" rel="noopener">「查缺补漏」巩固你的HTTP知识体系</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7" target="_blank" rel="noopener">网络套接字</a></li>
<li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#TCP/IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">互联网协议套件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32059190" target="_blank" rel="noopener">OSI 7层模型和TCP/IP 4层模型</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>使用swift懒加载需要注意的陷阱</title>
    <url>/2021/12/27/%E4%BD%BF%E7%94%A8swift%E6%87%92%E5%8A%A0%E8%BD%BD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>修改老代码后，发现UITableView会在创建cell时闪退，原因是在调用<code>dequeueReusableCell(withIdentifier:)</code>创建cell时返回了nil。但是检查代码，确认在<code>viewDidLoad</code>注册了这个cell，按道理不应该返回nil。后面分析才发现，由于<code>lazy var</code>不是线程安全的，在碰到viewDidLoad的某个特殊调用时机时就会出现这个问题，而且代码可能在大部分场景正常运行，然后出现一些看起来莫名其妙的bug！</p>
<a id="more"></a>

<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>我把问题代码简化后如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TestTableViewController: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">/// 使用懒加载创建tableView</span></span><br><span class="line">    lazy var tableView: <span class="built_in">UITableView</span> = &#123;</span><br><span class="line">        print(<span class="string">"start init testLabel, isViewLoaded \(self.isViewLoaded)"</span>)</span><br><span class="line">        let tableView = <span class="built_in">UITableView</span>.init(frame: <span class="keyword">self</span>.view.bounds)</span><br><span class="line">        print(<span class="string">"created tableView \(tableView)"</span>)</span><br><span class="line">        tableView.delegate = <span class="keyword">self</span></span><br><span class="line">        tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        print(<span class="meta">#function)</span></span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">        </span><br><span class="line">        print(<span class="meta">#function, <span class="meta-string">"tableView \(tableView) register cell"</span>)</span></span><br><span class="line">        <span class="comment">// 注册cell</span></span><br><span class="line">        tableView.register(<span class="built_in">UITableViewCell</span>.self, forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension TestTableViewController: <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span> &#123;</span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">        let cell = <span class="keyword">self</span>.tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)!</span><br><span class="line">        cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式如下</span></span><br><span class="line">@IBAction func showTestTableViewVC(_ sender: Any) &#123;</span><br><span class="line">    let testVC = TestTableViewController.init()</span><br><span class="line">    <span class="comment">// 引起问题的关键代码</span></span><br><span class="line">    testVC.tableView.isScrollEnabled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">self</span>.navigationController?.pushViewController(testVC, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你已经一眼就看出了问题所在，那么就没有必要看下去了。如果你没有看出来，也不要着急，这个问题确实挺隐蔽的。上述代码运行后，会出现报错：<code>TestTableViewController.swift:29: Fatal error: Unexpectedly found nil while unwrapping an Optional value</code>。那么这个问题是怎么产生的类？</p>
<h2 id="问题是怎么产生的？"><a href="#问题是怎么产生的？" class="headerlink" title="问题是怎么产生的？"></a>问题是怎么产生的？</h2><p>首先我们要清楚两个知识点：</p>
<ol>
<li><code>lazy var</code>懒加载不是线程安全的</li>
<li>在<code>UIViewController</code>中，成员变量<code>view</code>没有初始化及<code>viewDidLoad</code>方法被调用之前，只要调用了成员变量<code>view</code>，就会立即初始化<code>view</code>并调用<code>viewDidLoad</code>方法。 </li>
</ol>
<blockquote>
<p>第二点有点隐蔽，例如在<code>viewDidLoad</code>方法调用之前调用<code>self.view.bounds</code>就会触发。</p>
</blockquote>
<p>上述代码运行后的Log输出如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211227172817.png" alt=""></p>
<p>在调用<code>let testVC = TestTableViewController.init()</code>初始化控制器后，我们立即调用了<code>testVC.tableView.isScrollEnabled = false</code>，这个时候会进入<code>tableView</code>的懒加载部分：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">lazy var tableView: <span class="built_in">UITableView</span> = &#123;</span><br><span class="line">    print(<span class="string">"start init testLabel, isViewLoaded \(self.isViewLoaded)"</span>)</span><br><span class="line">    <span class="comment">// 注意，这里调用了self.view，会导致`viewDidLoad`被提前调用！</span></span><br><span class="line">    let tableView = <span class="built_in">UITableView</span>.init(frame: <span class="keyword">self</span>.view.bounds)</span><br><span class="line">    print(<span class="string">"created tableView \(tableView)"</span>)</span><br><span class="line">    tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">return</span> tableView</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    print(<span class="meta">#function)</span></span><br><span class="line">    view.addSubview(tableView)</span><br><span class="line">    </span><br><span class="line">    print(<span class="meta">#function, <span class="meta-string">"tableView \(tableView) register cell"</span>)</span></span><br><span class="line">    <span class="comment">// 注册cell</span></span><br><span class="line">    tableView.register(<span class="built_in">UITableViewCell</span>.self, forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先定义这次要创建的<code>tableView</code>为<code>A</code>。这部分懒加载代码由于错误的调用了<code>self.view</code>，导致<code>self.view</code>初始化和<code>viewDidLoad</code>方法被提前调用，此时成员变量<code>tableView</code>还没有被初始化完成，而<code>viewDidLoad</code>方法中又调用了<code>tableView</code>，由于<code>lazy</code>不是线程安全的，所以又递归进入了上述初始化<code>tableView</code>的逻辑，这个时候<code>self.view</code>已经被创建了，所以会初始化完成，我们定义这次创建的<code>tableView</code>为<code>B</code>，这个时候控制器持有的<code>tableView</code>对象是<code>B</code>，它会在<code>viewDidLoad</code>方法的这次调用中注册cell。<br>上述逻辑跑完后，<code>A</code>才紧随其后完成创建，并替换<code>B</code>成为控制器的新成员变量，而且由于<code>viewDidLoad</code>已经被调用过了，在<code>self.navigationController?.pushViewController(testVC, animated: true)</code>方法调用后，<code>viewDidLoad</code>不会再被调用，所以<code>A</code>是没有注册cell的。</p>
<p>运行到这时，控制器持有了<code>A</code>，而控制器的<code>view</code>通过<code>addSubview</code>持有了它的子视图<code>B</code>，图示如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20211227194208.png" alt=""><br>其中<code>B</code>对象在<code>viewDidLoad</code>方法中注册了<code>cell</code>，而<code>A</code>对象并没有注册，所以在代理方法中创建<code>cell</code>时返回了<code>nil</code>，导致了<code>crash</code>。如果对这部分不理解，可以多看几遍代码和日志，理顺下调用流程。</p>
<p>crash位置代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="comment">// self.tableView是对象A，它并没有注册cell。</span></span><br><span class="line">    <span class="comment">// 代理方法传递过来的tableView是对象B，它注册了cell，直接使用它则不会crash</span></span><br><span class="line">    let cell = <span class="keyword">self</span>.tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>)!</span><br><span class="line">    cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个问题的隐蔽性在于存在两个<code>UITableView</code>对象，如果在代理方法中不使用<code>self.tableView</code>而是使用代理方法传递过来的<code>tableView</code>，那么程序不会crash，而且显示正常。而后续会不会出现奇奇怪怪的问题，就完全看你的运气了。</p>
<p>当然这个问题埋的隐蔽性并不止于此，当外部不调用<code>tableView</code>属性时，例如不像样例代码那样调用<code>testVC.tableView.isScrollEnabled = false</code>，那么在<code>viewDidLoad</code>方法中会正常执行<code>tableView</code>的初始化，一切都是正常的。但是一旦哪位同事在外部调用了一次，那么潘多拉魔盒就打开了～</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决这种问题，需要我们有良好的编码规范。首先，要强化<code>lazy</code>不是线程安全的概念，在懒加载中只做这个变量初始化的事情，尽量避免其它变量及逻辑的混入。在<code>UIViewController</code>及其子类的懒加载逻辑中，避免对<code>view</code>的调用。我看很多人喜欢在懒加载逻辑中调用<code>view.addSubView()</code>或<code>view.bounds</code>，这是不太对的，因为在<code>isViewLoaded</code>为<code>false</code>的情况下，对<code>view</code>的调用就代表着<code>viewDidLoad</code>方法的提前调用，这让程序的逻辑变得有些混乱，除非你能保证在<code>viewDidLoad</code>之后调用这个属性。</p>
<p>其次，在编码过程中，要注意权限的控制，设计合适的接口，这样对使用者更友好，也能规避很多异常场景，当然这对开发者的要求较高，需要平常多加修炼和积累了。</p>
<h2 id="关于OC"><a href="#关于OC" class="headerlink" title="关于OC"></a>关于OC</h2><p>另外需要注意的是，<code>OC</code>的懒加载也有同样的问题。但是<code>OC</code>可以优化写法避免出现这个问题，而<code>Swift</code>不行。</p>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UITableView *)tableView &#123;</span><br><span class="line">    if (!_tableView) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一种用法：这样调用会出现异常</span><br><span class="line">&#x2F;&#x2F;        _tableView &#x3D; [[UITableView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">        &#x2F;&#x2F; 第二种用法：这样是正常的</span><br><span class="line">        _tableView &#x3D; [[UITableView alloc] init];</span><br><span class="line">        _tableView.frame &#x3D; self.view.bounds;</span><br><span class="line"></span><br><span class="line">        _tableView.delegate &#x3D; self;</span><br><span class="line">        _tableView.dataSource &#x3D; self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _tableView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的第二种用法不会出现问题，是由于在<code>_tableView.frame = self.view.bounds;</code>这行代码才引入的<code>self.view</code>，此时<code>_tableView</code><br>已经有值，后续代码不会执行。</p>
<p>虽然没有问题，但是不推荐这样使用，因为它还是引起了<code>viewDidLoad</code>的提前执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/29761706/swift-is-lazy-var-thread-safe" target="_blank" rel="noopener">Swift - is lazy var thread-safe?</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结 - 时间一天天的流逝，最终留下了什么？</title>
    <url>/2022/01/01/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E6%97%B6%E9%97%B4%E4%B8%80%E5%A4%A9%E5%A4%A9%E7%9A%84%E6%B5%81%E9%80%9D%EF%BC%8C%E6%9C%80%E7%BB%88%E7%95%99%E4%B8%8B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>往年断断续续的有做过年终总结和年终计划，大多是象征性的做一做，好像是一个仪式。随着年龄的增大，责任越来越多，压力也越来越大。这让我开始思考：时间一天天的流逝，最终留下了什么？<br>很多人被工作与生活裹携着前进，一直在低头赶路，却忘记了抬头看看方向和欣赏一下周围的风景，等到某一天才发现，身边已满是荆棘，寸步难行。而这个年终总结，就是我”抬头看路”的一部分。我会从个人成长，家庭，工作，业余生活来进行总结。</p>
<a id="more"></a>

<h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p>我自认为是一个爱学习的人，从事互联网行业以来，一直都是从事iOS的相关工作，除了iOS方向，我系统学习过Android，Python，React，JS，Go，Flutter等，浅尝即止的就不说了，每一项都投入了较多时间，在这些技术的学习高峰，估计能达到中级开发者的开发效率吧。但是随着时间的流逝，其中大部分都忘的差不多了，如果面试官问我相关问题，我大概率是答不出来的，重新去做相关事情也需要去温习才能想起，很多人可能也有类似的感觉。<br>所以从今年开始，对这方面的思考越来越多。首先，每个人的精力是有限的，要定好自己的技术方向，在基本盘稳固，有余力的情况下再做其它方向的拓展。其次，要更高效及有效的学习。</p>
<h3 id="定技术方向"><a href="#定技术方向" class="headerlink" title="定技术方向"></a>定技术方向</h3><p>今年年初确定技术平台为iOS &amp; Flutter，技术目标为成为大前端和架构方面的专家。目标很宏伟，需要一步步实施，在iOS方面，主要做了这些：</p>
<ul>
<li>完成李明杰老师《iOS底层原理班》视频课程的学习，并全程做笔记和总结。</li>
<li>完成李明杰老师《Swift编程从入门到精通》视频课程的学习，并全程做笔记和总结。</li>
</ul>
<p>李明杰老师的视频质量很高，让我接触到很多新东西（毕竟都搞汇编去分析了），但是很多都是底层和比较冷门的内容，现在已经忘了很多了，通过视频学习是非常耗时的，可能对初学者或求职者性价比会高一些吧。以后对熟悉领域的巩固和深入，会优先选择文字而不是视频～</p>
<p>在Flutter方面，主要做了这些：</p>
<ul>
<li>完成了对个人项目《购房计算器》的改版</li>
<li>完成了一个Flutter外包项目并上架。</li>
<li>打造了自己的快速开发框架，整了个VSCode插件生成模版代码，对开发效率提高挺多。</li>
</ul>
<p>现在对于Flutter的学习都是集中在应用层面，经过今年的学习和实践，现在已经可以用Flutter完成复杂的UI和需求，基本上原生能做的都能用Fluter做好，效率也更高。Flutter的劣势是做极致体验时干不过原生，原生项目嵌入Flutter的成本较高，对直播等这类场景不友好等，明年会把更多精力放入Flutter底层原理及它与原生交互部分，并做高质量的博文输出。</p>
<h3 id="更高效及有效的学习"><a href="#更高效及有效的学习" class="headerlink" title="更高效及有效的学习"></a>更高效及有效的学习</h3><p>今年的学习过程中，自己有犯一些错误，第一个是想尽快把学习在预定时间内搞完，牺牲掉了学习的质量。第二个是对自己自视太高，制定了不符实际的计划，最终导致计划烂在一次次的失败之中。在后半段，对学习思路进行了调整，改为以输出倒逼输入的模式，通过输出高质量的博文来进行学习。今年总共写了5篇博文，有3篇是12月份写的，其中一篇被老司机技术周报收纳并上了掘金社区的周榜，这对我是莫大的激励。还有就是尽量选择工作内容强相关的内容进行学习，会在工作中得到一次又一次的巩固。</p>
<h2 id="关于家庭"><a href="#关于家庭" class="headerlink" title="关于家庭"></a>关于家庭</h2><p>由于结婚很早，我现在是两个小孩的父亲，大的已经读小学了，是非常活泼好动的性格，在学校的表现和在家做作业的情况都让我和老婆苦恼。上半年尝试过各种办法无效后，我想出一个方案，规定每天在学校里不能扣分并在晚上八点半前完成全部作业，违反则罚站20分钟马步，如果连续违反则每次附加10分钟。为了避免小孩的逆反心理，我一起罚站并监督罚站纪律（子不教父之过），老婆检查并判定作业是否完成，执行半个月后取得了很好的成效，就是我的胳膊和腿差点废掉了。下半年，儿子班级换了班主任，完全不一样的管理风格，严格和认真程度高了不止一个量级，加上中间一段时间的松懈，儿子又暴露出来了很多问题，所以最近两个月又和老婆一起严抓习惯和学业，事情又逐步在往好的方向上发展。<br>受益于今年没有什么加班，个人也很少去应酬，给家庭的时间较多，但是感觉自己做的还是不够好，带小孩是一场修行，期望明年在小孩问题上要更多的关注，更多的思考，更多的沟通，更认真的执行，给家人做更好的榜样。</p>
<h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>由于公司的经营状况不佳以及裁员，上半年没什么工作任务，下半年公司则处在比较动荡的状态之中。这种状态下，业务需求不多，没有什么加班。中途试图在公司推进Flutter，我把公司现有App用Flutter重新进行了架构，完成了大部分基础组件的搭建，以及上层20%左右的业务内容。后面准备向同事推广，推进公司App的Flutter化，但是架不住裁员后都去复习面试题了。我想，年后，我也该去找工作了～</p>
<h2 id="业余生活"><a href="#业余生活" class="headerlink" title="业余生活"></a>业余生活</h2><p>我是一个路亚爱好者，由于工作和带小孩，没什么时间，经常在晚上小孩睡着后去河边甩几竿，或者周末早上三四点起床，钓到八九点回来，然后送小孩去上兴趣班。玩归玩，但是不能影响正事。今年钓得最爽的一次是在沩水2个小时钓了50条鳜鱼。在资江也钓了很多斑鳜，资江是鹅卵石河床，环境和风景一流，就算钓不到鱼也是一种美的享受，在青山与溪流之中，感受着那微风拂面和阳光，那是我”突然的自我”。</p>
<h2 id="展望2022"><a href="#展望2022" class="headerlink" title="展望2022"></a>展望2022</h2><p>在新的一年，我要多做一些高质量的输出。期望家人都能健健康康，不求达到多高的成就，只希望能做更好的自己。最后就日常列一个新年flag吧：</p>
<ul>
<li>最高优先级严格执行家庭管理和教育半年，给两个崽养成良好的行为习惯。</li>
<li>完成15编高质量的博文</li>
<li>做一个个人项目并日活1000+</li>
</ul>
<p>最后，一句话送给自己：永远不要高估自己短期内能做的事，也永远不要低估自己长期能做的事。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS组件化避坑心得</title>
    <url>/2022/01/24/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E9%81%BF%E5%9D%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="为什么要组件化"><a href="#为什么要组件化" class="headerlink" title="为什么要组件化"></a>为什么要组件化</h2><p>组件化一般是把工程分层拆成不同的组件，以达到解耦，模块复用，便于单元测试，编译速度优化等效果，最终目的是为了提高开发质量和效率。当然，组件化是有一定成本的，在组件化之前要考虑清楚当前的项目情况是否适合组件化，收益能否覆盖开发成本。规模较小，模块没太多复用需求的项目，就没必要进行组件化。</p>
<a id="more"></a>

<h2 id="组件化如何分层"><a href="#组件化如何分层" class="headerlink" title="组件化如何分层"></a>组件化如何分层</h2><p>组件化之前，先要对项目进行分层，以我们现在的项目为例：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220124145403.png" alt=""></p>
<p>分层后，一般使用<code>Cocoapods</code>来封装组件，通过<code>路由</code>来进行不同业务模块间的解耦调用。其中<code>系统框架层</code>，<code>公有pod库层</code>是本来就有的。其它层的拆分逻辑分别是：</p>
<ul>
<li>自有公有组件层（<code>公有pod</code>）：这一层的pod都是推到公有仓库，和业务是没有任何耦合的的，就是用于放开源的组件。</li>
<li>私有组件层（<code>私有pod</code>）：这一层的组件都有自己的私有git仓库，通过私有git仓库和私有索引库来进行管理，根据实际业务场景，这一层可能还会再进行分层。一般放一些项目中比较基础和通用的逻辑，例如配置信息管理，埋点管理，数据存储这些。</li>
<li>本地组件层（<code>本地pod</code>）：这一层放业务模块，是app呈现给用户的一个模块的整体封装，例如我的模块，首页模块这类。它的修改会非常频繁，日常的业务开发大部分都是在这一层，所以使用本地pod的方式，不会单独创建git仓库，与主工程共用一个git仓库进行管理。<blockquote>
<p><code>cocoapods</code>只支持在<code>Podfile</code>中以<code>path</code>方式依赖<code>pod</code>，在<code>podspec</code>中是不支持的，所以<code>本地pod</code>最多只能有一层。（你也可以写插件支持多层）</p>
</blockquote>
</li>
</ul>
<p>这样分层后，当有新的业务需求时，我们只需要创建一个本地pod，写入pod依赖，就可以快速的进入业务开发状态，因为没有其它模块的干扰，编译和调试的速度会得到极大的提升，同时也避免了模块之间的耦合。</p>
<h2 id="使用Cocoapods制作不同类型的组件"><a href="#使用Cocoapods制作不同类型的组件" class="headerlink" title="使用Cocoapods制作不同类型的组件"></a>使用<code>Cocoapods</code>制作不同类型的组件</h2><p>通过上述内容，可以知道有三种类型的组件：<code>公有pod</code>，<code>私有pod</code>,<code>本地pod</code>。不管什么类型，都建议使用<code>pod lib create PodName</code>命令来创建组件，在它生成的组件模版基础上，可以很方便的进行开发。</p>
<h3 id="公有Pod"><a href="#公有Pod" class="headerlink" title="公有Pod"></a>公有Pod</h3><p>公有pod是面向所有开发者的，需要尽量保证它的可用性和稳定性。如何发布公有pod这里不做说明，可以参考官方文档：<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk.html" target="_blank" rel="noopener">Getting setup with Trunk</a>。一些公司提供的商用公有pod，连pod验证命令<code>pod lib lint</code>都无法通过，这个是不应该的，最容易出现的问题就是编译错误，因为它会校验各个场景，而很多pod开发者却只保证自己的pod在常见场景可用。常见的报错有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错1: </span><br><span class="line">ld: symbol(s) not found for architecture i386</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错2:</span><br><span class="line">building for iOS Simulator, but linking in object file built for iOS, file &#39;you path&#39; for architecture arm64</span><br></pre></td></tr></table></figure>
<p>这里的<code>i386</code>是<code>32位模拟器</code>的架构，<code>arm64</code>是<code>m1机型</code>上的模拟器架构，出现这种问题一般是pod中引入了<code>lib</code>或者<code>framework</code>静态库，而这些库不支持这些架构。<br>现在都<code>2202</code>年了，微信的最低支持版本都到了<code>12.0</code>，所以请大胆将pod库的<code>deployment_target</code>参数设置为<code>12.0</code>，这样就不会进行<code>i386</code>架构的验证。 而对<code>arm64</code>模拟器架构的支持，最好是将静态库重新打包成<code>.xcframework</code>格式并支持<code>arm64</code>模拟器架构，不然会导致<code>m1</code>设备的使用者只能以<code>Rosetta</code>模式在模拟器上运行项目。具体可以看我之前写的博文<a href="https://juejin.cn/post/7037037120158269448" target="_blank" rel="noopener">M1设备的Xcode编译问题深究
</a>，如这些静态库是第三方提供的，无法重新打包支持<code>arm64</code>模拟器架构，则可以进行如下设置避免报错：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为依赖的静态库不支持模拟器arm64架构，设置当前这个pod不支持arm64， 以避免pod lib lint无法通过</span></span><br><span class="line">s.pod_target_xcconfig = &#123; <span class="string">'EXCLUDED_ARCHS[sdk=iphonesimulator*]'</span> =&gt; <span class="string">'arm64'</span> &#125;</span><br><span class="line"><span class="comment"># 单纯设置pod_target_xcconfig只是设置当前这个pod不支持arm64， 这里把这些pod的上层设置为不支持arm64，兼容这种问题</span></span><br><span class="line">s.user_target_xcconfig = &#123; <span class="string">'EXCLUDED_ARCHS[sdk=iphonesimulator*]'</span> =&gt; <span class="string">'arm64'</span> &#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>公有pod</code>，负责任的做法是没有任何错误和警告后再进行发布，如果由于各种客观原因，实在无法去除警告，可以加入<code>--allow-warnings</code>参数来推送：<code>pod trunk push [NAME.podspec] --allow-warnings</code>。如果添加<code>--skip-import-validation</code>参数来逃避验证，则显得有些不负责任了。</p>
<p>另外，在<code>CocoaPods</code>的<code>1.8</code>版本，将默认的<code>spec repo</code>设为了<code>CDN源</code>，以提高pod的速度。刚发布的<code>公有pod</code>版本，可能要几个小时后才能被同步到<code>CDN源</code>，导致刚发布时调用<code>pod install --repo-update</code>没法找到新发布的pod库，这时可以通过指定源来解决这个问题，样例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;你的公有pod&#39;, :source &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs&#39;</span><br></pre></td></tr></table></figure>
<p>当然，<code>CDN源</code>同步后要记得改回。</p>
<h3 id="私有Pod"><a href="#私有Pod" class="headerlink" title="私有Pod"></a>私有Pod</h3><p><code>私有pod</code>一般通过<code>私有repo</code>来进行管理，这样才方便做版本管理和使用缓存。<code>私有repo</code>创建命令是<code>pod repo add REPO_NAME SOURCE_URL</code>，其中<code>SOURCE_URL</code>就是<code>私有repo</code>的git地址。创建<code>私有repo</code>后，通过<code>pod repo push REPO_NAME SPEC_NAME.podspec</code>命令来发布<code>私有pod</code>到<code>私有repo</code>。需要注意的是<code>私有pod</code>和<code>公有pod</code>的发布命令并不一样，分别是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 公有pod发布命令</span></span><br><span class="line">pod trunk push SPEC_NAME.podspec</span><br><span class="line"><span class="comment"># 私有pod发布命令</span></span><br><span class="line">pod repo push REPO_NAME SPEC_NAME.podspec</span><br></pre></td></tr></table></figure>
<p>发布后，需要在<code>Podfile</code>中加入<code>私有repo源</code>，才能找到私有pod并安装成功。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --- Podfile文件 --</span></span><br><span class="line"><span class="comment"># 指定私有source</span></span><br><span class="line">source <span class="string">'https://youhost.com/YouPrivateRepo.git'</span></span><br><span class="line"><span class="comment"># 指定公有source，</span></span><br><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br></pre></td></tr></table></figure>
<p>这些固定流程不做过多说明，具体内容可以查看官方文档:<a href="https://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="noopener">Private Pods</a></p>
<p>如果私有pod中依赖了非公有源的pod，在<code>pod lib lint</code>时会出现这类报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for &#96;AlicloudHTTPDNS&#96; depended upon by &#96;DTHttpDns&#96;</span><br></pre></td></tr></table></figure>
<p>这时根据提示调用<code>pod repo update</code>后也是无效的，这类问题可以通过指定<code>sources</code>来解决，以如上报错为例，它依赖的<code>AlicloudHTTPDNS</code>是阿里的源：<code>https://github.com/aliyun/aliyun-specs.git</code>，设置<code>sources</code>后则可以验证通过:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以通过逗号分隔，添加多个不同的source。(--sources='a_source,b_source')</span></span><br><span class="line">pod lib lint DTHttpDns.podspec --allow-warnings --sources=<span class="string">'https://github.com/aliyun/aliyun-specs.git'</span></span><br></pre></td></tr></table></figure>
<p><code>pod repo push</code>也可能会出现上述报错，但是它的逻辑稍有不同，它会从你本地的repo列表中去查找pod依赖，找到则不会报错。而<code>pod lib lint</code>在没有指定<code>sources</code>时，只会从默认的源去找。</p>
<h3 id="本地Pod"><a href="#本地Pod" class="headerlink" title="本地Pod"></a>本地Pod</h3><p><code>本地pod</code>与主工程一起被同一个git仓库管理，不需要单独进行版本管理，也不需要<code>push</code>，而是在<code>Podfile</code>中直接以<code>path</code>的方式进行引入，样例如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --- Podfile文件中 --</span></span><br><span class="line">pod <span class="string">'你的本地pod'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../本地pod路径/你的本地pod目录名'</span></span><br></pre></td></tr></table></figure>

<h2 id="Pod组件中使用资源的坑"><a href="#Pod组件中使用资源的坑" class="headerlink" title="Pod组件中使用资源的坑"></a>Pod组件中使用资源的坑</h2><p>在pod中，经常会出现需要使用图片，xib，json文件等资源的场景，建议使用<code>resource_bundles</code>来配置使用这些资源，以名为<code>DTVideo</code>的pod库为例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- DTVideo.podspec 文件中--</span></span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">      <span class="string">'DTVideoAssets'</span> =&gt; [<span class="string">'DTVideo/&#123;Assets,Classes&#125;/**/*.&#123;xib,xcassets&#125;'</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这样配置后，<code>cocoapods</code>会自动把这些资源打包成一个名叫<code>DTVideoAssets</code>的<code>bundle</code>文件，在pod中使用这些资源的方式会发生一些改变。假如这个pod中有一个类<code>VideoPlayListCell.swift</code>，那么我们可以创建辅助方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DTVideoCommon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">assetsBundle</span><span class="params">()</span></span> -&gt; <span class="type">Bundle?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> myBundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">VideoPlayListCell</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> path = myBundle.path(forResource: <span class="string">"DTVideoAssets"</span>, ofType: <span class="string">"bundle"</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> path = path <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> assetsBundle = <span class="type">Bundle</span>.<span class="keyword">init</span>(path: path)</span><br><span class="line">        <span class="keyword">return</span> assetsBundle</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">imageWith</span><span class="params">(named name: String)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> assetsBundle = assetsBundle()</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>.<span class="keyword">init</span>(named: name, <span class="keyword">in</span>: assetsBundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载图片时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">DTVideoCommon</span>.imageWith(named: <span class="string">"video_play_max_nor"</span>)</span><br><span class="line">imageView.image = image</span><br></pre></td></tr></table></figure>
<p>使用xib时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>.<span class="keyword">init</span>(nibName: cellIdentifier, bundle: <span class="type">DTVideoCommon</span>.assetsBundle())</span><br><span class="line">tableView.register(cellNib, forCellReuseIdentifier: cellIdentifier)</span><br></pre></td></tr></table></figure>

<h3 id="xib文件中设置Module名的坑"><a href="#xib文件中设置Module名的坑" class="headerlink" title="xib文件中设置Module名的坑"></a>xib文件中设置Module名的坑</h3><p><code>xib</code>文件中有<code>Module</code>设置，如果是在工程中创建的，那么它默认是勾选上<code>inherit Module From Target</code>，当将这个文件移动到pod中时，它的<code>Module</code>名就被设置成了默认名，即<code>bundle</code>名，这样会导致创建这个cell的时候报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Terminating app due to uncaught exception &#39;NSUnknownKeyException&#39;, reason: &#39;[&lt;UITableViewCell 0x7fd3eba23d60&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key you_error_key.&#39;</span><br></pre></td></tr></table></figure>
<p>错误设置图示如下：</p>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220118145801.png" alt=""></p>
<p>正确的设置是不要勾选<code>inherit Module From Target</code>，并且在Module栏输入正确的<code>Module名</code>。</p>
<p>当然你也可以空着，不输入<code>Module</code>名，但是这样需要修改<code>VideoPlayListCell</code>的类名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span>(<span class="type">VideoPlayListCell</span>) <span class="comment">// Module栏空着情况下，必须添加这行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayListCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用<code>@objc(VideoPlayListCell)</code>修改类名，那么会出现上面一样的报错，所以还是建议输入正确的<code>Module名</code></p>
<h2 id="关于module"><a href="#关于module" class="headerlink" title="关于module"></a>关于module</h2><p><code>cocoapods</code>现在默认会开启pod库的<code>module</code>选项，所以没有必要在<code>podspec</code>中配置：<code>&#39;DEFINES_MODULE&#39; =&gt; &#39;YES&#39;</code>，<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220124172708.png" alt=""><br><code>module</code>对头文件的引入和混编做了很大的优化，在引入其它组件的时候，建议以<code>@import</code>或者<code>#import &lt;A/A.h&gt;</code>的方式引入，其中<code>#import &lt;A/A.h&gt;</code>会最终转换为<code>@import</code>的方式。</p>
<blockquote>
<p>现在使用pod库，以<code>#import &quot;XXX&quot;</code>和<code>#import &lt;XXX&gt;</code>的方式引入，Xcode都没有补全提示了，只有<code>@import</code>方式有。</p>
</blockquote>
<p>如果想对<code>module</code>做更多的了解，建议看这篇博文：<a href="https://tech.meituan.com/2021/02/25/swift-objective-c.html" target="_blank" rel="noopener">从预编译的角度理解Swift与Objective-C及混编机制</a>，这篇博文写的非常好，内容也很长，阅读完需要一两个小时。后面的内容很多是对篇博文的部分总结和回顾，再次感谢这篇博文的作者。</p>
<h2 id="pod库中swift与Objective-C的混编问题"><a href="#pod库中swift与Objective-C的混编问题" class="headerlink" title="pod库中swift与Objective-C的混编问题"></a>pod库中swift与Objective-C的混编问题</h2><p>当<code>Swift</code>和<code>Objective-C</code>文件同时在一个<code>App</code>或者<code>Unit Test</code>类型的<code>Target</code>中，不同类型文件的<code>API</code>寻找机制如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220124174306.png" alt=""></p>
<blockquote>
<p>这个和pod没有关联，是主工程的混编用法。</p>
</blockquote>
<p>当<code>Swift</code>和<code>Objective-C</code>文件在不同<code>Target</code>中，例如不同<code>Framework</code>中，不同类型文件的<code>API</code>寻找机制如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220124173953.png" alt=""></p>
<blockquote>
<p>图示的<code>module.modulemap</code>指的是需要<code>import</code>不同<code>framework</code>的<code>module</code>，例如<code>A</code>pod中的<code>swift</code>文件需要引用<code>B</code>pod中的<code>.h/.m</code>文件，需要：<code>import B</code></p>
</blockquote>
<p>当<code>Swift</code>和<code>Objective-C</code>文件同时在一个<code>Target</code>中，例如同一<code>Framework</code>中，不同类型文件的<code>API</code>寻找机制如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220124174342.png" alt=""></p>
<p>这代表在同一个pod库中，不需要做任何处理，<code>swift</code>就可以直接调用库中的<code>oc</code>代码。但是<code>oc</code>想调用库中的<code>swift</code>代码，则需要导入固定格式的头文件，如：<code>#import &lt;DTVideo/DTVideo-Swift.h&gt;</code>，其中<code>DTVideo</code>就是这个pod库的<code>module</code>名。另外还有两个点需要注意：</p>
<ul>
<li><code>swift</code>中必须是声明为<code>public</code>或者<code>open</code>权限的才能被<strong>同一个</strong><code>pod</code>中的<code>oc</code>代码或者外部调用。</li>
<li>如果想在pod外部创建它某个<code>swift类</code>的<code>子类</code>，那么这个<code>swift类</code>必须声明为<code>open</code>权限</li>
</ul>
<h2 id="pod中swift使用struct的坑"><a href="#pod中swift使用struct的坑" class="headerlink" title="pod中swift使用struct的坑"></a>pod中swift使用struct的坑</h2><p><code>struct</code>默认生成的初始化方法是<code>internal</code>级别的，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">TestStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">TestStruct</span>(key: <span class="string">"aaaa"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以在pod里面调用，但是在pod外部被调用则会报错：<code>&#39;TestStruct&#39; initializer is inaccessible due to &#39;internal&#39; protection level</code>。<br>需要手动创建它的<code>public init</code>方法。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">TestStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 需要手动添加public init方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(key: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key= key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置pod库的Public-Headers和Privete-Headers"><a href="#设置pod库的Public-Headers和Privete-Headers" class="headerlink" title="设置pod库的Public Headers和Privete Headers"></a>设置pod库的<code>Public Headers</code>和<code>Privete Headers</code></h2><h3 id="构建产物为Framework的情况下"><a href="#构建产物为Framework的情况下" class="headerlink" title="构建产物为Framework的情况下"></a>构建产物为<code>Framework</code>的情况下</h3><ul>
<li>根据<code>podspec</code>里的<code>public_header_files</code>字段的内容，将相应头文件设置为<code>Public</code>类型，并放在<code>Headers</code>中。</li>
<li>根据<code>podspec</code>里的<code>private_header_files</code>字段的内容，将相应文件设置为<code>Private</code>类型，并放在<code>PrivateHeader</code>中。</li>
<li>将其余未描述的头文件设置为<code>Project</code>类型，且不放入最终的产物中。</li>
</ul>
<p>如果<code>podspec</code>里未标注<code>Public</code>和<code>Private</code>的时候，会将所有文件设置为<code>Public</code>类型，并放在<code>Header</code>中。</p>
<h3 id="构建产物为Static-Library的情况下"><a href="#构建产物为Static-Library的情况下" class="headerlink" title="构建产物为Static Library的情况下"></a>构建产物为<code>Static Library</code>的情况下</h3><p>不论<code>podspec</code>里如何设置<code>public_header_files</code>和<code>private_header_files</code>，相应的头文件都会被设置为<code>Project</code>类型。</p>
<ul>
<li>在<code>Pods/Headers/Public</code>中会保存所有被声明为<code>public_header_files</code>的头文件。</li>
<li>在<code>Pods/Headers/Private</code>中会保存所有头文件，不论是<code>public_header_files</code>或者 <code>private_header_files</code>描述到，还是那些未被描述的，这个目录下是当前组件的所有头文件全集。</li>
</ul>
<h2 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h2><p>现在常见的路由方案有：<code>URLRoute</code>，<code>Protocol-Class</code>，<code>Target-Action</code>等。个人偏爱<code>URLRoute</code>，主要有两方面的原因：</p>
<ul>
<li>第一是通用。<code>URLRoute</code>可以多端统一，例如运营配置一条推送，点击打开某个页面，对于运营方来说，统一配置固定规则的URL就可以了，每个端都一致。H5页面要打开某个Native页面，或者外部唤起，也是统一用<code>URLRoute</code>就可以了，不需要区分平台做不同操作。</li>
<li>第二是没法避开。例如<code>URL Scheme</code>，<code>Universal Links</code>这类，还是需要使用到<code>URL</code>。</li>
</ul>
<p>而<code>Protocol-Class</code>，<code>Target-Action</code>这些方案，没法避免硬编码，只能说是<code>URLRoute</code>的一种补充。<code>URLRoute</code>本质上就是约定一个各端通用的协议，在各端内部对协议进行正确的解析和逻辑处理。封装好了之后，不管是外部还是内部的调用者，不需要关心任何细节和区分平台，只需要传入协议就可以。综上所属，推荐使用<code>URLRoute</code>。</p>
<h2 id="关于脚本"><a href="#关于脚本" class="headerlink" title="关于脚本"></a>关于脚本</h2><p>组件化后会多出很多重复简单的操作，例如一个<code>私有pod</code>的新版本发布，需要的流程有：git commit -&gt; 打tag -&gt; pod验证 -&gt; pod发布，这些都是可以通过编写脚本简化操作的，建议在组件化过程中多做这方面的工作。</p>
<h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>现在市面上的组件化方案很多，各大公司各种高大上的落地方案。我在小公司的业务间隙，抽时间写的这篇简单的避坑心得，是对自己实践的整理和归纳，希望能帮到你。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://tech.meituan.com/2021/02/25/swift-objective-c.html" target="_blank" rel="noopener">从预编译的角度理解Swift与Objective-C及混编机制</a></li>
<li><a href="https://juejin.cn/post/6844903582739726350#heading-23" target="_blank" rel="noopener">iOS 组件化 —— 路由设计思路分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中Pod库资源引用探究</title>
    <url>/2022/02/11/iOS%E4%B8%ADPod%E5%BA%93%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>cocoapods</code>中<code>Pod</code>引用资源的方式有多种，不同的方式对资源的使用还是有区别的，但也有一定的规律，这里我用一个样例工程来进行说明，样例工程名叫：<code>AssetsDemo</code>，使用<code>pod lib create AssetsDemo</code>命令创建，目录结构如图：</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211100525.png" alt=""><br>这个<code>pod</code>很简单，<code>Classes</code>目录只有一个<code>cell</code>的<code>swift</code>和<code>xib</code>文件，<code>Assets</code>目录有一些图片资源，其中的<code>TestTableViewCell.xib</code>使用了这张<code>test</code>图片。目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── Assets</span><br><span class="line">│   ├── Images.xcassets</span><br><span class="line">│   │   ├── Contents.json</span><br><span class="line">│   │   └── test.imageset</span><br><span class="line">│   │       ├── Contents.json</span><br><span class="line">│   │       ├── test@2x.png</span><br><span class="line">│   │       └── test@3x.png</span><br><span class="line">│   ├── test1@2x.png</span><br><span class="line">│   └── test1@3x.png</span><br><span class="line">└── Classes</span><br><span class="line">    ├── TestTableViewCell.swift</span><br><span class="line">    └── TestTableViewCell.xib</span><br></pre></td></tr></table></figure>

<p>前期工作已经准备完毕，下面说下<code>xib</code>和<code>图片</code>资源不同使用方式下的区别:</p>
<h2 id="将xib放入source-files，图片放入resource-bundles"><a href="#将xib放入source-files，图片放入resource-bundles" class="headerlink" title="将xib放入source_files，图片放入resource_bundles"></a>将<code>xib</code>放入<code>source_files</code>，图片放入<code>resource_bundles</code></h2><p>在<code>podspec</code>的写法如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.source_files = <span class="string">'AssetsDemo/Classes/**/*'</span></span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    <span class="string">'AssetsDemo'</span> =&gt; [<span class="string">'AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png&#125;'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后会生成这样的<code>framework</code>：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211130630.png" alt=""><br>我们可以看到，<code>xib</code>后缀会变成<code>nib</code>，并被放入<code>framework</code>中，而图片资源被放入了<code>AssetsDemo.bundle</code>中。</p>
<p>这样的配置，显然在常规情况下，<code>xib</code>是没法找到图片并显示的。但是有一种有缺陷的用法可以勉强解决这个问题，那就是直接把png图片打包到<code>AssetsDemo.bundle</code>中，然后在<code>xib</code>中将图片名改为<code>AssetsDemo.bundle/图片名</code>。这样做会导致<code>xib</code>编辑时无法正确的显示图片，也没法使用<code>xcassets</code>目录来存储图片，并且会导致一些系统优化无法生效。不推荐这样使用</p>
<h2 id="将xib和图片都放入resources"><a href="#将xib和图片都放入resources" class="headerlink" title="将xib和图片都放入resources"></a>将<code>xib</code>和<code>图片</code>都放入<code>resources</code></h2><p>在<code>podspec</code>的写法如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.source_files = <span class="string">'AssetsDemo/Classes/**/*.swift'</span></span><br><span class="line">s.resources = <span class="string">'AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png,xib&#125;'</span></span><br></pre></td></tr></table></figure>
<p>网上有说法使用<code>resources</code>来指定资源，被指定的资源只会简单的被 copy到目标工程中（主工程），资源的使用会简化，但是会与主工程同名资源文件产生冲突。但是在<code>Xcode13</code>和<code>pod 1.11.2</code>版本下，实测不是这样的。官方的文档也不是这样说的<a href="https://guides.cocoapods.org/syntax/podspec.html#resources" target="_blank" rel="noopener">Podspec Syntax Reference v1.11.2</a>，它是分静态库和动态库场景，静态库才有这类问题。</p>
<p>上述配置运行后会生成这样的<code>framework</code>结构：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211111746.png" alt=""></p>
<p>从上图可以看到，资源被直接放入了所在的<code>framework</code>，另外查看主工程的包文件，是没有这些资源的。综上所述，可以得出结论，动态库中，<code>resources</code>指定的资源，会被直接<code>copy</code>到<code>framework</code>，不会与主工程资源文件冲突。</p>
<p>另外，由于xib文件<code>TestTableViewCell.nib</code>和<code>Assets.car</code>在同一个目录下，<code>xib</code>可以直接从<code>Assets.car</code>中找到图片资源并正确展示</p>
<blockquote>
<ol>
<li>在主工程中打开这个<code>xib</code>文件，如果主工程中有同名资源，那么编辑时会优先显示主工程的资源，但是实际运行时还是这个<code>pod</code>的资源。</li>
<li>这里<code>xib</code>可以放入<code>source_files</code>和<code>resources</code>，效果是一样的</li>
</ol>
</blockquote>
<h2 id="将xib和图片都放入resource-bundles"><a href="#将xib和图片都放入resource-bundles" class="headerlink" title="将xib和图片都放入resource_bundles"></a>将<code>xib</code>和<code>图片</code>都放入<code>resource_bundles</code></h2><p>在<code>podspec</code>的写法如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.source_files = <span class="string">'AssetsDemo/Classes/**/*.swift'</span></span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    <span class="string">'AssetsDemo'</span> =&gt; [<span class="string">'AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png,xib&#125;'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置运行后会生成这样的<code>framework</code>结构：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211114122.png" alt=""></p>
<p>从上图可以看到，xib文件<code>TestTableViewCell.nib</code>和<code>Assets.car</code>在同一个目录下，<code>xib</code>可以直接从<code>Assets.car</code>中找到图片资源并正确展示。其中，<code>test1</code>图片虽然没有以<code>xcassets</code>格式引入，但是也能直接找到并正确展示。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，我们可以得出一个原则：尽量让<code>xib</code>和<code>xcassets</code>与图片在同一个目录下，这样xib可以直接找到图片并正常展示。</p>
<p>关于<code>resources</code>和<code>resource_bundles</code>，在动态库下，他们最终效果差不多，只是<code>resource_bundles</code>会把资源封装在<code>bundle</code>中，使用的时候会稍微麻烦一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用resources的情况：</span></span><br><span class="line"><span class="keyword">let</span> myBundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">TestTableViewCell</span>.<span class="keyword">self</span>)</span><br><span class="line">tableView.register(<span class="type">UINib</span>.<span class="keyword">init</span>(nibName: <span class="string">"TestTableViewCell"</span>, bundle: myBundle),</span><br><span class="line">                    forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用resource_bundles的情况：</span></span><br><span class="line"><span class="keyword">let</span> myBundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">TestTableViewCell</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> path = myBundle.path(forResource: <span class="string">"AssetsDemo"</span>, ofType: <span class="string">"bundle"</span>)!</span><br><span class="line"><span class="keyword">let</span> assetsBundle = <span class="type">Bundle</span>.<span class="keyword">init</span>(path: path) </span><br><span class="line">tableView.register(<span class="type">UINib</span>.<span class="keyword">init</span>(nibName: <span class="string">"TestTableViewCell"</span>, bundle: assetsBundle),</span><br><span class="line">                    forCellReuseIdentifier: <span class="string">"cell"</span>)</span><br></pre></td></tr></table></figure>
<p>至于静态库，则推荐使用<code>resource_bundles</code>了。综合来看，不管是静态库还是动态库，都推荐使用<code>resource_bundles</code>来引入所有的资源，因为<code>resources</code>方式在静态库和动态库场景，资源的使用方法差异太大，而<code>resource_bundles</code>各场景是一致的。</p>
<p>至于<code>source_files</code>，它只能引入代码和xib文件，不支持引入图片等其它资源。不建议用<code>source_files</code>方式引入<code>xib</code>，如果一定要使用，要注意避免出现<code>xib</code>中图片无法加载的问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://guides.cocoapods.org/syntax/podspec.html#specification" target="_blank" rel="noopener">Podspec Syntax Reference v1.11.2</a></li>
<li><a href="https://juejin.cn/post/6844903559931117581#heading-2" target="_blank" rel="noopener">关于 Pod 库的资源引用 resource_bundles or resources</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片显示原理与优化思路</title>
    <url>/2022/02/15/iOS%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在客户端开发中，图片的下载会占用大量的带宽，图片的加载会消耗大量的性能和内存，正确的使用图片显得尤为重要。本文会对图片显示原理进行介绍，然后提供一些优化思路及第三方图片框架的部分分析。</p>
<span id="more"></span>
<h2 id="图像的种类"><a href="#图像的种类" class="headerlink" title="图像的种类"></a>图像的种类</h2><p>所有的数字图像都可以归类为光栅或矢量两种类型。我们一般称光栅图为<code>位图</code>，它由<code>像素</code>组成，每个像素都有颜色数据，例如RGB值，透明度等。它常见的格式有<code>PNG</code>，<code>JPEG</code>，<code>WEBP</code>等，这些只是一个压缩位图格式，不同的压缩格式压缩率和适用的场景不一样，解码性能也不一样，但是它们有一个共同特点是拉升到大于原始宽高后会变得模糊。</p>
<p>矢量图形是用<code>点</code>，<code>线</code>等基于数学方程的几何图元表示的图像。常见的格式有<code>SVG</code>，<code>AI</code>等，它们的特点是放大到任何大小都不会降低其质量。</p>
<blockquote>
<p>文本是最常见的矢量图形之一</p>
</blockquote>
<p>我们可以把两种类型讲得更通俗一点，<code>位图</code>就是告诉计算机：“这个像素应该是淡黄色的，下一个应该是深紫色的，之后的应该是粉红色的”等等。但是对于<code>矢量图</code>，则是说：”画一个长100，宽100的正方形，给它填充为绿色。”，但是最终它还是会被渲染成<code>位图</code>数据进行展示。不同的是压缩位图根据压缩格式解码得到<code>原始位图</code>数据，<code>矢量图</code>通过计算得到<code>原始位图</code>数据。</p>
<h3 id="位图与矢量图的区别对比"><a href="#位图与矢量图的区别对比" class="headerlink" title="位图与矢量图的区别对比"></a><code>位图</code>与<code>矢量图</code>的区别对比</h3><table>
<thead>
<tr>
<th></th>
<th>位图</th>
<th>矢量图像</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>像素</td>
<td>锚点，线条</td>
</tr>
<tr>
<td>使用场景</td>
<td>照片，复杂的颜色&#x2F;纹理&#x2F;阴影等</td>
<td>字体，地图等</td>
</tr>
<tr>
<td>缩放</td>
<td>受分辨率限制</td>
<td>在保持质量的同时无限拉升</td>
</tr>
<tr>
<td>文件大小</td>
<td>较大，但可以压缩</td>
<td>小</td>
</tr>
<tr>
<td>性能</td>
<td>好，解压缩后根据像素直接渲染</td>
<td>差，需要解析并计算，再生成像素点进行渲染</td>
</tr>
<tr>
<td>常见格式</td>
<td>PNG，JPEG，WEBP等</td>
<td>SVG，AI等</td>
</tr>
</tbody></table>
<p>表格所示的<code>文件大小</code>并不是绝对的，要分场景。例如一张JPEG风景图，用矢量图来做肯定是非常大且不合适的。</p>
<h3 id="不同位图格式适用场景的对比"><a href="#不同位图格式适用场景的对比" class="headerlink" title="不同位图格式适用场景的对比"></a>不同位图格式适用场景的对比</h3><p>日常开发常见的位图格式对比如下：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>gif</td>
<td>文件小，支持动画、透明，兼容好</td>
<td>只支持256种颜色</td>
<td>色彩简单的logo、icon、动图</td>
</tr>
<tr>
<td>jpeg</td>
<td>色彩丰富，可压缩率高</td>
<td>有损压缩，压缩后图片质量下降</td>
<td>色彩丰富的图片，照片等</td>
</tr>
<tr>
<td>png</td>
<td>无损压缩，支持透明，简单图片尺寸小</td>
<td>不支持动画，色彩丰富的图片尺寸大</td>
<td>logo、icon、透明图</td>
</tr>
<tr>
<td>webp</td>
<td>文件小，支持有损和无损压缩，支持动画、透明</td>
<td>浏览器兼容性不好，编解码性能差</td>
<td>支持webp格式等app和webView</td>
</tr>
</tbody></table>
<p>相同视觉体验下，<code>webp</code>一般比<code>JPEG</code>和<code>PNG</code>尺寸更小，但是小icon这类图片，一般<code>PNG</code>尺寸更小。另外<code>webp</code>的解码时间更长，有人测试可以达到<code>png</code>格式的4.4倍，但是一般在后台解码和使用缓存，所以实际运行时<code>webp</code>更长的解码时间并不会造成性能瓶颈。相反，由于<code>webp</code>尺寸更小，下载耗时更少，可以节约带宽和得到更快的显示速度。 具体可以参考：<a href="https://toutiao.io/posts/dynj4k/preview">WebP 探寻之路</a></p>
<p>除了上述格式外，还有<code>HEIC</code>，<code>AVIF</code>等新格式，有更好的大小表现或编解码性能，但是系统兼容性不好，这里不做说明，有兴趣的可以自行查找相关资料。</p>
<h2 id="图片是如何显示到屏幕上的？"><a href="#图片是如何显示到屏幕上的？" class="headerlink" title="图片是如何显示到屏幕上的？"></a>图片是如何显示到屏幕上的？</h2><p>我们知道，屏幕是由一个个像素点组成的，屏幕的每一个像素点显示不同的颜色，构成了我们看到的画面，<code>iOS</code>中系统以<code>60～120hz</code>的频率从<code>Frame Buffer</code>中读取数据来更新屏幕。那么问题来了，<code>Frame Buffer</code>中的这些数据是如何产生的类？</p>
<p>iOS中视图是基于<code>UIKit</code>来构建，每个App都有一个根视图：<code>UIWindow</code>，它上面一层一层的附加了各种不同类型的View组成了整个App的视图：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211150838.png"><br>这些视图最终会被处理为<code>图元</code>，然后<code>GPU</code>对这些<code>图元</code>进行处理，最终合成转换为像素数据，放入<code>Frame Buffer</code>待屏幕显示时读取。那么其中的图片是怎样被处理并最终显示到屏幕上的类？</p>
<p>在2018的<code>WWDC</code>，苹果官方给出了关于iOS图像处理的最佳实践：<a href="https://developer.apple.com/videos/play/wwdc2018/219">Image and Graphics Best Practices</a>，对这方面内容进行了说明。</p>
<p>图片的加载分为三步，分别是：读取图片数据，解压缩图片，渲染图片。<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211165900.png"></p>
<h3 id="1-读取图片数据"><a href="#1-读取图片数据" class="headerlink" title="1. 读取图片数据"></a>1. 读取图片数据</h3><p>这里指从磁盘或者网络获取图片数据（PNG，JPEG等），然后缓存到内存。（注意这些图片数据一般都是压缩的，它们解压缩后才能得到原始位图）</p>
<h3 id="2-解压缩图片"><a href="#2-解压缩图片" class="headerlink" title="2. 解压缩图片"></a>2. 解压缩图片</h3><p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211170005.png"></p>
<ul>
<li><p>位图的解压缩：得益于<code>SDWebImage</code>等第三方框架帮我们做了大量工作，这一部分经常会被开发者忽略。<code>PNG</code>，<code>JPEG</code>等这些压缩格式会在这一步被解码成原始位图，原始位图的大小与压缩格式无关，只与图片的尺寸有关。以一张1024*1024尺寸的<code>JPEG</code>图片为例，只有<code>380KB</code>，但是按照每个像素<code>RGBA</code>四个字节大小，它解压缩后的大小是<code>1024 * 1024 * 4</code>个字节，即<code>4MB</code>，是解码前的<code>10.8</code>倍！。</p>
<blockquote>
<p>iOS中有内存压缩机制，实际显示的内存消耗可能与此数据不符。在第三方图片框架中，将图片缓存到内存时需要计算图片大小，可以参考这部分代码逻辑来计算内存消耗</p>
</blockquote>
</li>
<li><p>矢量图的解析：矢量图则是通过矢量图解析库来解析，解析库会创建<code>CALayer</code>，然后按照矢量图格式和绘制信息在<code>CALayer</code>上进行图像绘制，虽然这个绘制很复杂，但是和你自己用<code>CALayer</code>绘制自定义视图没有什么本质区别。需要注意的是这个过程是消耗<code>CPU性能</code>和<code>内存</code>的，在直播应用中，使用<code>SVGA</code>来播放复杂动画时，可以明显的看到CPU占用和内存消耗都会增长较多。</p>
</li>
</ul>
<h3 id="3-渲染图片"><a href="#3-渲染图片" class="headerlink" title="3. 渲染图片"></a>3. 渲染图片</h3><p><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211170307.png"><br>这一步大部分都是<code>GPU</code>的工作，通过<code>Render Server</code>及后续流程，将视图进行合成和渲染。日常开发基本接触不到，流程大概如下：<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220211165142.png"><br>这部分和图片这个主题关系不大，不做过多说明，更详细的内容推荐阅读这篇博文：<a href="https://mp.weixin.qq.com/s/6ckRnyAALbCsXfZu56kTDw">iOS 渲染原理解析</a></p>
<h2 id="如何优化图片性能"><a href="#如何优化图片性能" class="headerlink" title="如何优化图片性能"></a>如何优化图片性能</h2><p>通过上面的内容，我们对图片的本质和它如何被显示在屏幕上有了一个大概的认知，在这个基础上，我们可以从如下角度进行优化。</p>
<h3 id="图片数据优化"><a href="#图片数据优化" class="headerlink" title="图片数据优化"></a>图片数据优化</h3><p>常见的是对图片进行压缩，使用<a href="https://tinypng.com/">tinypng</a>或<a href="https://imageoptim.com/mac">imageoptim</a>这类工具对项目中的静态资源进行压缩，<code>tinypng</code>是网站，但是有提供API，<code>imageoptim</code>是软件，可以通过编写脚本来简化和标准化这方面的操作。</p>
<p>第二个就是选择合适的图片尺寸与质量，如果图片与视图大小不匹配，会额外消耗性能，并且浪费带宽。现在各种云存储平台都支持输出指定大小图片，我们可以通过后台下发配置，客户端对接口返回的URL根据配置及视图大小等进行处理，以加载合适大小和质量的图片。这部分如果做的比较细致，还可以考虑如下优化点：</p>
<ul>
<li>屏幕是2x还是3x</li>
<li>大图片降级（iPad或图片实在过大）</li>
<li>低端机降级</li>
<li>降低图片质量</li>
</ul>
<p>第三个就是选择合适的图片格式，现在比较常见的是把<code>JPEG</code>或<code>PNG</code>格式转换为<code>WebP</code>格式，会有很大的图片大小优化，可以查看这里的<a href="https://isparta.github.io/compare-webp/index.html#12345">测试数据</a>。</p>
<blockquote>
<p>直接删除项目中的冗余图片也是一种优化～，推荐使用<a href="https://github.com/onevcat/FengNiao">FengNiao</a></p>
</blockquote>
<h3 id="图片解码优化"><a href="#图片解码优化" class="headerlink" title="图片解码优化"></a>图片解码优化</h3><p>图片解码会大量的消耗<code>CPU性能</code>和<code>内存</code>，常见的优化措施有<code>DownSampling</code>，<code>后台解码</code>以及<code>缓存</code>。</p>
<h4 id="DownSampling（降低采样）"><a href="#DownSampling（降低采样）" class="headerlink" title="DownSampling（降低采样）"></a>DownSampling（降低采样）</h4><p>在图片比视图大的情况下，直接展示原图片会额外的消耗CPU性能和内存。想象一下，如果一个浏览照片的应用展示多张照片时，不做任何处理就直接读取照片并展示，那么Decode时，将会极大的消耗CPU和占用内存。而我们展示的图片<code>View</code>，完全不需要这么大的原始图像。</p>
<p>这种情况可以通过<code>Downsampling</code>来解决，它是一种生成缩略图的方式。<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220213193520.png"><br>上述流程的样例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">downsample</span>(<span class="params">imageAt</span> <span class="params">imageURL</span>: <span class="type">URL</span>, <span class="params">to</span> <span class="params">pointSize</span>: <span class="type">CGSize</span>, <span class="params">scale</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">	<span class="comment">// 加载图片数据且不解码</span></span><br><span class="line">	<span class="keyword">let</span> imageSourceOptions <span class="operator">=</span> [kCGImageSourceShouldCache: <span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">	<span class="keyword">let</span> imageSource <span class="operator">=</span> <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, imageSourceOptions)<span class="operator">!</span></span><br><span class="line">	<span class="keyword">let</span> maxDimensionInPixels <span class="operator">=</span> <span class="built_in">max</span>(pointSize.width, pointSize.height) <span class="operator">*</span> scale</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//kCGImageSourceShouldCacheImmediately设置为true，创建缩略图时会直接解码</span></span><br><span class="line">	<span class="keyword">let</span> downsampleOptions <span class="operator">=</span> [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">								 kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">								 kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">								 kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">	<span class="keyword">let</span> downsampledImage <span class="operator">=</span> <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)<span class="operator">!</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后台解码"><a href="#后台解码" class="headerlink" title="后台解码"></a>后台解码</h4><p>我分析了三个常见的图片解析库：<a href="https://github.com/SDWebImage/SDWebImage">SDWebImage</a>，<a href="https://github.com/ibireme/YYWebImage">YYWebImage</a>，<a href="https://github.com/onevcat/Kingfisher/issues?q=CGBitmapContextCreate">KingFisher</a>，它们都有后台解码功能，底层实现逻辑大概是：当从网络或硬盘获取到图片后，会根据逻辑在后台队列进行解码，实现细节稍有差异：</p>
<table>
<thead>
<tr>
<th>图片解析库</th>
<th>解码队列类型</th>
<th>关键API</th>
<th>默认解码</th>
</tr>
</thead>
<tbody><tr>
<td>SDWebImage</td>
<td>串行</td>
<td>CGBitmapContextCreate</td>
<td>是</td>
</tr>
<tr>
<td>YYWebImage</td>
<td>串行</td>
<td>CGBitmapContextCreate</td>
<td>是</td>
</tr>
<tr>
<td>KingFisher</td>
<td>并行</td>
<td>UIGraphicsBeginImageContextWithOptions</td>
<td>否</td>
</tr>
</tbody></table>
<p>通过<code>Debug</code>汇编分析，<code>UIGraphicsBeginImageContextWithOptions</code>最终也是调用的<code>CGBitmapContextCreate</code>。<br><img src="https://raw.githubusercontent.com/StudyData/ImageHost/master/picgo/20220215115606.png"></p>
<p>另外在分析的过程中发现，同一张<code>JPEG</code>网络图片，基于<code>UIImageView</code>使用不同的框架来加载显示，占用的内存是有差异的，其中<code>SDWebImage</code>的内存占用最高，<code>YYWebImage</code>与<code>KingFisher</code>（设置启用后台解码）的内存占用基本一致，都比<code>SDWebImage</code>占用少，当<code>KingFisher</code>不设置后台解码时，图片显示后内存占用是最大的。由于时间有限，对这部分没有做更细的分析和测试，这个结论不一定正确，欢迎对这部分感兴趣和熟悉的同学留言交流。下面贴出不同框架的解码代码。</p>
<ul>
<li><p>SDWebImage框架解码关键代码：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDImageCoderHelper第228行</span></span><br><span class="line">+ (<span class="built_in">CGImageRef</span>)<span class="built_in">CGImageCreateDecoded</span>:(<span class="built_in">CGImageRef</span>)cgImage orientation:(<span class="built_in">CGImagePropertyOrientation</span>)orientation &#123;</span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">    <span class="type">BOOL</span> hasAlpha = [<span class="keyword">self</span> <span class="built_in">CGImageContainsAlpha</span>:cgImage];</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">    bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, newWidth, newHeight, <span class="number">8</span>, <span class="number">0</span>, [<span class="keyword">self</span> colorSpaceGetDeviceRGB], bitmapInfo);</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Apply transform</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = SDCGContextTransformFromOrientation(orientation, <span class="built_in">CGSizeMake</span>(newWidth, newHeight));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(context, transform);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage); <span class="comment">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImageRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>YYWebImage</code>框架解码关键代码：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// YYImageCoder第868行</span></span><br><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="type">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        <span class="type">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">        <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(context);</span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 <span class="comment">// 省略代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>KingFisher</code>(4.10.1版本)框架解码关键代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Image.swift第727行开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">decoded</span>(<span class="params">scale</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="comment">// `KingFisher`对解码部分进行了多个方法的封装，把关键代码抽离如下，细节请查看源代码。</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageRef <span class="operator">=</span> <span class="keyword">self</span>.cgImage</span><br><span class="line">    <span class="comment">// guard let context = beginContext(size: CGSize(width: imageRef.width, height: imageRef.height), scale: 1.0) </span></span><br><span class="line">	<span class="type">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">false</span>, scale)</span><br><span class="line">    <span class="keyword">let</span> context <span class="operator">=</span> <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context<span class="operator">?</span>.scaleBy(x: <span class="number">1.0</span>, y: <span class="operator">-</span><span class="number">1.0</span>)</span><br><span class="line">    context<span class="operator">?</span>.translateBy(x: <span class="number">0</span>, y: <span class="operator">-</span>size.height)</span><br><span class="line">    <span class="comment">//defer &#123; endContext() &#125;</span></span><br><span class="line">    <span class="keyword">let</span> rect <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">CGFloat</span>(imageRef.width), height: <span class="type">CGFloat</span>(imageRef.height))</span><br><span class="line">    context.draw(imageRef, in: rect)</span><br><span class="line">    <span class="keyword">let</span> decompressedImageRef <span class="operator">=</span> context.makeImage()</span><br><span class="line">	<span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">    <span class="comment">//return Kingfisher&lt;Image&gt;.image(cgImage: decompressedImageRef!, scale: scale, refImage: base)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">Image</span>(cgImage: decompressedImageRef, scale: scale, orientation: .up)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>另外，之前提到的<code>DownSampling</code>这些第三方网络框架都支持。在<code>SDWebImage</code>框架中，通过<code>context</code>设置<code>SDWebImageContextImageThumbnailPixelSize</code>即可调整采样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thumbnailPixelSizesize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">self</span>.sdImageView.sd_setImage(</span><br><span class="line">    with: <span class="type">URL</span>.<span class="keyword">init</span>(string: urlStr),</span><br><span class="line">    placeholderImage: <span class="literal">nil</span>,</span><br><span class="line">    options: <span class="type">SDWebImageOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>),</span><br><span class="line">    context: [.imageThumbnailPixelSize: thumbnailPixelSizesize])</span><br></pre></td></tr></table></figure>

<p>在<code>KingFisher</code>中则通过在<code>options</code>参数中传入相应对<code>processor</code>来进行处理。当然这些第三方框架的功能远不止于此，例如对图片进行高斯模糊，画圆角等都有支持。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>图片下载会大量的占用带宽，解码会大量的消耗CPU性能，所以一般的策略都是将下载的图片存储到硬盘，将解码的图片缓存到内存来优化性能。这些第三方框架都对这些功能进行了良好的封装，具体的实现细节这里就不做展开了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/219">Image and Graphics Best Practices</a>: 官方视频，推荐观看</li>
<li><a href="https://www.bilibili.com/video/BV1YA411n7Dt/">Advanced Graphics and Animation for iOS Apps</a>：官方视频，2014年WWDC发布的，官方已经下架，可以在B站观看</li>
<li><a href="https://juejin.cn/post/6844903793755176968">iOS图像最佳实践总结</a>：对<code>Image and Graphics Best Practices</code>视频的整理，非常全面详细。</li>
<li><a href="https://mp.weixin.qq.com/s/6ckRnyAALbCsXfZu56kTDw">iOS 渲染原理解析</a>：写的非常全面和深入，推荐阅读</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0">每英寸像素</a></li>
<li><a href="https://juejin.cn/post/6844903953172267022">聊一聊几种常用web图片格式：gif、jpg、png、webp</a></li>
<li><a href="https://www.teqng.com/2021/09/14/%E5%B0%86%E5%9B%BE%E7%89%87%E5%BA%93%E4%BC%98%E5%8C%96%E5%88%B0%E5%BA%95%EF%BC%8C%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%9850%EF%BC%81%E4%BA%AC%E4%B8%9C%E4%BA%AC%E5%96%9Capp%E6%98%AF%E5%A6%82%E4%BD%95/">将图片库优化到底，性能提高50%！京东京喜App是如何做到的？</a></li>
<li><a href="https://juejin.cn/post/6844903591510048775">深入理解 iOS Rendering Process</a></li>
<li><a href="https://toutiao.io/posts/dynj4k/preview">WebP 探寻之路</a></li>
<li><a href="https://dreampiggy.com/2019/01/18/%E4%B8%BB%E6%B5%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A2%84%E8%A7%A3%E7%A0%81%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/">主流图片加载库所使用的预解码究竟干了什么</a></li>
<li><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS状态栏问题探究</title>
    <url>/2022/04/01/iOS%E7%8A%B6%E6%80%81%E6%A0%8F%E9%97%AE%E9%A2%98%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><p>最近在适配UI的时候，发现在<code>iOS13</code>及以后的版本进入一个视频播放页面后，调用更改状态栏的<code>API</code>无效了。后面发现是由于<code>iOS13</code>以后对<code>Scene</code>的适配以及一个隐藏的<code>UIWindow</code>导致的，<code>iOS13</code>加入<code>Scene</code>后，系统状态栏的实现发现了很大的变化。这里对<code>iOS</code>状态栏进行一个系统的总结备后续参考。</p>
<span id="more"></span>

<h2 id="如何控制状态栏"><a href="#如何控制状态栏" class="headerlink" title="如何控制状态栏"></a>如何控制状态栏</h2><h3 id="使用UIApplication控制（iOS7之前）"><a href="#使用UIApplication控制（iOS7之前）" class="headerlink" title="使用UIApplication控制（iOS7之前）"></a>使用<code>UIApplication</code>控制（iOS7之前）</h3><p>在<code>iOS7</code>之前，一般都是通过直接使用<code>UIApplication</code>来变更状态栏的样式和隐藏状态。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIApplication</span></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span>, introduced: <span class="number">2.0</span>, deprecated: <span class="number">9.0</span>, message: <span class="string">&quot;Use -[UIViewController preferredStatusBarStyle]&quot;</span>)</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">setStatusBarStyle</span>(<span class="keyword">_</span> <span class="params">statusBarStyle</span>: <span class="type">UIStatusBarStyle</span>, <span class="params">animated</span>: <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span>, introduced: <span class="number">3.2</span>, deprecated: <span class="number">9.0</span>, message: <span class="string">&quot;Use -[UIViewController prefersStatusBarHidden]&quot;</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">setStatusBarHidden</span>(<span class="keyword">_</span> <span class="params">hidden</span>: <span class="type">Bool</span>, <span class="params">with</span> <span class="params">animation</span>: <span class="type">UIStatusBarAnimation</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以直接通过调用：<code>UIApplication.shared.setStatusBarStyle(.lightContent, animated: true)</code>来修改状态栏，非常的简单粗暴。但是在复杂逻辑中，这样全局的设置容易造成混乱和不好维护。所以在<code>iOS7</code>后提供了新的控制体系，并把上述方法在<code>iOS9</code>标记为<code>deprecated</code>。</p>
<h3 id="View-controller-based-status-bar-appearance方式（iOS7之后）"><a href="#View-controller-based-status-bar-appearance方式（iOS7之后）" class="headerlink" title="View controller-based status bar appearance方式（iOS7之后）"></a><code>View controller-based status bar appearance</code>方式（iOS7之后）</h3><p><code>Apple</code>在<code>iOS7</code>中提供了新的状态栏控制方法，由<code>VC</code>去负责自己生命周期中的状态栏控制。使用新方法首先要在<code>Info.plist</code>中将<code>View controller-based status bar appearance</code> 设为<code>YES</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;key&gt;UIViewControllerBasedStatusBarAppearance&lt;/key&gt;</span><br><span class="line">&lt;<span class="keyword">true</span>/&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后在相应的<code>VC</code>中重写两个控制方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">changeStatusBar</span>() &#123;</span><br><span class="line">    statusBarStyle <span class="operator">=</span> .lightContent</span><br><span class="line">    isStatusBarHidden <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 调用后状态栏才会刷新</span></span><br><span class="line">    setNeedsStatusBarAppearanceUpdate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制状态栏样式</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> statusBarStyle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制状态栏隐藏状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">var</span> prefersStatusBarHidden: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isStatusBarHidden</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们就可以通过<code>VC</code>来控制当前它所在视图的状态栏的样式。但是在实际使用中并没有这样简单，因为<code>VC</code>可能是嵌套在<code>UINavigationController</code>中，或者我需要<code>VC</code>的<code>childViewControllers</code>来控制状态栏的样式等。这就涉及到控制权限问题了。</p>
<h4 id="子控制器的控制权限问题"><a href="#子控制器的控制权限问题" class="headerlink" title="子控制器的控制权限问题"></a>子控制器的控制权限问题</h4><p>这种类型非常简单，如果你想要使用子控制器来更改状态栏的状态，重写<code>UIViewController</code>的<code>childForStatusBarStyle</code>方法即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> childForStatusBarStyle: <span class="type">UIViewController</span>? &#123;</span><br><span class="line">    <span class="keyword">let</span> childVC <span class="operator">=</span> children[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 将控制权限交给childVC</span></span><br><span class="line">    <span class="keyword">return</span> childVC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> childForStatusBarHidden: <span class="type">UIViewController</span>? &#123;</span><br><span class="line">    <span class="keyword">let</span> childVC <span class="operator">=</span> children[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 将控制权限交给childVC</span></span><br><span class="line">    <span class="keyword">return</span> childVC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样状态栏的控制权限就交给了子控制器<code>childVC</code>。</p>
<h4 id="UINavigationController的控制权限问题"><a href="#UINavigationController的控制权限问题" class="headerlink" title="UINavigationController的控制权限问题"></a><code>UINavigationController</code>的控制权限问题</h4><p>这种情况涉及到导航栏，会复杂一些，分为状态栏是否可见两种场景，它的规则如下：</p>
<ol>
<li>当<code>NavigationBar</code>不可见时，由它栈顶的<code>topViewController</code>控制状态栏。</li>
<li>当<code>NavigationBar</code>可见时，由它自身控制状态栏。这种情况下，由它的<code>barStyle</code>属性决定状态栏的样式：<ul>
<li>当<code>barStyle</code> &#x3D; <code>.default</code> 时，<code>NavigationBar</code>显示为白色，此时<code>StatusBar</code>显示为黑色</li>
<li>当<code>barStyle</code> &#x3D; <code>.black</code> 时，<code>NavigationBar</code> 显示为白色，此时<code>StatusBar</code>显示为白色</li>
</ul>
</li>
</ol>
<p>如果你既不想隐藏状态栏，又想让<code>topViewController</code>来控制状态栏，那么可以像上面<code>子控制器的控制权限问题</code>的方法一样，重写<code>childForStatusBarStyle</code>和<code>childForStatusBarHidden</code>即可。</p>
<h4 id="Modal-Presentation的控制权限问题"><a href="#Modal-Presentation的控制权限问题" class="headerlink" title="Modal Presentation的控制权限问题"></a><code>Modal Presentation</code>的控制权限问题</h4><p>当我们<code>presnet</code>一个<code>VC</code>时，它的状态栏由谁控制，取决于它是否是全屏展示。现在<code>VC</code>默认的<code>modalPresentationStyle</code>是<code>UIModalPresentationStyle.automatic</code>，并不是全屏展示，所以默认情况下它自身并不控制状态栏。但是当我们将<code>modalPresentationStyle</code>改为<code>UIModalPresentationStyle.fullScreen</code>后，它变成了全屏展示，就获得了状态栏的控制权。</p>
<p>如果既不想让<code>present</code>的<code>VC</code>全屏显示，又想让它控制状态栏，那么将它的<code>modalPresentationCapturesStatusBarAppearance</code>属性设置为<code>true</code>即可。</p>
<h2 id="iOS13之前状态栏的底层实现及状态栏无法控制的场景"><a href="#iOS13之前状态栏的底层实现及状态栏无法控制的场景" class="headerlink" title="iOS13之前状态栏的底层实现及状态栏无法控制的场景"></a>iOS13之前状态栏的底层实现及状态栏无法控制的场景</h2><p>在<code>iOS13</code>之前，状态栏是通过<code>UIWindow</code>来实现的，可以很方便的通过<code>UIApplication</code>拿到状态栏对应的视图。</p>
<blockquote>
<p>以前还有通过状态栏获取网络状态等骚操作。</p>
</blockquote>
<p>在<code>iOS13</code>之前，我们可以通过如下代码来分析状态栏：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到状态栏</span></span><br><span class="line"><span class="type">id</span> bar = [[<span class="built_in">UIApplication</span> sharedApplication] valueForKey:<span class="string">@&quot;_statusBar&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;class:%@, superClass:%@&quot;</span>, [bar <span class="keyword">class</span>], [bar superclass]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;superview:%@&quot;</span>, [bar superview]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Demo[28973:959757] class:UIStatusBar, superClass:UIStatusBar_Base</span></span><br><span class="line"><span class="comment">Demo[28973:959757] superView:&lt;UIStatusBarWindow: 0x7fcbd8d0c9b0; frame = (0 0; 320 568); opaque = NO; gestureRecognizers = &lt;NSArray: 0x600002b4def0&gt;; layer = &lt;UIWindowLayer: 0x6000025581c0&gt;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上述样例可以看到，状态栏的类名叫<code>UIStatusBar</code>，它继承自<code>UIStatusBar_Base</code>，被添加在<code>UIStatusBarWindow</code>（UIWindow的子类）上被显示出来。</p>
<p>当我们新建一个<code>UIWindow</code>，将它隐藏，它是不会影响到<code>keyWindow</code>的状态栏控制的，但是当将它设为不隐藏并且将<code>frame</code>的值设为<code>UIScreen.main.bounds</code>的时候，<code>keyWindow</code>的状态栏控制将会失效。有趣的是，将<code>frame</code>改小或改大后，都不会导致失效，只有值为<code>UIScreen.main.bounds</code>的时候才会导致异常，感觉像是iOS的源码里面有代码逻辑来判断<code>frame</code>是否与<code>UIScreen.main.bounds</code>相等一样。</p>
<blockquote>
<p><code>windowLevel</code>不影响上述结论</p>
</blockquote>
<h2 id="iOS13之后状态栏的底层实现及状态栏无法控制的场景"><a href="#iOS13之后状态栏的底层实现及状态栏无法控制的场景" class="headerlink" title="iOS13之后状态栏的底层实现及状态栏无法控制的场景"></a>iOS13之后状态栏的底层实现及状态栏无法控制的场景</h2><p><code>iOS13</code>之后，状态栏的底层实现完全发生了变化，从<code>UIApplication</code>取<code>_statusBar</code>只会返回<code>nil</code>，对<code>UIStatusBar</code>，<code>UIStatusBar_Base</code>，<code>UIStatusBarWindow</code>等类的初始化方法<code>hook</code>，发现都没有被调用。这说明iOS13之后，状态栏的视图实现逻辑被完全重构了。</p>
<p>iOS13新增了一个<code>UIStatusBarManager</code>类（之前也有，但是是私有的）,系统源码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">UIStatusBarManager</span> : <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> statusBarStyle: <span class="type">UIStatusBarStyle</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> isStatusBarHidden: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> statusBarFrame: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// returns CGRectZero if the status bar is hidden</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIWindowScene</span> &#123;</span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> statusBarManager: <span class="type">UIStatusBarManager</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>runtime</code>打印出它的成员变量和方法列表分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 成员变量列表</span><br><span class="line">&quot;_overriddingStatusBarHidden&quot; = &quot;@&quot;;</span><br><span class="line">&quot;_scene&quot; = UIScene;</span><br><span class="line">&quot;_statusBarFrameIgnoringVisibility&quot; = &quot;GRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&quot;;</span><br><span class="line">debugDescription = NSString;</span><br><span class="line">debugMenuHandler = &quot;@&quot;;</span><br><span class="line">defaultStatusBarHeight = &quot;@&quot;;</span><br><span class="line">description = NSString;</span><br><span class="line">hash = &quot;@&quot;;</span><br><span class="line">inStatusBarFadeAnimation = &quot;@&quot;;</span><br><span class="line">localStatusBars = NSMutableSet;</span><br><span class="line">statusBarAlpha = &quot;@&quot;;</span><br><span class="line">statusBarFrame = &quot;GRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&quot;;</span><br><span class="line">statusBarHeight = &quot;@&quot;;</span><br><span class="line">statusBarHidden = &quot;@&quot;;</span><br><span class="line">statusBarPartStyles = NSDictionary;</span><br><span class="line">statusBarStyle = &quot;@&quot;;</span><br><span class="line">superclass = &quot;@&quot;;</span><br><span class="line">windowScene = UIWindowScene;</span><br><span class="line"></span><br><span class="line">// 方法列表</span><br><span class="line">.cxx_destruct</span><br><span class="line">_settingsDiffActionsForScene:</span><br><span class="line">initWithScene:</span><br><span class="line">_scene</span><br><span class="line">_setScene:</span><br><span class="line">windowScene</span><br><span class="line">isStatusBarHidden</span><br><span class="line">defaultStatusBarHeightInOrientation:</span><br><span class="line">statusBarStyle</span><br><span class="line">statusBarHeight</span><br><span class="line">setWindowScene:</span><br><span class="line">updateStatusBarAppearance</span><br><span class="line">updateLocalStatusBars</span><br><span class="line">statusBarHidden</span><br><span class="line">statusBarAlpha</span><br><span class="line">setupForSingleLocalStatusBar</span><br><span class="line">updateStatusBarAppearanceWithAnimationParameters:</span><br><span class="line">statusBarFrameForStatusBarHeight:</span><br><span class="line">defaultStatusBarHeight</span><br><span class="line">_updateStatusBarAppearanceWithClientSettings:transitionContext:animationParameters:</span><br><span class="line">_updateVisibilityForWindow:targetOrientation:animationParameters:</span><br><span class="line">_updateStyleForWindow:animationParameters:</span><br><span class="line">_updateAlpha</span><br><span class="line">_visibilityChangedWithOriginalOrientation:targetOrientation:animationParameters:</span><br><span class="line">activateLocalStatusBar:</span><br><span class="line">_updateLocalStatusBar:</span><br><span class="line">statusBarFrame</span><br><span class="line">_handleScrollToTopAtXPosition:</span><br><span class="line">_adjustedLocationForXPosition:</span><br><span class="line">_setOverridingStatusBarHidden:</span><br><span class="line">_setOverridingStatusBarHidden:animationParameters:</span><br><span class="line">statusBarFrameForStatusBarHeight:inOrientation:</span><br><span class="line">_statusBarFrameIgnoringVisibility</span><br><span class="line">updateStatusBarAppearanceWithClientSettings:transitionContext:</span><br><span class="line">deactivateLocalStatusBar:</span><br><span class="line">createLocalStatusBar</span><br><span class="line">handleTapAction:</span><br><span class="line">_isOverridingStatusBarHidden</span><br><span class="line">localStatusBars</span><br><span class="line">setLocalStatusBars:</span><br><span class="line">statusBarPartStyles</span><br><span class="line">isInStatusBarFadeAnimation</span><br><span class="line">debugMenuHandler</span><br><span class="line">setDebugMenuHandler:</span><br></pre></td></tr></table></figure>

<p>通过<code>runtime</code>调用<code>createLocalStatusBar</code>创建状态栏发现状态栏的类名是：<code>_UIStatusBarLocalView</code>，对这个类及它相关属性进行分析，然后进行hook，发现这些类运行时都没有创建和使用，线索到这里就断了。</p>
<p>虽然底层实现发生了变化，但是状态栏状态变更的接口和结果依然和之前版本保持一致，上面说的导致<code>keyWindow</code>的状态栏控制失效的场景也依然存在。但是我在实际开发中碰到了一个更诡异的问题，在我们现在的项目中，需要适配CarPlay，所以使用了<code>Scene</code>，使用<code>Scene</code>后，所有的<code>UIWindow</code>必须设置它的<code>windowScene</code>属性，它才能正确显示在对应的<code>scene</code>中，由于项目中引用了<code>DoraemonKit</code>等第三方框架，它们内部使用<code>UIWindow</code>进行显示，为了让项目正常运行，同事hook了一些代码：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">SceneHook</span>)</span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">13.0</span>, *)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            SEL selector = <span class="keyword">@selector</span>(initWithFrame:);</span><br><span class="line">            Method method = class_getInstanceMethod(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">                <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@&quot;Method not found for [UIView initWithFrame:]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            IMP imp = method_getImplementation(method);</span><br><span class="line">            class_replaceMethod(<span class="keyword">self</span>, selector, imp_implementationWithBlock(^(<span class="built_in">UIView</span> *<span class="keyword">self</span>, <span class="built_in">CGRect</span> frame) &#123;</span><br><span class="line">                ((<span class="built_in">UIView</span> * (*)(<span class="built_in">UIView</span> *, SEL, <span class="built_in">CGRect</span>))imp)(<span class="keyword">self</span>, selector, frame);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:<span class="built_in">UIWindow</span>.class]) &#123;</span><br><span class="line">                    <span class="built_in">UIWindowScene</span> *scene = [<span class="built_in">UIApplication</span> sharedApplication].keyWindow.windowScene;</span><br><span class="line">                    [(<span class="built_in">UIWindow</span> *)<span class="keyword">self</span> setWindowScene:scene];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">            &#125;), method_getTypeEncoding(method));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们有接入腾讯的视频播放SDK，它在播放视频时会创建一个<code>window</code>单例：<code>SuperPlayerWindow</code>，用于实现播放器小窗功能，这个<code>window</code>默认是<strong>隐藏</strong>的，在<code>iOS13</code>之前没有问题，但是在<code>iOS13</code>及之后会导致<code>keyWindow</code>中<code>VC</code>的状态栏控制功能失效。（注意这个window是隐藏不显示的）</p>
<blockquote>
<p>吐槽下，整一个视图单例，创建后就在app生命周期中一直存在，这种设计明显是不合理的。</p>
</blockquote>
<p>将这个<code>SuperPlayerWindow</code>的<code>frame</code>设为<code>UIScreen.main.bounds</code>之外的值可以解决这个问题，将上述hook代码进行如下修改也可以解决这个问题：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIWindow</span> (<span class="title">SceneHook</span>)</span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">13.0</span>, *)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            SEL selector = <span class="keyword">@selector</span>(initWithFrame:);</span><br><span class="line">            Method method = class_getInstanceMethod(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">                <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@&quot;Method not found for [UIWindow initWithFrame:]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            IMP imp = method_getImplementation(method);</span><br><span class="line">            class_replaceMethod(<span class="keyword">self</span>, selector, imp_implementationWithBlock(^(<span class="built_in">UIWindow</span> *<span class="keyword">self</span>, <span class="built_in">CGRect</span> frame) &#123;</span><br><span class="line">                ((<span class="built_in">UIWindow</span> * (*)(<span class="built_in">UIWindow</span> *, SEL, <span class="built_in">CGRect</span>))imp)(<span class="keyword">self</span>, selector, frame);</span><br><span class="line">                <span class="built_in">UIWindowScene</span> *scene = [<span class="built_in">UIApplication</span> sharedApplication].keyWindow.windowScene;</span><br><span class="line">                [(<span class="built_in">UIWindow</span> *)<span class="keyword">self</span> setWindowScene:scene];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">            &#125;), method_getTypeEncoding(method));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上述两段代码没有看到和状态栏有什么关联的地方，但是却实实在在的产生影响，受制于<code>iOS</code>的<code>UIKit</code>是闭源的，没法通过源码查找它的产生的原因，如果你有什么思路，欢迎留言讨论～</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://juejin.cn/post/6844903537000857608">UIStatusBarStyle 解惑</a></li>
<li><a href="https://www.jianshu.com/p/006c2d663d2d">iOS状态栏的管理</a></li>
<li><a href="https://juejin.cn/post/6844903925678604295">iOS13 获取StatusBar并且获取网络状态</a></li>
<li><a href="https://juejin.cn/post/6844903952853499918">Xcode11新变化：SceneDelegate</a></li>
<li><a href="https://juejin.cn/post/6844903993496305671">iOS13 Scene Delegate详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术笔记</tag>
        <tag>iOS</tag>
        <tag>UI</tag>
      </tags>
  </entry>
</search>
