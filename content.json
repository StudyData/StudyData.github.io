[{"title":"iOS图片显示原理与优化思路","date":"2022-02-15T09:40:05.000Z","path":"2022/02/15/iOS图片显示原理与优化思路/","text":"图像的种类所有的数字图像都可以归类为光栅或矢量两种类型。我们一般称光栅图为位图，它由像素组成，每个像素都有颜色数据，例如RGB值，透明度等。它常见的格式有PNG，JPEG，WEBP等，这些只是一个压缩位图格式，不同的压缩格式压缩率和适用的场景不一样，解码性能也不一样，但是它们有一个共同特点是拉升到大于原始宽高后会变得模糊。 矢量图形是用点，线等基于数学方程的几何图元表示的图像。常见的格式有SVG，AI等，它们的特点是放大到任何大小都不会降低其质量。 文本是最常见的矢量图形之一 我们可以把两种类型讲得更通俗一点，位图就是告诉计算机：“这个像素应该是淡黄色的，下一个应该是深紫色的，之后的应该是粉红色的”等等。但是对于矢量图，则是说：”画一个长100，宽100的正方形，给它填充为绿色。”，但是最终它还是会被渲染成位图数据进行展示。不同的是压缩位图根据压缩格式解码得到原始位图数据，矢量图通过计算得到原始位图数据。 位图与矢量图的区别对比 位图 矢量图像 原理 像素 锚点，线条 使用场景 照片，复杂的颜色/纹理/阴影等 字体，地图，动画等 缩放 受分辨率限制 在保持质量的同时无限扩展 文件大小 较大，但可以压缩 小 性能 好，解压缩后根据像素直接渲染 差，需要解析并计算，再生成像素点进行渲染 常见格式 PNG，JPEG，WEBP等 SVG，AI等 表格所示的文件大小并不是绝对的，要分场景。例如一张JPEG风景图，用矢量图来做肯定是非常大且不合适的。 不同位图格式适用场景的对比日常开发常见的位图格式对比如下： 格式 优点 缺点 适用场景 gif 文件小，支持动画、透明，兼容好 只支持256种颜色 色彩简单的logo、icon、动图 jpeg 色彩丰富，可压缩率高 有损压缩，压缩后图片质量下降 色彩丰富的图片，照片等 png 无损压缩，支持透明，简单图片尺寸小 不支持动画，色彩丰富的图片尺寸大 logo、icon、透明图 webp 文件小，支持有损和无损压缩，支持动画、透明 浏览器兼容性不好，编解码性能差 支持webp格式等app和webView 相同视觉体验下，webp一般比JPEG和PNG尺寸更小，但是小icon这类图片，一般PNG尺寸更小。另外webp的解码时间更长，有人测试可以达到png格式的4.4倍，但是一般在后台解码和使用缓存，所以实际运行时webp更长的解码时间并不会造成性能瓶颈。相反，由于webp尺寸更小，下载耗时更少，可以节约带宽和得到更快的显示速度。 具体可以参考：WebP 探寻之路 除了上述格式外，还有HEIC，AVIF等新格式，有更好的大小表现或编解码性能，但是系统兼容性不好，这里不做说明，有兴趣的可以自行查找相关资料。 图片是如何显示到屏幕上的？我们知道，屏幕是由一个个像素点组成的，屏幕的每一个像素点显示不同的颜色，构成了我们看到的画面，iOS中系统以60～120hz的频率从Frame Buffer中读取数据来更新屏幕。那么问题来了，Frame Buffer中的这些数据是如何产生的类？ iOS中视图是基于UIKit来构建，每个App都有一个根视图：UIWindow，它上面一层一层的附加了各种不同类型的View组成了整个App的视图：这些视图最终会被处理为图元，然后GPU对这些图元进行处理，最终合成转换为像素数据，放入Frame Buffer待屏幕显示时读取。那么其中的图片是怎样被处理并最终显示到屏幕上的类？ 在2018的WWDC，苹果官方给出了关于iOS图像处理的最佳实践：Image and Graphics Best Practices，对这方面内容进行了说明。 图片的加载分为三步，分别是：读取图片数据，解压缩图片，渲染图片。 1. 读取图片数据这里指从磁盘或者网络获取图片数据（PNG，JPEG等），然后缓存到内存。（注意这些图片数据一般都是压缩的，它们解压缩后才能得到原始位图） 2. 解压缩图片 位图的解压缩：得益于SDWebImage等第三方框架帮我们做了大量工作，这一部分经常会被开发者忽略。PNG，JPEG等这些压缩格式会在这一步被解码成原始位图，原始位图的大小与压缩格式无关，只与图片的尺寸有关。以一张1024*1024尺寸的JPEG图片为例，只有380KB，但是按照每个像素RGBA四个字节大小，它解压缩后的大小是1024 * 1024 * 4个字节，即4MB，是解码前的10.8倍！。 iOS中有内存压缩机制，实际显示的内存消耗可能与此数据不符。在第三方图片框架中，将图片缓存到内存时需要计算图片大小，可以参考这部分代码逻辑来计算内存消耗 矢量图的解析：矢量图则是通过矢量图解析库来解析，解析库会创建CALayer，然后按照矢量图格式和绘制信息在CALayer上进行图像绘制，虽然这个绘制很复杂，但是和你自己用CALayer绘制自定义视图没有什么本质区别。需要注意的是这个过程是消耗CPU性能和内存的，在直播应用中，使用SVGA来播放复杂动画时，可以明显的看到CPU占用和内存消耗都会增长较多。 3. 渲染图片这一步大部分都是GPU的工作，通过Render Server及后续流程，将视图进行合成和渲染。日常开发基本接触不到，流程大概如下：这部分和图片这个主题关系不大，不做过多说明，更详细的内容推荐阅读这篇博文：iOS 渲染原理解析 如何优化图片性能通过上面的内容，我们对图片的本质和它如何被显示在屏幕上有了一个大概的认知，在这个基础上，我们可以从如下角度进行优化。 图片数据优化常见的是对图片进行压缩，使用tinypng或imageoptim这类工具对项目中的静态资源进行压缩，tinypng是网站，但是有提供API，imageoptim是软件，可以通过编写脚本来简化和标准化这方面的操作。 第二个就是选择合适的图片尺寸与质量，如果图片与视图大小不匹配，会额外消耗性能，并且浪费带宽。现在各种云存储平台都支持输出指定大小图片，我们可以通过后台下发配置，客户端对接口返回的URL根据配置及视图大小等进行处理，以加载合适大小和质量的图片。这部分如果做的比较细致，还可以考虑如下优化点： 屏幕是2x还是3x 大图片降级（iPad或图片实在过大） 低端机降级 降低图片质量 第三个就是选择合适的图片格式，现在比较常见的是把JPEG或PNG格式转换为WebP格式，会有很大的图片大小优化，可以查看这里的测试数据。 直接删除项目中的冗余图片也是一种优化～，推荐使用FengNiao 图片解码优化图片解码会大量的消耗CPU性能和内存，常见的优化措施有DownSampling，后台解码以及缓存。 DownSampling（降低采样）在图片比视图大的情况下，直接展示原图片会额外的消耗CPU性能和内存。想象一下，如果一个浏览照片的应用展示多张照片时，不做任何处理就直接读取照片并展示，那么Decode时，将会极大的消耗CPU和占用内存。而我们展示的图片View，完全不需要这么大的原始图像。 这种情况可以通过Downsampling来解决，它是一种生成缩略图的方式。上述流程的样例代码如下： 1234567891011121314func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage &#123; // 加载图片数据且不解码 let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions)! let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale //kCGImageSourceShouldCacheImmediately设置为true，创建缩略图时会直接解码 let downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions)! return UIImage(cgImage: downsampledImage)&#125; 后台解码我分析了三个常见的图片解析库：SDWebImage，YYWebImage，KingFisher，它们都有后台解码功能，底层实现逻辑大概是：当从网络或硬盘获取到图片后，会根据逻辑在后台队列进行解码，实现细节稍有差异： 图片解析库 解码队列类型 关键API 默认解码 SDWebImage 串行 CGBitmapContextCreate 是 YYWebImage 串行 CGBitmapContextCreate 是 KingFisher 并行 UIGraphicsBeginImageContextWithOptions 否 通过Debug汇编分析，UIGraphicsBeginImageContextWithOptions最终也是调用的CGBitmapContextCreate。 另外在分析的过程中发现，同一张JPEG网络图片，基于UIImageView使用不同的框架来加载显示，占用的内存是有差异的，其中SDWebImage的内存占用最高，YYWebImage与KingFisher（设置启用后台解码）的内存占用基本一致，都比SDWebImage占用少，当KingFisher不设置后台解码时，图片显示后内存占用是最大的。由于时间有限，对这部分没有做更细的分析和测试，这个结论不一定正确，欢迎对这部分感兴趣和熟悉的同学留言交流。下面贴出不同框架的解码代码。 SDWebImage框架解码关键代码： 1234567891011121314151617181920// SDImageCoderHelper第228行+ (CGImageRef)CGImageCreateDecoded:(CGImageRef)cgImage orientation:(CGImagePropertyOrientation)orientation &#123; // 省略代码... BOOL hasAlpha = [self CGImageContainsAlpha:cgImage]; CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate(NULL, newWidth, newHeight, 8, 0, [self colorSpaceGetDeviceRGB], bitmapInfo); if (!context) &#123; return NULL; &#125; // Apply transform CGAffineTransform transform = SDCGContextTransformFromOrientation(orientation, CGSizeMake(newWidth, newHeight)); CGContextConcatCTM(context, transform); CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // The rect is bounding box of CGImage, don't swap width &amp; height CGImageRef newImageRef = CGBitmapContextCreateImage(context); CGContextRelease(context); return newImageRef;&#125; YYWebImage框架解码关键代码： 123456789101112131415161718192021222324252627// YYImageCoder第868行CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) &#123; // ...省略代码 if (decodeForDisplay) &#123; //decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) &#123; hasAlpha = YES; &#125; // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -[UIView drawRect:] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; &#125; else &#123; // 省略代码.... &#125;&#125; KingFisher(4.10.1版本)框架解码关键代码： 1234567891011121314151617// Image.swift第727行开始public func decoded(scale: CGFloat) -&gt; Image &#123; // `KingFisher`对解码部分进行了多个方法的封装，把关键代码抽离如下，细节请查看源代码。 guard let imageRef = self.cgImage // guard let context = beginContext(size: CGSize(width: imageRef.width, height: imageRef.height), scale: 1.0) UIGraphicsBeginImageContextWithOptions(size, false, scale) let context = UIGraphicsGetCurrentContext() context?.scaleBy(x: 1.0, y: -1.0) context?.translateBy(x: 0, y: -size.height) //defer &#123; endContext() &#125; let rect = CGRect(x: 0, y: 0, width: CGFloat(imageRef.width), height: CGFloat(imageRef.height)) context.draw(imageRef, in: rect) let decompressedImageRef = context.makeImage() UIGraphicsEndImageContext() //return Kingfisher&lt;Image&gt;.image(cgImage: decompressedImageRef!, scale: scale, refImage: base) return Image(cgImage: decompressedImageRef, scale: scale, orientation: .up)&#125; 另外，之前提到的DownSampling这些第三方网络框架都支持。在SDWebImage框架中，通过context设置SDWebImageContextImageThumbnailPixelSize即可调整采样。 123456let thumbnailPixelSizesize = CGSize(width: 100, height: 100)self.sdImageView.sd_setImage( with: URL.init(string: urlStr), placeholderImage: nil, options: SDWebImageOptions.init(rawValue: 0), context: [.imageThumbnailPixelSize: thumbnailPixelSizesize]) 在KingFisher中则通过在options参数中传入相应对processor来进行处理。当然这些第三方框架的功能远不止于此，例如对图片进行高斯模糊，画圆角等都有支持。 缓存图片下载会大量的占用带宽，解码会大量的消耗CPU性能，所以一般的策略都是将下载的图片存储到硬盘，将解码的图片缓存到内存来优化性能。这些第三方框架都对这些功能进行了良好的封装，具体的实现细节这里就不做展开了。 参考资料 Image and Graphics Best Practices: 官方视频，推荐观看 Advanced Graphics and Animation for iOS Apps：官方视频，2014年WWDC发布的，官方已经下架，可以在B站观看 iOS图像最佳实践总结：对Image and Graphics Best Practices视频的整理，非常全面详细。 iOS 渲染原理解析：写的非常全面和深入，推荐阅读 每英寸像素 聊一聊几种常用web图片格式：gif、jpg、png、webp 将图片库优化到底，性能提高50%！京东京喜App是如何做到的？ 深入理解 iOS Rendering Process WebP 探寻之路 主流图片加载库所使用的预解码究竟干了什么 移动端图片格式调研","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"iOS中Pod库资源引用探究","date":"2022-02-11T04:56:00.000Z","path":"2022/02/11/iOS中Pod库资源引用探究/","text":"前言cocoapods中Pod引用资源的方式有多种，不同的方式对资源的使用还是有区别的，但也有一定的规律，这里我用一个样例工程来进行说明，样例工程名叫：AssetsDemo，使用pod lib create AssetsDemo命令创建，目录结构如图： 这个pod很简单，Classes目录只有一个cell的swift和xib文件，Assets目录有一些图片资源，其中的TestTableViewCell.xib使用了这张test图片。目录结构如下： 123456789101112├── Assets│ ├── Images.xcassets│ │ ├── Contents.json│ │ └── test.imageset│ │ ├── Contents.json│ │ ├── test@2x.png│ │ └── test@3x.png│ ├── test1@2x.png│ └── test1@3x.png└── Classes ├── TestTableViewCell.swift └── TestTableViewCell.xib 前期工作已经准备完毕，下面说下xib和图片资源不同使用方式下的区别: 将xib放入source_files，图片放入resource_bundles在podspec的写法如下： 1234s.source_files = 'AssetsDemo/Classes/**/*'s.resource_bundles = &#123; 'AssetsDemo' =&gt; ['AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png&#125;']&#125; 运行后会生成这样的framework：我们可以看到，xib后缀会变成nib，并被放入framework中，而图片资源被放入了AssetsDemo.bundle中。 这样的配置，显然在常规情况下，xib是没法找到图片并显示的。但是有一种有缺陷的用法可以勉强解决这个问题，那就是直接把png图片打包到AssetsDemo.bundle中，然后在xib中将图片名改为AssetsDemo.bundle/图片名。这样做会导致xib编辑时无法正确的显示图片，也没法使用xcassets目录来存储图片，并且会导致一些系统优化无法生效。不推荐这样使用 将xib和图片都放入resources在podspec的写法如下： 12s.source_files = 'AssetsDemo/Classes/**/*.swift's.resources = 'AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png,xib&#125;' 网上有说法使用resources来指定资源，被指定的资源只会简单的被 copy到目标工程中（主工程），资源的使用会简化，但是会与主工程同名资源文件产生冲突。但是在Xcode13和pod 1.11.2版本下，实测不是这样的。官方的文档也不是这样说的Podspec Syntax Reference v1.11.2，它是分静态库和动态库场景，静态库才有这类问题。 上述配置运行后会生成这样的framework结构： 从上图可以看到，资源被直接放入了所在的framework，另外查看主工程的包文件，是没有这些资源的。综上所述，可以得出结论，动态库中，resources指定的资源，会被直接copy到framework，不会与主工程资源文件冲突。 另外，由于xib文件TestTableViewCell.nib和Assets.car在同一个目录下，xib可以直接从Assets.car中找到图片资源并正确展示 在主工程中打开这个xib文件，如果主工程中有同名资源，那么编辑时会优先显示主工程的资源，但是实际运行时还是这个pod的资源。 这里xib可以放入source_files和resources，效果是一样的 将xib和图片都放入resource_bundles在podspec的写法如下： 1234s.source_files = 'AssetsDemo/Classes/**/*.swift's.resource_bundles = &#123; 'AssetsDemo' =&gt; ['AssetsDemo/&#123;Assets,Classes&#125;/**/*.&#123;xcassets,png,xib&#125;']&#125; 上述配置运行后会生成这样的framework结构： 从上图可以看到，xib文件TestTableViewCell.nib和Assets.car在同一个目录下，xib可以直接从Assets.car中找到图片资源并正确展示。其中，test1图片虽然没有以xcassets格式引入，但是也能直接找到并正确展示。 总结综上所述，我们可以得出一个原则：尽量让xib和xcassets与图片在同一个目录下，这样xib可以直接找到图片并正常展示。 关于resources和resource_bundles，在动态库下，他们最终效果差不多，只是resource_bundles会把资源封装在bundle中，使用的时候会稍微麻烦一点： 1234567891011// 使用resources的情况：let myBundle = Bundle(for: TestTableViewCell.self)tableView.register(UINib.init(nibName: \"TestTableViewCell\", bundle: myBundle), forCellReuseIdentifier: \"cell\")// 使用resource_bundles的情况：let myBundle = Bundle(for: TestTableViewCell.self)let path = myBundle.path(forResource: \"AssetsDemo\", ofType: \"bundle\")!let assetsBundle = Bundle.init(path: path) tableView.register(UINib.init(nibName: \"TestTableViewCell\", bundle: assetsBundle), forCellReuseIdentifier: \"cell\") 至于静态库，则推荐使用resource_bundles了。综合来看，不管是静态库还是动态库，都推荐使用resource_bundles来引入所有的资源，因为resources方式在静态库和动态库场景，资源的使用方法差异太大，而resource_bundles各场景是一致的。 至于source_files，它只能引入代码和xib文件，不支持引入图片等其它资源。不建议用source_files方式引入xib，如果一定要使用，要注意避免出现xib中图片无法加载的问题。 参考资料 Podspec Syntax Reference v1.11.2 关于 Pod 库的资源引用 resource_bundles or resources","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"iOS组件化避坑心得","date":"2022-01-24T13:57:48.000Z","path":"2022/01/24/iOS组件化避坑心得/","text":"为什么要组件化组件化一般是把工程分层拆成不同的组件，以达到解耦，模块复用，便于单元测试，编译速度优化等效果，最终目的是为了提高开发质量和效率。当然，组件化是有一定成本的，在组件化之前要考虑清楚当前的项目情况是否适合组件化，收益能否覆盖开发成本。规模较小，模块没太多复用需求的项目，就没必要进行组件化。 组件化如何分层组件化之前，先要对项目进行分层，以我们现在的项目为例： 分层后，一般使用Cocoapods来封装组件，通过路由来进行不同业务模块间的解耦调用。其中系统框架层，公有pod库层是本来就有的。其它层的拆分逻辑分别是： 自有公有组件层（公有pod）：这一层的pod都是推到公有仓库，和业务是没有任何耦合的的，就是用于放开源的组件。 私有组件层（私有pod）：这一层的组件都有自己的私有git仓库，通过私有git仓库和私有索引库来进行管理，根据实际业务场景，这一层可能还会再进行分层。一般放一些项目中比较基础和通用的逻辑，例如配置信息管理，埋点管理，数据存储这些。 本地组件层（本地pod）：这一层放业务模块，是app呈现给用户的一个模块的整体封装，例如我的模块，首页模块这类。它的修改会非常频繁，日常的业务开发大部分都是在这一层，所以使用本地pod的方式，不会单独创建git仓库，与主工程共用一个git仓库进行管理。 cocoapods只支持在Podfile中以path方式依赖pod，在podspec中是不支持的，所以本地pod最多只能有一层。（你也可以写插件支持多层） 这样分层后，当有新的业务需求时，我们只需要创建一个本地pod，写入pod依赖，就可以快速的进入业务开发状态，因为没有其它模块的干扰，编译和调试的速度会得到极大的提升，同时也避免了模块之间的耦合。 使用Cocoapods制作不同类型的组件通过上述内容，可以知道有三种类型的组件：公有pod，私有pod,本地pod。不管什么类型，都建议使用pod lib create PodName命令来创建组件，在它生成的组件模版基础上，可以很方便的进行开发。 公有Pod公有pod是面向所有开发者的，需要尽量保证它的可用性和稳定性。如何发布公有pod这里不做说明，可以参考官方文档：Getting setup with Trunk。一些公司提供的商用公有pod，连pod验证命令pod lib lint都无法通过，这个是不应该的，最容易出现的问题就是编译错误，因为它会校验各个场景，而很多pod开发者却只保证自己的pod在常见场景可用。常见的报错有： 12345&#x2F;&#x2F; 报错1: ld: symbol(s) not found for architecture i386&#x2F;&#x2F; 报错2:building for iOS Simulator, but linking in object file built for iOS, file &#39;you path&#39; for architecture arm64 这里的i386是32位模拟器的架构，arm64是m1机型上的模拟器架构，出现这种问题一般是pod中引入了lib或者framework静态库，而这些库不支持这些架构。现在都2202年了，微信的最低支持版本都到了12.0，所以请大胆将pod库的deployment_target参数设置为12.0，这样就不会进行i386架构的验证。 而对arm64模拟器架构的支持，最好是将静态库重新打包成.xcframework格式并支持arm64模拟器架构，不然会导致m1设备的使用者只能以Rosetta模式在模拟器上运行项目。具体可以看我之前写的博文M1设备的Xcode编译问题深究 ，如这些静态库是第三方提供的，无法重新打包支持arm64模拟器架构，则可以进行如下设置避免报错： 1234# 因为依赖的静态库不支持模拟器arm64架构，设置当前这个pod不支持arm64， 以避免pod lib lint无法通过s.pod_target_xcconfig = &#123; 'EXCLUDED_ARCHS[sdk=iphonesimulator*]' =&gt; 'arm64' &#125;# 单纯设置pod_target_xcconfig只是设置当前这个pod不支持arm64， 这里把这些pod的上层设置为不支持arm64，兼容这种问题s.user_target_xcconfig = &#123; 'EXCLUDED_ARCHS[sdk=iphonesimulator*]' =&gt; 'arm64' &#125; 对于公有pod，负责任的做法是没有任何错误和警告后再进行发布，如果由于各种客观原因，实在无法去除警告，可以加入--allow-warnings参数来推送：pod trunk push [NAME.podspec] --allow-warnings。如果添加--skip-import-validation参数来逃避验证，则显得有些不负责任了。 另外，在CocoaPods的1.8版本，将默认的spec repo设为了CDN源，以提高pod的速度。刚发布的公有pod版本，可能要几个小时后才能被同步到CDN源，导致刚发布时调用pod install --repo-update没法找到新发布的pod库，这时可以通过指定源来解决这个问题，样例如下： 1pod &#39;你的公有pod&#39;, :source &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs&#39; 当然，CDN源同步后要记得改回。 私有Pod私有pod一般通过私有repo来进行管理，这样才方便做版本管理和使用缓存。私有repo创建命令是pod repo add REPO_NAME SOURCE_URL，其中SOURCE_URL就是私有repo的git地址。创建私有repo后，通过pod repo push REPO_NAME SPEC_NAME.podspec命令来发布私有pod到私有repo。需要注意的是私有pod和公有pod的发布命令并不一样，分别是： 1234# 公有pod发布命令pod trunk push SPEC_NAME.podspec# 私有pod发布命令pod repo push REPO_NAME SPEC_NAME.podspec 发布后，需要在Podfile中加入私有repo源，才能找到私有pod并安装成功。 12345# --- Podfile文件 --# 指定私有sourcesource 'https://youhost.com/YouPrivateRepo.git'# 指定公有source，source 'https://github.com/CocoaPods/Specs.git' 这些固定流程不做过多说明，具体内容可以查看官方文档:Private Pods 如果私有pod中依赖了非公有源的pod，在pod lib lint时会出现这类报错： 1ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for &#96;AlicloudHTTPDNS&#96; depended upon by &#96;DTHttpDns&#96; 这时根据提示调用pod repo update后也是无效的，这类问题可以通过指定sources来解决，以如上报错为例，它依赖的AlicloudHTTPDNS是阿里的源：https://github.com/aliyun/aliyun-specs.git，设置sources后则可以验证通过: 12# 可以通过逗号分隔，添加多个不同的source。(--sources='a_source,b_source')pod lib lint DTHttpDns.podspec --allow-warnings --sources='https://github.com/aliyun/aliyun-specs.git' pod repo push也可能会出现上述报错，但是它的逻辑稍有不同，它会从你本地的repo列表中去查找pod依赖，找到则不会报错。而pod lib lint在没有指定sources时，只会从默认的源去找。 本地Pod本地pod与主工程一起被同一个git仓库管理，不需要单独进行版本管理，也不需要push，而是在Podfile中直接以path的方式进行引入，样例如下： 12# --- Podfile文件中 --pod '你的本地pod', :path =&gt; '../本地pod路径/你的本地pod目录名' Pod组件中使用资源的坑在pod中，经常会出现需要使用图片，xib，json文件等资源的场景，建议使用resource_bundles来配置使用这些资源，以名为DTVideo的pod库为例： 1234# -- DTVideo.podspec 文件中--s.resource_bundles = &#123; 'DTVideoAssets' =&gt; ['DTVideo/&#123;Assets,Classes&#125;/**/*.&#123;xib,xcassets&#125;'] &#125; 这样配置后，cocoapods会自动把这些资源打包成一个名叫DTVideoAssets的bundle文件，在pod中使用这些资源的方式会发生一些改变。假如这个pod中有一个类VideoPlayListCell.swift，那么我们可以创建辅助方法： 1234567891011121314151617struct DTVideoCommon &#123; static func assetsBundle() -&gt; Bundle? &#123; let myBundle = Bundle(for: VideoPlayListCell.self) let path = myBundle.path(forResource: \"DTVideoAssets\", ofType: \"bundle\") guard let path = path else &#123; return nil &#125; let assetsBundle = Bundle.init(path: path) return assetsBundle &#125; static func imageWith(named name: String) -&gt; UIImage? &#123; let assetsBundle = assetsBundle() let image = UIImage.init(named: name, in: assetsBundle, compatibleWith: nil) return image &#125;&#125; 加载图片时： 12let image = DTVideoCommon.imageWith(named: \"video_play_max_nor\")imageView.image = image 使用xib时： 12let cellNib = UINib.init(nibName: cellIdentifier, bundle: DTVideoCommon.assetsBundle())tableView.register(cellNib, forCellReuseIdentifier: cellIdentifier) xib文件中设置Module名的坑xib文件中有Module设置，如果是在工程中创建的，那么它默认是勾选上inherit Module From Target，当将这个文件移动到pod中时，它的Module名就被设置成了默认名，即bundle名，这样会导致创建这个cell的时候报错： 1Terminating app due to uncaught exception &#39;NSUnknownKeyException&#39;, reason: &#39;[&lt;UITableViewCell 0x7fd3eba23d60&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key you_error_key.&#39; 错误设置图示如下： 正确的设置是不要勾选inherit Module From Target，并且在Module栏输入正确的Module名。 当然你也可以空着，不输入Module名，但是这样需要修改VideoPlayListCell的类名： 1234@objc(VideoPlayListCell) // Module栏空着情况下，必须添加这行class VideoPlayListCell: UITableViewCell &#123; // ... 代码省略&#125; 如果不使用@objc(VideoPlayListCell)修改类名，那么会出现上面一样的报错，所以还是建议输入正确的Module名 关于modulecocoapods现在默认会开启pod库的module选项，所以没有必要在podspec中配置：&#39;DEFINES_MODULE&#39; =&gt; &#39;YES&#39;，module对头文件的引入和混编做了很大的优化，在引入其它组件的时候，建议以@import或者#import &lt;A/A.h&gt;的方式引入，其中#import &lt;A/A.h&gt;会最终转换为@import的方式。 现在使用pod库，以#import &quot;XXX&quot;和#import &lt;XXX&gt;的方式引入，Xcode都没有补全提示了，只有@import方式有。 如果想对module做更多的了解，建议看这篇博文：从预编译的角度理解Swift与Objective-C及混编机制，这篇博文写的非常好，内容也很长，阅读完需要一两个小时。后面的内容很多是对篇博文的部分总结和回顾，再次感谢这篇博文的作者。 pod库中swift与Objective-C的混编问题当Swift和Objective-C文件同时在一个App或者Unit Test类型的Target中，不同类型文件的API寻找机制如下： 这个和pod没有关联，是主工程的混编用法。 当Swift和Objective-C文件在不同Target中，例如不同Framework中，不同类型文件的API寻找机制如下： 图示的module.modulemap指的是需要import不同framework的module，例如Apod中的swift文件需要引用Bpod中的.h/.m文件，需要：import B 当Swift和Objective-C文件同时在一个Target中，例如同一Framework中，不同类型文件的API寻找机制如下： 这代表在同一个pod库中，不需要做任何处理，swift就可以直接调用库中的oc代码。但是oc想调用库中的swift代码，则需要导入固定格式的头文件，如：#import &lt;DTVideo/DTVideo-Swift.h&gt;，其中DTVideo就是这个pod库的module名。另外还有两个点需要注意： swift中必须是声明为public或者open权限的才能被同一个pod中的oc代码或者外部调用。 如果想在pod外部创建它某个swift类的子类，那么这个swift类必须声明为open权限 pod中swift使用struct的坑struct默认生成的初始化方法是internal级别的，例如： 1234567public struct TestStruct &#123; let key: String&#125;func test() &#123; TestStruct(key: \"aaaa\")&#125; 它可以在pod里面调用，但是在pod外部被调用则会报错：&#39;TestStruct&#39; initializer is inaccessible due to &#39;internal&#39; protection level。需要手动创建它的public init方法。如： 1234567public struct TestStruct &#123; let key: String // 需要手动添加public init方法 public init(key: String) &#123; self.key= key &#125;&#125; 设置pod库的Public Headers和Privete Headers构建产物为Framework的情况下 根据podspec里的public_header_files字段的内容，将相应头文件设置为Public类型，并放在Headers中。 根据podspec里的private_header_files字段的内容，将相应文件设置为Private类型，并放在PrivateHeader中。 将其余未描述的头文件设置为Project类型，且不放入最终的产物中。 如果podspec里未标注Public和Private的时候，会将所有文件设置为Public类型，并放在Header中。 构建产物为Static Library的情况下不论podspec里如何设置public_header_files和private_header_files，相应的头文件都会被设置为Project类型。 在Pods/Headers/Public中会保存所有被声明为public_header_files的头文件。 在Pods/Headers/Private中会保存所有头文件，不论是public_header_files或者 private_header_files描述到，还是那些未被描述的，这个目录下是当前组件的所有头文件全集。 关于路由现在常见的路由方案有：URLRoute，Protocol-Class，Target-Action等。个人偏爱URLRoute，主要有两方面的原因： 第一是通用。URLRoute可以多端统一，例如运营配置一条推送，点击打开某个页面，对于运营方来说，统一配置固定规则的URL就可以了，每个端都一致。H5页面要打开某个Native页面，或者外部唤起，也是统一用URLRoute就可以了，不需要区分平台做不同操作。 第二是没法避开。例如URL Scheme，Universal Links这类，还是需要使用到URL。 而Protocol-Class，Target-Action这些方案，没法避免硬编码，只能说是URLRoute的一种补充。URLRoute本质上就是约定一个各端通用的协议，在各端内部对协议进行正确的解析和逻辑处理。封装好了之后，不管是外部还是内部的调用者，不需要关心任何细节和区分平台，只需要传入协议就可以。综上所属，推荐使用URLRoute。 关于脚本组件化后会多出很多重复简单的操作，例如一个私有pod的新版本发布，需要的流程有：git commit -&gt; 打tag -&gt; pod验证 -&gt; pod发布，这些都是可以通过编写脚本简化操作的，建议在组件化过程中多做这方面的工作。 后文现在市面上的组件化方案很多，各大公司各种高大上的落地方案。我在小公司的业务间隙，抽时间写的这篇简单的避坑心得，是对自己实践的整理和归纳，希望能帮到你。 参考资料 从预编译的角度理解Swift与Objective-C及混编机制 iOS 组件化 —— 路由设计思路分析","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"2021年终总结 - 时间一天天的流逝，最终留下了什么？","date":"2022-01-01T03:09:59.000Z","path":"2022/01/01/2021年终总结-时间一天天的流逝，最终留下了什么？/","text":"往年断断续续的有做过年终总结和年终计划，大多是象征性的做一做，好像是一个仪式。随着年龄的增大，责任越来越多，压力也越来越大。这让我开始思考：时间一天天的流逝，最终留下了什么？很多人被工作与生活裹携着前进，一直在低头赶路，却忘记了抬头看看方向和欣赏一下周围的风景，等到某一天才发现，身边已满是荆棘，寸步难行。而这个年终总结，就是我”抬头看路”的一部分。我会从个人成长，家庭，工作，业余生活来进行总结。 个人成长我自认为是一个爱学习的人，从事互联网行业以来，一直都是从事iOS的相关工作，除了iOS方向，我系统学习过Android，Python，React，JS，Go，Flutter等，浅尝即止的就不说了，每一项都投入了较多时间，在这些技术的学习高峰，估计能达到中级开发者的开发效率吧。但是随着时间的流逝，其中大部分都忘的差不多了，如果面试官问我相关问题，我大概率是答不出来的，重新去做相关事情也需要去温习才能想起，很多人可能也有类似的感觉。所以从今年开始，对这方面的思考越来越多。首先，每个人的精力是有限的，要定好自己的技术方向，在基本盘稳固，有余力的情况下再做其它方向的拓展。其次，要更高效及有效的学习。 定技术方向今年年初确定技术平台为iOS &amp; Flutter，技术目标为成为大前端和架构方面的专家。目标很宏伟，需要一步步实施，在iOS方面，主要做了这些： 完成李明杰老师《iOS底层原理班》视频课程的学习，并全程做笔记和总结。 完成李明杰老师《Swift编程从入门到精通》视频课程的学习，并全程做笔记和总结。 李明杰老师的视频质量很高，让我接触到很多新东西（毕竟都搞汇编去分析了），但是很多都是底层和比较冷门的内容，现在已经忘了很多了，通过视频学习是非常耗时的，可能对初学者或求职者性价比会高一些吧。以后对熟悉领域的巩固和深入，会优先选择文字而不是视频～ 在Flutter方面，主要做了这些： 完成了对个人项目《购房计算器》的改版 完成了一个Flutter外包项目并上架。 打造了自己的快速开发框架，整了个VSCode插件生成模版代码，对开发效率提高挺多。 现在对于Flutter的学习都是集中在应用层面，经过今年的学习和实践，现在已经可以用Flutter完成复杂的UI和需求，基本上原生能做的都能用Fluter做好，效率也更高。Flutter的劣势是做极致体验时干不过原生，原生项目嵌入Flutter的成本较高，对直播等这类场景不友好等，明年会把更多精力放入Flutter底层原理及它与原生交互部分，并做高质量的博文输出。 更高效及有效的学习今年的学习过程中，自己有犯一些错误，第一个是想尽快把学习在预定时间内搞完，牺牲掉了学习的质量。第二个是对自己自视太高，制定了不符实际的计划，最终导致计划烂在一次次的失败之中。在后半段，对学习思路进行了调整，改为以输出倒逼输入的模式，通过输出高质量的博文来进行学习。今年总共写了5篇博文，有3篇是12月份写的，其中一篇被老司机技术周报收纳并上了掘金社区的周榜，这对我是莫大的激励。还有就是尽量选择工作内容强相关的内容进行学习，会在工作中得到一次又一次的巩固。 关于家庭由于结婚很早，我现在是两个小孩的父亲，大的已经读小学了，是非常活泼好动的性格，在学校的表现和在家做作业的情况都让我和老婆苦恼。上半年尝试过各种办法无效后，我想出一个方案，规定每天在学校里不能扣分并在晚上八点半前完成全部作业，违反则罚站20分钟马步，如果连续违反则每次附加10分钟。为了避免小孩的逆反心理，我一起罚站并监督罚站纪律（子不教父之过），老婆检查并判定作业是否完成，执行半个月后取得了很好的成效，就是我的胳膊和腿差点废掉了。下半年，儿子班级换了班主任，完全不一样的管理风格，严格和认真程度高了不止一个量级，加上中间一段时间的松懈，儿子又暴露出来了很多问题，所以最近两个月又和老婆一起严抓习惯和学业，事情又逐步在往好的方向上发展。受益于今年没有什么加班，个人也很少去应酬，给家庭的时间较多，但是感觉自己做的还是不够好，带小孩是一场修行，期望明年在小孩问题上要更多的关注，更多的思考，更多的沟通，更认真的执行，给家人做更好的榜样。 关于工作由于公司的经营状况不佳以及裁员，上半年没什么工作任务，下半年公司则处在比较动荡的状态之中。这种状态下，业务需求不多，没有什么加班。中途试图在公司推进Flutter，我把公司现有App用Flutter重新进行了架构，完成了大部分基础组件的搭建，以及上层20%左右的业务内容。后面准备向同事推广，推进公司App的Flutter化，但是架不住裁员后都去复习面试题了。我想，年后，我也该去找工作了～ 业余生活我是一个路亚爱好者，由于工作和带小孩，没什么时间，经常在晚上小孩睡着后去河边甩几竿，或者周末早上三四点起床，钓到八九点回来，然后送小孩去上兴趣班。玩归玩，但是不能影响正事。今年钓得最爽的一次是在沩水2个小时钓了50条鳜鱼。在资江也钓了很多斑鳜，资江是鹅卵石河床，环境和风景一流，就算钓不到鱼也是一种美的享受，在青山与溪流之中，感受着那微风拂面和阳光，那是我”突然的自我”。 展望2022在新的一年，我要多做一些高质量的输出。期望家人都能健健康康，不求达到多高的成就，只希望能做更好的自己。最后就日常列一个新年flag吧： 最高优先级严格执行家庭管理和教育半年，给两个崽养成良好的行为习惯。 完成15编高质量的博文 做一个个人项目并日活1000+ 最后，一句话送给自己：永远不要高估自己短期内能做的事，也永远不要低估自己长期能做的事。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://blog.devlxx.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"使用swift懒加载需要注意的陷阱","date":"2021-12-27T09:00:10.000Z","path":"2021/12/27/使用swift懒加载需要注意的陷阱/","text":"修改老代码后，发现UITableView会在创建cell时闪退，原因是在调用dequeueReusableCell(withIdentifier:)创建cell时返回了nil。但是检查代码，确认在viewDidLoad注册了这个cell，按道理不应该返回nil。后面分析才发现，由于lazy var不是线程安全的，在碰到viewDidLoad的某个特殊调用时机时就会出现这个问题，而且代码可能在大部分场景正常运行，然后出现一些看起来莫名其妙的bug！ 样例我把问题代码简化后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class TestTableViewController: UIViewController &#123; /// 使用懒加载创建tableView lazy var tableView: UITableView = &#123; print(\"start init testLabel, isViewLoaded \\(self.isViewLoaded)\") let tableView = UITableView.init(frame: self.view.bounds) print(\"created tableView \\(tableView)\") tableView.delegate = self tableView.dataSource = self return tableView &#125;() override func viewDidLoad() &#123; super.viewDidLoad() print(#function) view.addSubview(tableView) print(#function, \"tableView \\(tableView) register cell\") // 注册cell tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\") &#125;&#125;extension TestTableViewController: UITableViewDataSource, UITableViewDelegate &#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 10 &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = self.tableView.dequeueReusableCell(withIdentifier: \"cell\")! cell.textLabel?.text = \"\\(indexPath.row)\" return cell &#125;&#125;// 调用方式如下@IBAction func showTestTableViewVC(_ sender: Any) &#123; let testVC = TestTableViewController.init() // 引起问题的关键代码 testVC.tableView.isScrollEnabled = false self.navigationController?.pushViewController(testVC, animated: true)&#125; 如果你已经一眼就看出了问题所在，那么就没有必要看下去了。如果你没有看出来，也不要着急，这个问题确实挺隐蔽的。上述代码运行后，会出现报错：TestTableViewController.swift:29: Fatal error: Unexpectedly found nil while unwrapping an Optional value。那么这个问题是怎么产生的类？ 问题是怎么产生的？首先我们要清楚两个知识点： lazy var懒加载不是线程安全的 在UIViewController中，成员变量view没有初始化及viewDidLoad方法被调用之前，只要调用了成员变量view，就会立即初始化view并调用viewDidLoad方法。 第二点有点隐蔽，例如在viewDidLoad方法调用之前调用self.view.bounds就会触发。 上述代码运行后的Log输出如下： 在调用let testVC = TestTableViewController.init()初始化控制器后，我们立即调用了testVC.tableView.isScrollEnabled = false，这个时候会进入tableView的懒加载部分： 12345678910111213141516171819lazy var tableView: UITableView = &#123; print(\"start init testLabel, isViewLoaded \\(self.isViewLoaded)\") // 注意，这里调用了self.view，会导致`viewDidLoad`被提前调用！ let tableView = UITableView.init(frame: self.view.bounds) print(\"created tableView \\(tableView)\") tableView.delegate = self tableView.dataSource = self return tableView&#125;()override func viewDidLoad() &#123; super.viewDidLoad() print(#function) view.addSubview(tableView) print(#function, \"tableView \\(tableView) register cell\") // 注册cell tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\")&#125; 我们先定义这次要创建的tableView为A。这部分懒加载代码由于错误的调用了self.view，导致self.view初始化和viewDidLoad方法被提前调用，此时成员变量tableView还没有被初始化完成，而viewDidLoad方法中又调用了tableView，由于lazy不是线程安全的，所以又递归进入了上述初始化tableView的逻辑，这个时候self.view已经被创建了，所以会初始化完成，我们定义这次创建的tableView为B，这个时候控制器持有的tableView对象是B，它会在viewDidLoad方法的这次调用中注册cell。上述逻辑跑完后，A才紧随其后完成创建，并替换B成为控制器的新成员变量，而且由于viewDidLoad已经被调用过了，在self.navigationController?.pushViewController(testVC, animated: true)方法调用后，viewDidLoad不会再被调用，所以A是没有注册cell的。 运行到这时，控制器持有了A，而控制器的view通过addSubview持有了它的子视图B，图示如下：其中B对象在viewDidLoad方法中注册了cell，而A对象并没有注册，所以在代理方法中创建cell时返回了nil，导致了crash。如果对这部分不理解，可以多看几遍代码和日志，理顺下调用流程。 crash位置代码如下： 1234567func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // self.tableView是对象A，它并没有注册cell。 // 代理方法传递过来的tableView是对象B，它注册了cell，直接使用它则不会crash let cell = self.tableView.dequeueReusableCell(withIdentifier: \"cell\")! cell.textLabel?.text = \"\\(indexPath.row)\" return cell&#125; 而这个问题的隐蔽性在于存在两个UITableView对象，如果在代理方法中不使用self.tableView而是使用代理方法传递过来的tableView，那么程序不会crash，而且显示正常。而后续会不会出现奇奇怪怪的问题，就完全看你的运气了。 当然这个问题埋的隐蔽性并不止于此，当外部不调用tableView属性时，例如不像样例代码那样调用testVC.tableView.isScrollEnabled = false，那么在viewDidLoad方法中会正常执行tableView的初始化，一切都是正常的。但是一旦哪位同事在外部调用了一次，那么潘多拉魔盒就打开了～ 解决方案要解决这种问题，需要我们有良好的编码规范。首先，要强化lazy不是线程安全的概念，在懒加载中只做这个变量初始化的事情，尽量避免其它变量及逻辑的混入。在UIViewController及其子类的懒加载逻辑中，避免对view的调用。我看很多人喜欢在懒加载逻辑中调用view.addSubView()或view.bounds，这是不太对的，因为在isViewLoaded为false的情况下，对view的调用就代表着viewDidLoad方法的提前调用，这让程序的逻辑变得有些混乱，除非你能保证在viewDidLoad之后调用这个属性。 其次，在编码过程中，要注意权限的控制，设计合适的接口，这样对使用者更友好，也能规避很多异常场景，当然这对开发者的要求较高，需要平常多加修炼和积累了。 关于OC另外需要注意的是，OC的懒加载也有同样的问题。但是OC可以优化写法避免出现这个问题，而Swift不行。 关键代码如下： 12345678910111213- (UITableView *)tableView &#123; if (!_tableView) &#123; &#x2F;&#x2F; 第一种用法：这样调用会出现异常&#x2F;&#x2F; _tableView &#x3D; [[UITableView alloc] initWithFrame:self.view.bounds]; &#x2F;&#x2F; 第二种用法：这样是正常的 _tableView &#x3D; [[UITableView alloc] init]; _tableView.frame &#x3D; self.view.bounds; _tableView.delegate &#x3D; self; _tableView.dataSource &#x3D; self; &#125; return _tableView;&#125; 上述代码中的第二种用法不会出现问题，是由于在_tableView.frame = self.view.bounds;这行代码才引入的self.view，此时_tableView已经有值，后续代码不会执行。 虽然没有问题，但是不推荐这样使用，因为它还是引起了viewDidLoad的提前执行。 参考资料 Swift - is lazy var thread-safe?","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"HTTP协议是怎么实现的？","date":"2021-12-23T06:35:23.000Z","path":"2021/12/23/HTTP协议是怎么实现的？/","text":"前言在上层应用开发中，HTTP协议可以说是最常见，使用最频繁的网络协议了。在网上也有非常多的文章进行解读，但是大部分都是讲解HTTP协议的内容和使用，很少有人讲HTTP协议是怎么实现的。网络协议可以涉及很大的广度和深度，不是一篇文章就能讲清楚的，我这里更多的是提供一个思路供读者来思考。本篇文章会基于iOS平台来进行说明，但是并不代表这篇文章只针对iOS开发，因为协议是跨平台的，其中涉及到的编程思想也是。本文会分四个部分进行讲解： 第一部分：数据是如何在网络上进行传输的。这部分主要让你对网络模型和各层协议有一个基础的了解，如果您对这部分比较了解，可以直接从第二部分看起。 第二部分：HTTP协议数据是如何转换为TCP数据收发的。 第三部分：HTTP协议中Request和Response的解析和相关逻辑处理。 第四部分：修改HTTP底层实现，完成自有需求。 数据是如何在网络上进行传输的数据遵循网络协议进行收发，讲到网络协议，就绕不开OSI模型和TCP/IP参考模型，它们有不同的层次划分，OSI模型分为7层，TCP/IP参考模型分为4层。网上有很多将TCP/IP参考模型映射到OSI模型的说法，由于TCP/IP参考模型和OSI模型不能精确地匹配，还没有一个完全正确，或者说权威的答案，一般认为的对应关系图示如下： HTTP协议属于最上层应用层，网络模型是比较抽象的，在实际编码时，上层应用的开发者一般只接触到应用层，开发者只需要把一个HTTP Reques丢入网络框架，请求完成后就会返回一个HTTP Response，但是它的底层是怎么实现的类？我们先看下图：从上图我们可以看到HTTP数据是如何在客户端与服务端之间交互的，网络模型虽然很复杂，但是从某个角度看，可以说是”套娃”，在RFC 1122中描述的沿着不同的层应用数据的封装递减图示如下：上图中最上层的Data数据代表应用层协议数据，在HTTP协议中，HTTP的request报文和response报文都包含有header，TCP和IP也都有header，它们通过层层”套娃”后发送。 现在我们对数据如何通过网络传输稍微有了一个整体的概念，但是细节是不清楚的。从上述内容中，可以看到，HTTP数据是转换为TCP数据进行传输，对于传输层及以下的内容在这里就不做说明，这里主要讲应用层的HTTP数据是如何通过传输层传输的，以及如何解析的。 HTTP协议数据是如何转换为TCP数据收发的一般来讲，各系统都会给用户提供HTTP网络框架，例如iOS的NSURLSession，在系统的HTTP网络框架之上，开发者社区又会开发出各种易用版本的封装，例如AFNetworking。对上层开发者来说，HTTP协议的使用一般就是一个框架封装好的Request对象，甚至只是一个URL，使用框架请求完成后，返回一个Response对象，它的底层实现是隐藏的。 我们都知道，计算机的底层是二进制，数据传输也不例外。要把Request对象从主机传输到服务器，那么必须把它转换为二进制，那么它是怎么转换的？又是怎么传输的？ HTTP协议是怎么转换成二进制的？网络框架的Request对象为了易用性，经过了层层封装，要传输出去，必须将它转换为二进制数据：Request对象 -&gt; 符合HTTP协议的Request字符串 -&gt; 二进制数据。 HTTP协议中的请求报文：响应报文： 按照图示请求报文格式，我们可以将Request对象转换为符合HTTP协议的字符串并转换为字节流。样例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// 创建NSURLRequestNSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"];NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];/// 将NSURLRequest转换为二进制数据（这里只针对POST和GET请求进行说明）+ (NSData *)httpRequestDataWithRequest:(NSURLRequest *)request &#123; NSMutableString * requestStrFrmt = [NSMutableString string]; NSURL * url = request.URL; NSString *requestURI = url.path; //解析请求行 if ([request.HTTPMethod isEqualToString:@\"POST\"]) &#123; if (!url.path || url.path.length == 0) &#123; requestURI = @\"/\"; &#125; &#125; else if ([request.HTTPMethod isEqualToString:@\"GET\"]) &#123; if (url.path.length &gt; 0 &amp;&amp; url.query.length &gt; 0) &#123; requestURI = [NSString stringWithFormat:@\"%@?%@\", url.path, url.query]; &#125; else if (url.path.length &gt; 0) &#123; requestURI = url.path; &#125; else if (url.query.length &gt; 0) &#123; requestURI = url.query; &#125; else &#123; requestURI = @\"/\"; &#125; &#125; [requestStrFrmt appendFormat:@\"%@ %@ HTTP/1.1\\r\\n\", request.HTTPMethod, requestURI]; if ([request.allHTTPHeaderFields objectForKey:@\"Host\"] == nil) &#123; [requestStrFrmt appendFormat:@\"Host: %@\\r\\n\", url.host]; &#125; //解析请求头 for (NSString * key in request.allHTTPHeaderFields.allKeys) &#123; [requestStrFrmt appendFormat:@\"%@: %@\\r\\n\", key, request.allHTTPHeaderFields[key]]; &#125; //解析请求数据（body） if ([request.HTTPMethod isEqualToString:@\"POST\"] &amp;&amp; request.HTTPBody) &#123; [requestStrFrmt appendFormat:@\"Content-Length: %@\\r\\n\", @(request.HTTPBody.length)]; //请求头以两个CRLF结束 [requestStrFrmt appendString:@\"\\r\\n\"]; NSData *headerData = [requestStrFrmt dataUsingEncoding:NSUTF8StringEncoding]; NSMutableData * requestData = [NSMutableData dataWithData:headerData]; [requestData appendData:request.HTTPBody]; return requestData; &#125; else &#123; //请求头以两个CRLF结束 [requestStrFrmt appendString:@\"\\r\\n\"]; return [requestStrFrmt dataUsingEncoding:NSUTF8StringEncoding]; &#125;&#125;/// 打印出NSURLRequest报文的文本数据NSData *data = [NSData httpRequestDataWithRequest:request];NSString *requestText = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];NSLog(@\"%@\", requestText); 调用通过上述代码，我们可以得到request报文的文本数据。样例： 12GET &#x2F; HTTP&#x2F;1.1Host: www.baidu.com response报文可以参考request报文进行分析，为了避免篇幅过长，这里就不再做说明了。 HTTP二进制数据是怎么传输的？在各操作系统中，通常会为应用程序提供一组应用程序接口，称为套接字接口（socket API），主要作用就是实行进程间通信和网络编程。大白话就是：套接字是用C语言写成的应用程序开发库，它就是一个库。 套接字中的网络套接字，包含有流式套接字（SOCK-STREAM），它使用TCP协议来实现字节流的传输。通过socket框架，将包含HTTP数据的TCP字节流发送给服务端，服务端通过socket框架拿到包含HTTP数据的TCP字节流后，根据HTTP协议进行解析，解析后又被服务端的HTTP网络框架返回，图示如下：上述图示只包含request报文部分，并不包含response报文部分，由于response报文的数据传输和这个并无太大区别，这里就不再做额外说明了。 HTTP协议中Request和Response的解析和逻辑处理看到这里，我们对HTTP实现应该有了较明朗的了解，但是这其中还是有一些细节需要补充。用过Socket的同学应该都知道，它基于TCP是流式传输，会有半包和粘包问题。一般通过对数据添加Header来解决这些问题。我们知道，HTTP数据包含两部分，分别是Header和Body，HTTP协议定义Header和Body之间包含两个CRLF，一个CRLF是一个回车加一个换行：\\r\\n。通过这个标识，我们可以从TCP流中把HTTP数据的Header分离出来。然后再解析出Header中的Content-Length字段，它就是body的长度，读取这个长度的内容，就可以把Body解析出来。 在HTTP/1.1版本，Body的解析还和Transfer-Encoding字段有关，这里就不讨论了。 当然HTTP协议不只是包含数据解析部分，还有很多逻辑控制部分，它的响应头和和请求头中有很多控制字段，例如缓存相关的Etag，Last-Modified等，和数据压缩相关的Content-Encoding，Accept-Encoding等。系统的网络框架实现了这些控制字段的逻辑，让用户可以开箱即用。 修改HTTP底层实现，完成自有需求。对HTTP上层的修改是很常见的，例如YTKNewwork就在HTTP协议之上，添加了自定义缓存逻辑，可以通过cacheTimeInSeconds方法来控制缓存时间。但是对HTTP底层的修改却比较少见，我对这部分的了解，是基于一个特殊需求。 我们都知道手机可以通过WiFi或者蜂窝网络通道来收发数据，一般情况下，同时连接WiFi和蜂窝网络时，路由会让流量只走WiFi通道。但是对于一些WiFi连接工具软件来讲，需要在无法上网的WiFi下进行数据获取，以满足WiFi认证上网的需求，这种情况下蜂窝网络是可以访问网络的，那么可以让HTTP请求不走默认的WiFi通道，通过蜂窝网络来请求数据吗？上层的HTTP网络框架是没有这个功能的，但是底层的socket框架却提供这个功能，它可以让数据无视路由，从特定接口收发。我们完全可以在socket之上，自己实现HTTP协议中request,response的解析和逻辑处理，以达成这个功能的支持。当然对HTTP协议的全量支持是无法承受的开发成本，但是满足自我需求的简单实现还是可以的。我把这功能封装成了一个框架：XXSocketReqeust，使用方式如下： 12345678_manager = [[XXSocketRequestManager alloc] init];NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@\"https://www.baidu.com\"]];/// 使用XXNetworkInterfaceCellular，这个HTTP请求会无视路由，强制走蜂窝网络通道进行请求。XXSocketDataTask *task = [_manager dataTaskWithRequest:request viaInterface:XXNetworkInterfaceCellular completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"error is :%@\\n response is %@\", error, response); NSLog(@\"responseObject: %@\", [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125;];[task start]; 感兴趣的同学可以下载看看。 后记很多时候网络协议是高冷的，通用的网络协议为了通用和满足各种需求，是非常复杂的。但是我们完全可以针对自己的业务自制协议，或者对协议进行魔改，以满足自我的需求，这其中的难度并没有你想象中的那么高。 参考资料 XXSocketReqeust 一篇让你彻底了解 http 请求报文和响应报文的结构 「查缺补漏」巩固你的HTTP知识体系 网络套接字 互联网协议套件 OSI 7层模型和TCP/IP 4层模型","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"网络协议","slug":"网络协议","permalink":"http://blog.devlxx.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"M1设备的Xcode编译问题深究","date":"2021-12-02T07:07:09.000Z","path":"2021/12/02/M1设备的Xcode编译问题深究/","text":"问题的由来在Apple发布M1芯片之前，一直使用Intel的芯片，没有出现什么问题。发布M1芯片后，由于两者架构的不同（M1是arm64架构，Intel是x86_64的架构），导致很多软件运行出现了问题。我们在M1机型中使用Xcode编译模拟器时，可能会碰到如下报错： 1ld: in youpath&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon(UMComBaseEvent.o), building for iOS Simulator, but linking in object file built for iOS, file &#39;&#x2F;Users&#x2F;mtgj&#x2F;Desktop&#x2F;TestArch1&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon&#39; for architecture arm64 或 12345ld: warning: ignoring file YoupPth&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;FMDB&#x2F;FMDB.framework&#x2F;FMDB, building for iOS Simulator-x86_64 but attempting to link with file built for iOS Simulator-arm64Undefined symbols for architecture x86_64: &quot;_OBJC_CLASS_$_FMDatabaseQueue&quot;, referenced from: objc-class-ref in SqflitePlugin.old: symbol(s) not found for architecture x86_64 这些报错，都是是由于项目中存在.a或.framework静态库导致的。以前，我们创建静态库时，会分别打包出一份针对真机（arm64）和模拟器的（x86_64），然后将这两份合并成一个包后引入项目中进行使用。在Intel机型上，真机上使用arm64指令，模拟器（x86_64）中使用x86_64指令，所以不存在问题。但是在M1机型上，模拟器是以arm64运行的，显然再以x86_64运行就会出现问题。 有同学可能会想到包中是有arm64指令（真机）的，拿给以arm64运行的模拟器使用不就可以了吗？ 实际上xcode底层并不是这样处理的，它真机就找真机的，模拟器就找模拟器的。 解决方案常用方案对于这类架构报错问题，网上的资料一般会告诉你两个解决方案： 以Rosetta模式运行Xcode。 修改Build Settings -&gt; Excluded Architectures选项，添加Any iOS Simulator SDK选项，并设置值为arm64。图示如下： 这两种方案都能解决编译问题，但是也都存在问题。 在iOS12及以后，不再支持iphone5及以下机型，而后续的机型都是arm64架构，所以这里不再对之前的armv6/armv7/armv7s/i386 等指令集进行说明。 Rosetta方案说明以Rosetta模式运行是M1机器上x86软件无法运行的解决方案，它会将x86指令转译成ARM指令运行，这种转译显然是存在性能损耗的，损耗大概在20%～30%，详情可参考文章：苹果换芯，成了开发者们的噩梦？，不到万不得已，不推荐使用这种方案。 Excluded Architectures方案说明修改Excluded Architectures选项也有它的问题。字面意思是排除架构的意思，我们设置在模拟器中排除arm64就能解决模拟器无法编译arm64的问题。 这样的设置能生效会让人有点费解，我们知道，在intel机型上，模拟器本来就是以x86方式运行的，排除arm64毫无影响。但是在M1机型上，模拟器是以arm64方式运行的，排除了arm64反而能跑，这不是把我的智商摁在地上摩擦么？，但是苹果就是这样干的，当在M1机型上，排除了模拟器的arm64架构后，模拟器还是会以arm64的方式运行，但是模拟器中的app是以x86的方式运行的，对苹果的这个骚操作我们不得不服。图示如下： 这种情况下，模拟器和应用会通过XPC进行通信，虽然理论上不会有问题，但通信时间会比较长，导致一些依赖计时器判断的逻辑会出问题，例如滑动手势，加速度的判断会出一些问题，导致模拟器里大部分情况下列表无法触发惯性滚动。 - by kem 其它问题有时候在Excluded Architectures选项中排除了模拟器的arm64指令，依然无法编译通过，那么一般是项目设置和cocoapods的设置不一致导致，设置为一致后一般可以解决问题。可以通过在Podfile中添加如下内容来解决： 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['EXCLUDED_ARCHS[sdk=iphonesimulator*]'] = \"arm64\" end endend 最优解通过上述内容，我们知道了问题的由来，它是由于项目中存在.a或.framework，它们提供的指令集不完整导致的。Apple对于这类问题，也提供了解决方案，请由我细细道来。 以Xcode13为例，在我们创建静态库时，选择真机编译出来的包只包含arm64指令，选择模拟器编译出来的会同时包含arm64和x86_64指令。我看一些网上的教程，教别人将模拟器部分的arm64移除，其实大可不必。因为要支持M1机器正常跑模拟器，模拟器必须同时包含arm64和x86_64指令。 2019年的WWDC，apple提供了一种新的框架封装格式XCFramework。简单理解就是以前使用lipo合并不同指令集的包，现在则使用新的指令合并成XCFramework格式。 打包成framework，格式如下： 12345678910111213141516171819202122232425$ tree Release-iphoneos/TestFramework.frameworkRelease-iphoneos/TestFramework.framework├── Headers│ ├── TestFramework.h│ └── TestManager.h├── Info.plist├── Modules│ └── module.modulemap└── TestFramework$ tree Release-iphonesimulator/TestFramework.frameworkRelease-iphonesimulator/TestFramework.framework├── Headers│ ├── TestFramework.h│ └── TestManager.h├── Info.plist├── Modules│ └── module.modulemap├── TestFramework└── _CodeSignature ├── CodeDirectory ├── CodeRequirements ├── CodeRequirements-1 ├── CodeResources └── CodeSignature 打包成XCFramework后，格式如下： 123456789101112131415161718192021222324252627$ tree TestFramework.xcframeworkTestFramework.xcframework├── Info.plist├── ios-arm64│ └── TestFramework.framework│ ├── Headers│ │ ├── TestFramework.h│ │ └── TestManager.h│ ├── Info.plist│ ├── Modules│ │ └── module.modulemap│ └── TestFramework└── ios-arm64_x86_64-simulator └── TestFramework.framework ├── Headers │ ├── TestFramework.h │ └── TestManager.h ├── Info.plist ├── Modules │ └── module.modulemap ├── TestFramework └── _CodeSignature ├── CodeDirectory ├── CodeRequirements ├── CodeRequirements-1 ├── CodeResources └── CodeSignature 从上述可以看出，XCFramework就是把两个不同指令集的framework放入了同一个文件夹(.xcframework)，并生成了一个配置文件Info.plist。这样生成的XCFramework就可以完美的解决M1机器无法编译模拟器的问题。 XCFramework的创建指令也很简单： 1234567891011# -- 针对.a --# 指令：xcodebuild -create-xcframework -library &lt;path&gt; [-headers &lt;path&gt;] [-library &lt;path&gt; [-headers &lt;path&gt;]...] -output &lt;path&gt;# 样例：xcodebuild -create-xcframework -library youpath/TestFramework.a -headers youpath/TestFramework -library youpath/TestFramework.a -headers youpath/TestFramework -output youpath/TestFramework.xcframework# -- 针对.framework --# 指令：xcodebuild -create-xcframework -framework &lt;path&gt; [-framework &lt;path&gt;...] -output &lt;path&gt;# 样例：xcodebuild -create-xcframework -framework Release-iphoneos/TestFramework.framework -framework Release-iphonesimulator/TestFramework.framework -output TestFramework.xcframework 解决M1机型无法编译模拟器的关键就是针对模拟器的包要同时包含arm64和x86_64指令集。如果使用只支持x86_64指令集的模拟器包，就算打包成XCFramework也会依然存在这个问题。 后记以现在的情况，很多第三方框架，并没有使用XCFramework，而项目中只要有一个框架没有支持模拟器的arm64指令，那么在M1机器上，模拟器只能以Rosetta模式运行应用，对这一块的普遍支持估计要等M1普及以后了。 参考资料 苹果换芯，成了开发者们的噩梦？ armv6、armv7、armv7s、armv8、armv64及其i386、x86_64区别 细说iOS静态库和动态库 关于Xcode11的XCFrameworks框架","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"Aspects框架的源码解读及问题解析","date":"2021-10-18T01:35:53.000Z","path":"2021/10/18/Aspects框架的源码解读及问题解析/","text":"前言在iOS日常开发中，对某些方法进行hook是很常见的操作。最常见的是使用Category在+load中进行方法swizzle，它是针对类的，会改变这个类所有实例的行为。但是有时候我们只想针对单个实例进行hook，这种方法就显得无力了。而Aspects框架可以搞定这个问题。它的原理是通过Runtime动态的创建子类，把实例的isa指针指向新创建的子类，然后在子类中对hook的方法进行处理，这样就支持了对单个实例的hook。Aspects框架支持对类和实例的hook，API很易用，可以方便的让你在任何地方进行hook，是线程安全的。但是Aspects框架也有一些缺陷，一不小心就会掉坑里面，我会通过源码解析进行说明。 源码解析我主要使用图示对Aspects的源码进行说明，建议参考源码一起查看。要看懂这些内容，需要对isa指针，消息转发机制，runtime有一定的了解，本文中不会对这些内容展开来讲，因为要把这些东西讲清楚，每一项都需要单独写一篇文章了。 主要流程解析 它第一个流程是使用关联对象添加Container，在这个过程中会进行一些前置条件的判断，例如这个方法是否支持被hook等，如果条件验证通过，就会把这次hook的信息保存起来，在方法调用的时候，查询出来使用。 第二个流程是动态创建子类，如果是针对类的hook，则不会走这一步。 第三步是替换这个类的forwardInvocation:方法为__ASPECTS_ARE_BEING_CALLED__，这个方法内部会查找到之前创建的Container，然后根据Container中的逻辑进行实际的调用。 第四步是将原有方法的IMP改为_objc_msgForward，改完后当调用原有方法时，就会调用_objc_msgForward，从而触发forwardInvocation:方法。 我对它的流程做了一个简化的图示，标有每个流程的序号，后面会对每个流程进行解析。流程如下： 图示中的取出对象类型，是指的调用hook的对象的类型，如果是实例对象，那么就走类路径；如果是类对象，则走元类路径；如果是kvo等实际类型不一致的情况，则走其它子类路径。 ①添加Container流程这个流程中，把hook的逻辑封装成Container，并使用关联对象进行保存。这个过程中会判断hook的方法是否被支持、判断被hook类的继承关系、验证回调block正确性等操作。具体图示如下： 关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123; ... aspect_performLocked(^&#123; // 加锁 // hook前置条件判断 if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123; // 用selector作key，通过关联对象获得Container对象。 AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); // 内部会判断block与hook的selector是否匹配，不匹配返回nil。 identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) &#123; // 添加identifier，包含了hook的类型和回调。 [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. aspect_prepareClassAndHookSelector(self, selector, error); &#125; &#125; &#125;); return identifier;&#125;static BOOL aspect_isSelectorAllowedAndTrack(NSObject *self, SEL selector, AspectOptions options, NSError **error) &#123; static NSSet *disallowedSelectorList; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; disallowedSelectorList = [NSSet setWithObjects:@\"retain\", @\"release\", @\"autorelease\", @\"forwardInvocation:\", nil]; &#125;); // 这里对不支持hook的方法进行过滤 NSString *selectorName = NSStringFromSelector(selector); if ([disallowedSelectorList containsObject:selectorName]) &#123; NSString *errorDescription = [NSString stringWithFormat:@\"Selector %@ is blacklisted.\", selectorName]; AspectError(AspectErrorSelectorBlacklisted, errorDescription); return NO; &#125; // dealloc只支持AspectPositionBefore类型下调用 AspectOptions position = options&amp;AspectPositionFilter; if ([selectorName isEqualToString:@\"dealloc\"] &amp;&amp; position != AspectPositionBefore) &#123; NSString *errorDesc = @\"AspectPositionBefore is the only valid position when hooking dealloc.\"; AspectError(AspectErrorSelectorDeallocPosition, errorDesc); return NO; &#125; // 判断是否存在这个方法 if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123; NSString *errorDesc = [NSString stringWithFormat:@\"Unable to find selector -[%@ %@].\", NSStringFromClass(self.class), selectorName]; AspectError(AspectErrorDoesNotRespondToSelector, errorDesc); return NO; &#125; // 这里禁止有继承关系的类hook同一个方法，代码量较多，不是关键内容，这里不贴出 if (class_isMetaClass(object_getClass(self))) &#123; ... &#125; return YES;&#125;/// AspectsContainer内部添加AspectIdentifier的实现。/// 这里可以看出对同一个方法的多次hook都会被调用，不会出现后面hook的覆盖前面的情况。- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123; NSParameterAssert(aspect); NSUInteger position = options&amp;AspectPositionFilter; switch (position) &#123; case AspectPositionBefore: self.beforeAspects = [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break; case AspectPositionInstead: self.insteadAspects = [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break; case AspectPositionAfter: self.afterAspects = [(self.afterAspects ?:@[]) arrayByAddingObject:aspect]; break; &#125;&#125; 从源码中可以看到，不支持的hook方法有[NSSet setWithObjects:@&quot;retain&quot;, @&quot;release&quot;, @&quot;autorelease&quot;, @&quot;forwardInvocation:&quot;, nil];。其中retain, release, autorelease在arc下是被禁用的，框架本身是hook了forwardInvocation:进行实现的，所以对它的hook也不支持。 dealloc只支持AspectPositionBefore类型，使用AspectPositionInstead会导致系统默认的dealloc操作被替换无法执行而出现问题。 AspectPositionAfter类型，调用时对象可能已经已经被释放了，从而引发野指针错误。 Aspects禁止有继承关系的类hook同一个方法，具体可以参见它的一个issue，它报告了这样操作会导致死循环，我会在文章后面再进行说明。 Aspects使用block进行hook的调用，涉及到方法参数的传递和返回值问题，所以其中会对block进行校验。 ②runtime创建子类iOS中的KVO就是通过runtime动态创建子类，然后在子类中重写对应的setter方法来实现的，Aspects支持对单个实例的hook原理与此有一些类似。图示如下：具体说明请查看源码中的注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 执行hookstatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123; NSCParameterAssert(selector); // 针对实例类型，会通过runtime动态创建子类。类类型则直接hook。 Class klass = aspect_hookClass(self, error); ...&#125;static Class aspect_hookClass(NSObject *self, NSError **error) &#123; NSCParameterAssert(self); Class statedClass = self.class; Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // 已经被hook过的类，直接返回 if ([className hasSuffix:AspectsSubclassSuffix]) &#123; return baseClass; // 是元类(MetaClass)，则代表是对类进行hook。（非单个实例） &#125;else if (class_isMetaClass(baseClass)) &#123; // 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__ return aspect_swizzleClassInPlace((Class)self); // 可能是一个KVO对象等情况，传入实际的类型进行hook。 &#125;else if (statedClass != baseClass) &#123; return aspect_swizzleClassInPlace(baseClass); &#125; // 单个实例的情况，动态创建子类进行hook. const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) &#123; subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) &#123; NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__ aspect_swizzleForwardInvocation(subclass); // 重写class方法，返回之前的类型，而不是新创建的子类。避免hook后，类型判断出现问题。 aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); objc_registerClassPair(subclass); &#125; object_setClass(self, subclass); return subclass;&#125; ③替换forwardInvocation:这部分就是把原有的forwardInvocation:替换为自定义的实现：__ASPECTS_ARE_BEING_CALLED__。源码如下： 12345678910static NSString *const AspectsForwardInvocationSelectorName = @\"__aspects_forwardInvocation:\";static void aspect_swizzleForwardInvocation(Class klass) &#123; NSCParameterAssert(klass); // If there is no method, replace will act like class_addMethod. IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); if (originalImplementation) &#123; class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); &#125; AspectLog(@\"Aspects: %@ is now aspect aware.\", NSStringFromClass(klass));&#125; 替换后的对应关系图示如下： ④hook方法交换IMP:图示如下： 第③步和第④步可能有些同学会感到疑惑，为什么要替换forwardInvocation以及为什么要将hook的方法的IMP替换为_objc_msgForward，这个和iOS的消息转发机制有关，可以自行查找相关资料，这里就不做说明了。需要注意的是有些框架也是通过iOS的消息发送机制来做一些操作，例如JSPatch，使用的时候需要注意，避免发生冲突。 被hook方法的调用流程当hook注入后，对hook方法进行调用时，调用流程就会发生变化。图示如下： 从上述解析过程中，我们可以看到Aspects这个框架是设计的很巧妙的，从中可以看到非常多runtime知识的应用。但是作者并不推荐在实际项目中进行使用： 因为Apsects对类的底层进行了修改，这种修改是基础方面的修改，需要考虑到各种场景和边界问题，一旦某方面考虑不周，就会引发出一些未知问题。另外这个框架是有缺陷的，很久没有进行更新了，我对它的已知问题点进行了总结，在下面进行说明。如果有未总结到位的，欢迎补充。 问题点基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。之前这样会出现死循环，后面作者进行了修改，对这个行为进行了禁止并加了错误提示。详见这个issue 123456789101112131415161718192021222324252627282930@interface A : NSObject- (void)foo;@end@implementation A- (void)foo &#123; NSLog(@\"%s\", __PRETTY_FUNCTION__);&#125;@end@interface B : A @end@implementation B- (void)foo &#123; NSLog(@\"%s\", __PRETTY_FUNCTION__); [super foo]; // 导致死循环的代码&#125;@endint main(int argc, char *argv[]) &#123; [B aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@\"before -[B foo]\"); &#125;]; [A aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@\"before -[A foo]\"); &#125;]; B *b = [[B alloc] init]; [b foo]; // 调用后死循环&#125; 我们都知道，super是从它的父类开始查找方法，然后传入self进行调用。 根据我们之前对源码的解析，在这里调用[super foo]后会从父类查找foo的IMP，查到后发现父类的IMP已经被替换为_objc_msgForward，然后传入self调用。 因为是传入的self，所以实际会调用到它自身的forwardInvocation:，这样就导致了死循环。 针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。这里通过代码进行说明，以Animal对象为例： 123456789101112131415161718192021222324252627282930313233@interface Animal : NSObject@property(strong, nonatomic) NSString * name;@end@implementation Animal- (void)testKVO &#123; [self addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; self.name = @\"Animal\";&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@\"observeValueForKeyPath keypath:%@ name:%@\", keyPath, self.name);&#125;- (void)dealloc &#123; [self removeObserver:self forKeyPath:@\"name\"];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [animal testKVO]; // 这里如果改为针对类进行hook，则不会存在问题，因为类hook修改的是Animal类，而实例hook修改的是NSKVONotifying_Animal类 [animal aspect_hookSelector:@selector(setName:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, NSString *name)&#123; NSLog(@\"aspects hook setName\"); &#125; error:nil]; // 这里会crash animal.name = @\"ChangedAnimalName\"; &#125;&#125; 异常原因分析图示如下： 上面是继承链和方法调用流程的图示，可以看出，_NSSetObjectValueAndNotify是被aspects__setName:调用的，_NSSetObjectValueAndNotify的内部实现逻辑是取调用它的selector，去父类查找方法，即aspects__setName:方法，而Animal对象并没有这个方法的实现，这就导致了crash。 与category的共存问题先用aspects进行hook，再使用category进行hook，会导致crash。反之则没有问题。样例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@interface Animal : NSObject@property(strong, nonatomic) NSString * name;@end@implementation Animal- (void)setName:(NSString *)name &#123; NSLog(@\"%s\", __func__); _name = name;&#125;@end@interface Animal(hook)+ (void)categoryHook;@end@implementation Animal(hook)+ (void)categoryHook &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [super class]; SEL originalSelector = @selector(setName:); SEL swizzledSelector = @selector(lx_setName:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125;- (void)lx_setName:(NSString *)name &#123; NSLog(@\"%s\", __func__); [self lx_setName:name];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [Animal aspect_hookSelector:@selector(setName:) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, NSString *name)&#123; NSLog(@\"aspects hook setName\"); &#125; error:nil]; [Animal categoryHook]; // 调用后crash：[Animal lx_setName:]: unrecognized selector sent to instance 0x100608dc0 animal.name = @\"ChangedAnimalName\"; &#125;&#125; 这个与__ASPECTS_ARE_BEING_CALLED__的内部逻辑有关，里面会对调用的方法添加前缀aspect__进行调用，以调用到原始的IMP，但是category hook后破坏了这个流程。图示如下： 根据上述图示，实际只有aspects__setName，没有aspects__lx_setName，导致找不到方法而crash 基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：123456789101112131415161718192021222324252627282930@interface Animal : NSObject- (void)testInstanceMethod;+ (void)testClassMethod;@end@implementation Animal- (void)testInstanceMethod &#123; NSLog(@\"%s\", __func__);&#125;+ (void)testClassMethod &#123; NSLog(@\"%s\", __func__);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [Animal aspect_hookSelector:@selector(testInstanceMethod) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook testInstanceMethod\"); &#125; error:nil]; [object_getClass([Animal class]) aspect_hookSelector:@selector(testClassMethod) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook testClassMethod\"); &#125; error:nil]; [animal testInstanceMethod]; // crash: \"+[Animal testClassMethod]: unrecognized selector sent to class 0x1000114a0\" [Animal testClassMethod]; &#125;&#125; 这样的调用在日常开发中非常正常，但是它会导致crash。它是由于aspect_swizzleClassInPlace方法中的逻辑缺陷导致的。 1234567891011121314static Class aspect_swizzleClassInPlace(Class klass) &#123; NSCParameterAssert(klass); // Animal类对象与Animal元类对象会得到同一个字符串。 NSString *className = NSStringFromClass(klass); NSLog(@\"aspect_swizzleClassInPlace %@ %p\", klass, object_getClass(klass)); _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) &#123; // 类对象和元类对象得到同一个className，这里后加入的会被错误的过滤掉。 if (![swizzledClasses containsObject:className]) &#123; aspect_swizzleForwardInvocation(klass); [swizzledClasses addObject:className]; &#125; &#125;); return klass;&#125; 从上述代码可以看到，它的去重逻辑只是简单的字符串判断，取Animal的元类和类名得到同一个字符串Animal，导致后添加的被过滤，当调用后被hook的方法后，执行_objc_msgForward，因为后hook的aspect_swizzleForwardInvocation被过滤了没有执行，所以找不到forwardInvocation:的IMP，导致了crash。 _objc_msgForward会出现冲突的问题内部是通过消息转发机制来实现的，使用时要注意，避免与其它使用_objc_msgForward或相关逻辑的框架发生冲突。 性能问题hook后的方法，通过原有消息机制找到IMP后，并不会直接调用。而是会进行消息转发进入到__ASPECTS_ARE_BEING_CALLED__方法，内部再通过key取出相应的Coantiner进行调用，相对于未hook之前，额外增加了调用成本。所以不建议对频繁调用的方法和在项目中大量使用。 线程问题框架内部为了保证线程安全，有进行加锁，但是使用的是自旋锁OSSpinLock，存在线程反转的问题，在iOS10已经被标记为弃用。 对类方法的hook，需要使用object_getClass来获取元类对象进行hook这个不是框架问题，而是有些同学不知道如何对类方法进行hook，这里进行说明。 12345678910@interface Animal : NSObject+ (void)testClassMethod;@end// 需要通过object_getClass来获取元类对象进行hook[object_getClass(Animal) aspect_hookSelector:@selector(testClassMethod) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook setName\");&#125; error:null];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"对独立开发的思考","date":"2021-03-01T04:20:36.000Z","path":"2021/03/01/对独立开发的思考/","text":"独立开发经历第一个小程序项目我在17年的时候买人生的第一套房，是一套二手房，当时对二手房的各项交易费用一知半解，感觉自己就像一头屠宰桌上的猪，任人宰割。刚好那个时候微信小程序开始兴起，基于学习兴趣和需求，做了一个计算购房费用的小程序（在微信上搜索“首付款计算器”可以看到）。做出来后找了一个中介朋友，让他以激活码的方式帮我销售，收入五五分成，他帮我销售了几份后反馈有的客户没法安装（微信版本异常），有的客户有异常问题（非技术问题）。那个时候刚好工作比较忙，又觉得整这些事情太麻烦了（收益低），就没有更新和维护这个项目了。 第二个跨平台项目在20年的时候，由于年龄的逐渐增长，开始考虑去扩展一些额外的收入点。那个时候刚好在学习Flutter，就想用Flutter对之前的项目进行重构，做市面上最专业的购房费用计算器。当时的初衷是想从开发到发布，系统的学习一项新技能，另外就是看能不能赚点钱。但是实际情况和我预想的有点偏差，我增加了很多预想之外的需求。 一开始只想支持长沙的新房和二手房费用计算，但是做到后面想支持北上广深，因为这意味着更大的市场。为了支持不同城市，我对计算层进行了重构，引入了词法分析，支持不同的城市根据配置数据进行费用计算（不同城市的费用不一样），而这又引入了新的问题，配置下发和更新需要接口提供支持。然后我决定用Go开发后台，我自学了Go的语法和Beego框架，然后又学习了Docker，编写了部署脚本，把后台部署在了自己购买的云服务器上面。 后面想到都有接口了，干脆开发一套用户体系，对计算结果进行收藏和管理吧，于是开发了用户体系，对计算层又进行了修改，支持修改和列表显示，加入了版本升级、用户反馈等常规功能。 这些对于技术人来说，都是轻车熟路，不熟悉的地方查查文档也能解决。最麻烦的地方在于不同城市的费用计算规则，一般人觉得购房就是一些税费什么的很简单，但是我当时是想做市面上最专业的购房计算器，需要支持住宅、商业的计算，然后购房者、卖房者有个人（非中国籍、中国籍）、公司（大公司、小公司）、机构等各种情况，实际上是非常复杂的。我伪装成购房者在各大购房平台咨询中介费用问题，但是有些问题中介也不清楚，还有些问题不同中介回复的不一样，最终没有办法，只有跑到当地的房管局进行咨询确认，所以最终这个项目只支持了长沙和深圳的费用计算。 项目完成后iOS端顺利发布到了AppStore，Android端在各大应用商店发布需要软著，后面就没有发了，自己通过云存储部署了一个简单的H5页面来进行Android端的分发。在这里不得不说AppStore的强大，在我没有做推广的情况下，还是有一定的下载量（付费下载），让我收回了购买Apple开发者账号的成本。 对独立开发的反思以上是我做项目的前期，但是我完全没有考虑清楚项目后期的事情，那就是维护和营销。在我们的工作中，经常接触到这两个词，也知道是什么意思，但是在自己的个人项目中，你对这两个词有可能会有完全不一样的理解。我开始思考自己这个项目的意义，是用于学习技术还是为了赚钱？是为了做一个好的产品还是为了炫技？ 所幸我看了一篇公众号文章和软件开发相关的一些思考，作者叫liuyubobobo，我很喜欢的一位开发者。文章中有一小段视频：97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？，我觉得自己就像是这个视频中的程序员，讲着一堆牛逼的技术术语，但实际上却不知道如何做好一个项目。后面经过思考，我发现自己犯了如下错误： 没有想清楚是要学习还是要赚钱。抱着又想学习又想赚钱的想法，两头都没有做好。 盲目的给项目引入了过多的技术，导致后续维护成本很高。个人开发者没有必要维护自己的后台，更没有必要维护一套自建的用户体系，使用对应平台的云接口，稳定，开发效率高。 进入了一个自己不熟悉的领域（房产），我需要学习新的知识，还要跟上数据更新的步伐，不停的去学习。我分析一些做的好的个人开发者，都是做的工具类的软件，不需要把精力花费在陌生领域的学习，可以把精力集中在打磨产品的体验方面。 选择以App的承载方式来做这个项目是错误的，微信小程序才是最好的方案。（给好几个朋友推荐，都是反问，你为什么不做成微信小程序类？） 总结做一个好的产品，应该从用户体验出发，去思考能给用户提供什么？能给用户带来什么？然后再倒推用什么技术，在人力与资源受限时，我们要学会借力于平台，使用稳定可靠的技术。让用户打开我们产品的时候，都会说：太好了，这就是我想要的！而不是坐在那里，想着自己有什么吊炸天的技术，然后怎么把它卖出去。另外关于营销，我觉得其中的学问是不亚于技术的，需要持续的学习和实践，像我17年的小程序项目那样，能找到一个专业的销售人员绑定在一起，对产品的销售是很有帮助的。 附录 个人项目下载地址 97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？ 和软件开发相关的一些思考","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"思考","slug":"思考","permalink":"http://blog.devlxx.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"Flutter定制上下拉刷新功能","date":"2020-07-09T06:45:44.000Z","path":"2020/07/09/Flutter定制上下拉刷新功能/","text":"技术选型项目中需要定制一个基于Gif图片的下拉刷新功能，调研发现Flutter支持上下拉刷新的框架很多，其中有两个比较有名的有flutter_easyrefresh和pull_to_refresh，两个框架功能都很强大，都能满足需求，其中flutter_easyrefresh在github的star更多，lib包大小为644KB，pull_to_refresh在pub.dev的评分更高，lib包大小为172KB，综合考虑后，选择基于pull_to_refresh来实现框架功能。 下拉刷新GIF图片的生成下拉刷新需要控制Gif图片的播放，所以需要引入组件flutter_gifimage，gifimage支持加载本地和网络的gif图片，但是不支持加载图片列表的方式来执行gif动画，所以我们需要将图片列表生成为gif图片（UI小姐姐只给了图片列表）。网上有很多网站可以生成gif，但是都有图片数量限制。 下载一个生成gif的软件来生成又显得很麻烦，我们选择使用Python的Pillow库来创建gif图片。Pillow是PIL的python3版本，功能强大，可以很好的完成需求。创建脚本如下： 12345678910111213141516from PIL import Image, ImageDrawdef gen_frame(path): png = Image.open(path).convert('RGBA') background = Image.new('RGBA', png.size, (255,255,255,0)) alpha_composite = Image.alpha_composite(background, png) return alpha_compositeimage_list = []im0 = gen_frame('refresh_images/Loading_00@2x.png')for i in range(1,57): path = 'refresh_images/Loading_0' + str(i) + \"@2x.png\" image_list.append(gen_frame(path))# 生成透明图片需要加两个个参数：transparency=0, disposal=2im0.save('GIF.gif', save_all=True, append_images=image_list, loop=0, duration=34, transparency=0, disposal=2) 上述脚本对Gif背景进行了处理，以生成一张透明背景的gif图片 Gif下拉刷新组件头部的实现pull_to_refresh中提供了抽象类RefreshIndicator与RefreshIndicator，与material提供的重名，所以需要隐藏。 import部分代码如下： 123import 'package:flutter/material.dart' hide RefreshIndicator, RefreshIndicatorState;import 'package:pull_to_refresh/pull_to_refresh.dart'; 最终下拉刷新的Header实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart' hide RefreshIndicator, RefreshIndicatorState;import 'package:flutter_gifimage/flutter_gifimage.dart';import 'package:pull_to_refresh/pull_to_refresh.dart';class GifHeader extends RefreshIndicator &#123; GifHeader() : super(height: 72.0, refreshStyle: RefreshStyle.Follow); @override _GifHeaderState createState() =&gt; _GifHeaderState();&#125;class _GifHeaderState extends RefreshIndicatorState&lt;GifHeader&gt; with SingleTickerProviderStateMixin &#123; GifController _gifController; @override void initState() &#123; //value可以理解成Gif图片里面的第几帧 _gifController = GifController( vsync: this, value: 0, ); super.initState(); &#125; @override void onModeChange(RefreshStatus mode) &#123; if (mode == RefreshStatus.refreshing) &#123; //min和max都可以理解成Gif图片里面的第几帧，这里表示低0帧到第44帧 _gifController.repeat( min: 0, max: 44, period: Duration(milliseconds: 2000)); &#125; super.onModeChange(mode); &#125; @override Future&lt;void&gt; endRefresh() &#123; return _gifController.animateTo(44, duration: Duration(milliseconds: 500)); &#125; @override void resetValue() &#123; // reset not ok , the plugin need to update lowwer _gifController.value = 0; super.resetValue(); &#125; @override Widget buildContent(BuildContext context, RefreshStatus mode) &#123; return GifImage( image: AssetImage(\"images/pull_refresh.gif\"), controller: _gifController, height: 72.0, ); &#125; @override void dispose() &#123; _gifController.dispose(); super.dispose(); &#125;&#125; 设置Gif的value（帧）时，不能超过Gif的最大帧数，不然超出的帧数是显示一个有颜色的空白页面 集成进入项目pull_to_refresh提供了全局的统一配置类RefreshConfiguration，用它来包裹MaterialApp则可以全局生效，代码如下： 123456789101112131415161718192021Widget build(BuildContext context) &#123; return RefreshConfiguration( headerBuilder: () =&gt; GifHeader(), // 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个 footerBuilder: () =&gt; ClassicFooter(), // 配置默认底部指示器 headerTriggerDistance: 72.0, // 头部触发刷新的越界距离 // springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9), // 自定义回弹动画,三个属性值意义请查询flutter api maxOverScrollExtent: 100, //头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性 maxUnderScrollExtent: 0, // 底部最大可以拖动的范围 enableScrollWhenRefreshCompleted: true, //这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true enableLoadingWhenFailed: true, //在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多 hideFooterWhenNotFull: false, // Viewport不满一屏时,禁用上拉加载更多功能 // 当列表无法充满全屏的时候，加载更多跟在列表后面 shouldFooterFollowWhenNotFull: (status) =&gt; true, enableBallisticLoad: true, // 可以通过惯性滑动触发加载更多 child: MaterialApp( title: 'Flutter Demo', home: HomePage(), ), );&#125; 全局配置好后，则可以在列表进行集成了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:my_flutter/message/notice_list_page/notice_ist_cell.dart';import 'package:my_flutter/message/notice_list_page/notice_list_model.dart';import 'package:pull_to_refresh/pull_to_refresh.dart';class NoticeListPage extends StatefulWidget &#123; @override _NoticeListPageState createState() =&gt; _NoticeListPageState();&#125;class _NoticeListPageState extends State&lt;NoticeListPage&gt; &#123; RefreshController _refreshController = RefreshController(initialRefresh: true); List&lt;NoticeListModel&gt; list = []; void _onRefresh() async &#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 2000)); // 这里可以添加逻辑判断，如果无更多数据：_refreshController.loadNoData(); // 如果加载失败： 设置_refreshController.refreshFailed() _refreshController.refreshCompleted(); setState(() &#123; list = _getList(); &#125;); &#125; void _onLoading() async &#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 1000)); // if failed,use loadFailed(),if no data return,use LoadNodata() _refreshController.loadComplete(); if (mounted) setState(() &#123; list.addAll(_getList()); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SmartRefresher( enablePullDown: true, enablePullUp: list.length &gt; 0, controller: _refreshController, onRefresh: _onRefresh, onLoading: _onLoading, child: ListView.builder( itemBuilder: (c, i) =&gt; NoticeListCell(model: list[i]), itemExtent: 100.0, itemCount: list.length, ), ), ); &#125; List&lt;NoticeListModel&gt; _getList() &#123; return [NoticeListModel(),NoticeListModel()]; &#125;&#125;","tags":[]},{"title":"使用Xcode模板加速及规范开发","date":"2020-06-29T07:26:16.000Z","path":"2020/06/29/使用Xcode模板加速及规范开发/","text":"前言：开发效率和质量是每位开发人员永恒的追求，而Xcode的模板功能可以帮助你更好的达成这个目标，更难能可贵的是它还能在一定程度上帮助你统一实现逻辑和开发规范。 为什么需要使用模板在日常开发中，经常会碰到开发类似功能的情况，我们可以使用面向对象编程的继承来对相同部分进行封装，利用多态来进行特定功能区分，这样可以提高开发效率和质量。当然也有函数式开发和面向协议编程等，但是万变不离其宗，大家都在提模块化，组件化，以提高开发效率、质量、可维护性等。但是不管使用哪种框架和编码方式，都不可能干掉所有的重复代码和重复逻辑，依然会存在很多复制、粘贴等重复操作。例如我们在项目基础框架之上实现两个列表模块A和B，那么A和B模块中大部分的代码文件都是类似的，里面的内容也都是类似的。 为了减少这些重复操作导致的效率低下，我们可以使用Dash或Gist等工具，创建代码片段，来快速的复制粘贴代码，但是这些只限定于单个文件内的文本编辑。如果你所做的项目对某一类功能的实现已经有了固定套路，例如一个常见的列表页面，包含下拉刷新、加载更多等功能，你选择了MVC或MVVM等架构模式，那么在单个项目内，每个列表页面的代码（在一个文件或多个文件中）将会大量相似，每次都要重复的创建类似的文件，写类似的实现。如果是多人开发，还可能会在大体框架基础下搞出好几套大同小异的代码来，而这样的害处是显而易见的。 如何使用模板加速开发？模板工具在软件开发中，要提高效率，就得把重复的工作交给电脑来做，电脑会做的又快又好。针对上面提到的问题，我们完全可以创建一套模板，然后通过脚本或者IDE来批量生成代码，生成代码后，只需要修改其中的少量代码就可以完成全部功能，这样就避免了大量的文件创建和代码复制粘贴操作，也避免了一些由于操作失误导致的bug，同时也避免了一些不同开发人员的不同实现逻辑的问题。 我了解到有两种实现方案： 介绍 | Gckit-CLI Xcode自定义模板 我刚开始是使用的Gckit-CLI工工具，但是发现Xcode原生支持自定义模板后，我转向了使用Xcode自定义模板，因为集成在IDE中使用起来更加的便捷。所以这里我只介绍Xcode自定义模板功能的使用，对Gckit-CLI感兴趣的可以去它的官网自行查看。 Xcode自定义模板的使用Xcode系统默认模板说明Xcode在创建项目或文件时，就是使用了Xcode自带的模板功能。 它包含iOS、watchOS、tvOS、macOS菜单，在iOS菜单下又分为Source、User Interface等类别，类别里面有Cocoa Touch Class、Swift File等模块，图示如下： 这些模板的路径位置如下： iOS 平台模版的位置：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates watchOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates tvOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates macOS 平台文件模版的位置：/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates 这里我们仅拿iOS平台模板来进行说明 我们看iOS平台模板的目录结构： 12345678├── File\\ Templates│ ├── Apple\\ Watch│ ├── Playground│ ├── Resource│ ├── Source│ └── User\\ Interface└── Project\\ Templates └── iOS Project\\ Templates是创建项目的模板，这里不做说明。File\\ Templates目录下的内容就是上面图示中iOS菜单下的内容，例如我们根据Source -&gt; Cocoa Touch Class的模板创建文件，会进入如下页面： Xcode模板页面的生成Cocoa Touch Class模板文件目录结构如下 123456789101112131415161718├── File\\ Templates│ ├── Source│ │ ├── Cocoa\\ Touch\\ Class.xctemplate # Cocoa Touch Class模板文件目录│ │ │ ├── NSObjectObjective-C│ │ │ ├── NSObjectSwift│ │ │ ├── TemplateIcon.png│ │ │ ├── TemplateIcon@2x.png│ │ │ ├── TemplateInfo.plist # 根据此文件生成页面和匹配模板目录│ │ │ ├── UICollectionReusableViewObjective-C│ │ │ ├── UICollectionReusableViewXIBObjective-C│ │ │ │ ├── UICollectionReusableViewObjective-C│ │ │ | │ ├── ___FILEBASENAME___.h│ │ │ | │ ├── ___FILEBASENAME___.m│ │ │ | │ ├── ___FILEBASENAME___.xib│ │ │ ├── ...├── ...│ ├── ...... 上述页面对应Cocoa Touch Class.xctemplate目录下的TemplateInfo.plist文件，这个页面是根据此文件生成的。 我们看下TemplateInfo.plist文件的内容（内容太多，只贴出部分，上面的注释是作者添加的）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182··· 省略部分 &lt;dict&gt; # 这里对应中间的子类输入控件 &lt;key&gt;Identifier&lt;/key&gt; &lt;string&gt;cocoaTouchSubclass&lt;/string&gt; &lt;key&gt;Required&lt;/key&gt; # 必须展示这个控件在页面上 &lt;string&gt;YES&lt;/string&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Subclass of:&lt;/string&gt; # 左边的说明文本 &lt;key&gt;Description&lt;/key&gt; &lt;string&gt;What class to subclass in the new file&lt;/string&gt; &lt;key&gt;Type&lt;/key&gt; # UI样式类型是class类型，可以输入值，也可以选择值 &lt;string&gt;class&lt;/string&gt; &lt;key&gt;Default&lt;/key&gt; # 默认选择的值是NSObject &lt;string&gt;NSObject&lt;/string&gt; &lt;key&gt;FallbackHeader&lt;/key&gt; &lt;string&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/string&gt; &lt;key&gt;Values&lt;/key&gt; # 可选择的列表 &lt;array&gt; &lt;string&gt;NSObject&lt;/string&gt; &lt;string&gt;UIView&lt;/string&gt; &lt;string&gt;UIViewController&lt;/string&gt; &lt;string&gt;UITableViewController&lt;/string&gt; &lt;string&gt;UITableViewCell&lt;/string&gt; &lt;string&gt;UICollectionViewController&lt;/string&gt; &lt;string&gt;UICollectionViewCell&lt;/string&gt; &lt;string&gt;UICollectionReusableView&lt;/string&gt; &lt;/array&gt; &lt;key&gt;Suffixes&lt;/key&gt; # 输入匹配相关 &lt;dict&gt; &lt;key&gt;UIViewController&lt;/key&gt; &lt;string&gt;ViewController&lt;/string&gt; &lt;key&gt;UITableViewController&lt;/key&gt; &lt;string&gt;TableViewController&lt;/string&gt; &lt;key&gt;UITableViewCell&lt;/key&gt; &lt;string&gt;TableViewCell&lt;/string&gt; &lt;key&gt;UICollectionViewController&lt;/key&gt; &lt;string&gt;CollectionViewController&lt;/string&gt; &lt;key&gt;UICollectionViewCell&lt;/key&gt; &lt;string&gt;CollectionViewCell&lt;/string&gt; &lt;key&gt;UICollectionReusableView&lt;/key&gt; &lt;string&gt;CollectionReusableView&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;dict&gt; # 对应最底部的语言选择按钮 &lt;key&gt;Identifier&lt;/key&gt; &lt;string&gt;languageChoice&lt;/string&gt; &lt;key&gt;Required&lt;/key&gt; # 必须展示这个控件在页面上 &lt;true/&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Language:&lt;/string&gt; # 左边的说明文本 &lt;key&gt;Description&lt;/key&gt; &lt;string&gt;The implementation language&lt;/string&gt; &lt;key&gt;Type&lt;/key&gt; #UI样式是popup，弹出列表选择值 &lt;string&gt;popup&lt;/string&gt; &lt;key&gt;Default&lt;/key&gt; &lt;string&gt;Objective-C&lt;/string&gt; &lt;key&gt;Values&lt;/key&gt; &lt;array&gt; # 可选择的列表 &lt;string&gt;Swift&lt;/string&gt; &lt;string&gt;Objective-C&lt;/string&gt; &lt;/array&gt; &lt;key&gt;MainTemplateFiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Swift&lt;/key&gt; &lt;string&gt;___FILEBASENAME___.swift&lt;/string&gt; &lt;key&gt;Objective-C&lt;/key&gt; &lt;string&gt;___FILEBASENAME___.m&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;AllowedTypes&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Swift&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.swift-source&lt;/string&gt; &lt;/array&gt; &lt;key&gt;Objective-C&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.objective-c-source&lt;/string&gt; &lt;string&gt;public.objective-c-plus-plus-source&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt;··· 省略部分 模板的匹配用户在上述页面填写和选择了内容后，点击Next创建，就进入了模板匹配逻辑。假如用户在Subclass of选项中输入或选择了UICollectionReusableView，不勾选Also create XIB file勾选框，在Language选项中选择Objective-C，那么Xcode就会将这两个值按顺序拼接起来，得到文件名：UICollectionReusableViewObjective-C，然后会在TemplateInfo.plist文件所在目录中，搜索文件名为UICollectionReusableViewObjective-C的文件夹，如果有就取这个文件夹内模板文件来生成代码（有几个文件就生成几个）。如果没搜索到，就进行默认创建。 模板代码如何生成在上面流程中，已经匹配到了UICollectionReusableViewObjective-C模板，这个模板存在两个文件。 123UICollectionReusableViewObjective-C├── ___FILEBASENAME___.h└── ___FILEBASENAME___.m 其中___FILEBASENAME___.h的内容是： 1234567891011&#x2F;&#x2F;___FILEHEADER______IMPORTHEADER_cocoaTouchSubclass___NS_ASSUME_NONNULL_BEGIN@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___@endNS_ASSUME_NONNULL_END Xcode会使用用户在创建页面输入的类名来替换文件名中的___FILEBASENAME___，使用用户在Subclass of中输入的内容来替换___VARIABLE_cocoaTouchSubclass___，使用之前设置好的文件注释头来替换___FILEHEADER___，全部替换完成后写入文件输出，呈现给用户的就是创建文件完成。到此为止，通过模板创建文件整个流程全部走完了。 Xcode模板的相关配置和字段较多，可以根据里面的内容和展示的页面和行为来猜测每个字段的含义，然后依葫芦画瓢来学习Xcode模板是如何工作的。（如果您有找到这方面的文档，请评论区告诉我） 如何创建Xcode自定义模板自定义模板和系统模板的实现和使用基本是一样的。将自定义模板放在特定目录下时，Xcode就会将自定义模板加载出来。 修改模板后要重启xcode才能生效。 自定义模板的路径是：~/Library/Developer/Xcode/Templates(如果不存在Templates目录，就手动创建一个。)在此路径下，我们创建一个Custom目录，将系统模板中的Cocoa\\ Touch\\ Class.xctemplate目录复制到Custom目录下，这样在工程中新建文件就可以看到自定义的Custom目录及它下面的Cocoa\\ Touch\\ Class模板了： 到了这一步，你就会清楚自定义模板的套路了，剩下的就是依葫芦画瓢来实现自己的模板了。 我根据个人常用编程习惯，创建了一套模板，大家可以下载进行参考。下载地址： GitHub - xx-li/CustomTemplates: Xcode rapid development templates， 使用图示： 后文由于模板的匹配是目录匹配方式，所以每一个选项都会对应一个新的目录，例如一个2*2的选项，就会需要四个模板目录来进行匹配。当我们对模板进行功能细分时，就需要创建大量的模板，而每一个模板可能有大量内容是相似的，修改一个基础逻辑就要对所有的模板文件进行修改。为了解决这种问题，可以使用脚本来创建模板。 在上面的仓库中CustomTemplates，有用Python写的模板生成脚本。因为是用于个人项目，生成的代码缺乏基础框架支持，并不能直接使用，您可以参考编写适用于自己的脚本和模板。 参考资料iOS-VIPER-Xcode-Templates","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"如何创建一个Flutter Plugin","date":"2020-06-15T09:51:00.000Z","path":"2020/06/15/如何创建一个Flutter-Plugin/","text":"什么是pluginFlutter和Dart生态系统的软件包有两种模板，分别是packages和plugin，其中plugin包含Android、iOS平台特定实现，一般需要Flutter端与Android或iOS进行通讯交互（类比Hybrid或RN中JS与Native的交互），以实现特定功能。 创建plugin一般使用命令创建Plugin：flutter create —org com.example —template=plugin hello，执行命令后，会在当前目录下生成一个hello文件夹，里面是一个plugin的简单demo实现。iOS可以使用OC和Swift，Android可以使用Java和kotlin进行代码编写，命令默认使用swift及kotlin，如需修改，使用-i及-o命令。例如要创建一个使用OC及java的plugin，命令为：flutter create —org com.example —template=plugin -a java -o objc hello。 平台通道数据类型及编解码器在平台通道进行数据传输时，Flutter它会自动对这些值进行序列化和反序列化。 下表展示了如何在平台端接收 Dart 值，反之亦然： 创建一个样例Demo为了更好的说明流程，这里创建一个禁用截屏功能的plugin进行说明，plugin提供三个功能：全局添加水印、截屏监控、禁用截屏。其中全局添加水印为在Flutter当前页面栈的最上层添加一个半透、有水印、穿透触摸事件的全遮盖页面，为纯dart实现，不需要与平台进行交互； 截屏监控为当平台监听到截屏行为后，立即通知Flutter端，是一个持续通讯的过程；禁用截屏为Flutter端通知平台执行禁用操作（只支持Android平台）。此plugin已经开发完成并发布到官方pub，可以在GitHub - disable_screenshots下载并查看源码。 创建命令：flutter create --org com.devlxx --template=plugin disable_screenshots 执行命令后会生成如下目录：1234567891011├── disable_screenshots│ ├── CHANGELOG.md│ ├── README.md│ ├── android│ ├── disable_screenshots.iml│ ├── example│ ├── ios│ ├── lib│ ├── pubspec.lock│ ├── pubspec.yaml│ └── test pubspec.yaml：plugin的配置文件。里面有字段：name、description、version、homepage，这些均是字面意思，很好理解。另外有字段environment，指定插件的使用环境，最关键的是有一个flutter字段： 12345678910111213# The following section is specific to Flutter.flutter: # This section identifies this Flutter project as a plugin project. # The &#39;pluginClass&#39; and Android &#39;package&#39; identifiers should not ordinarily # be modified. They are used by the tooling to maintain consistency when # adding or updating assets for this project. plugin: platforms: android: package: com.devlxx.disable_screenshots pluginClass: DisableScreenshotsPlugin ios: pluginClass: DisableScreenshotsPlugin 这个字段说明了plugin支持的平台以及各平台的入口class，这个需要能一一对应。默认会给你创建好，不要随意修改这里及类名即可。 README.md : 项目说明。当发布到官方的pub.dev后，插件的Readme栏目内容即为此文件内容。 lib：pluginFlutter端的实现 ios：pluginios端的实现 android：pluginandroid端的实现 example：plugin的使用demo，可以运行此demo进行测试，另外demo里面也有README.md文件，当发布到官方的pub.dev后，插件的Example栏目内容即为此文件内容。 Flutter与iOS、Android通讯原理Flutter只是一个UI框架，与平台相关的功能只能由平台来原生实现，这就需要Flutter与原生进行相互通讯。它们通过PlatformChannel进行互相通讯，核心原理是： Flutter通过PlatformChannel将要传递的数据编码后，跨线程发送到宿主（iOS或Android） 宿主接收到PlatformChannel的消息后，执行原生API。 宿主执行完原生API后，将数据编码并原路返回给应用程序的Flutter部分图示如下： PlatformChannel有三种类型，分别是：BasicMessageChannel、MethodChannel、EventChannel。其中BasicMessageChannel接收一个MessageCodec作为其编解码器的实现，允许我们使用自定义的消息编解码进行异步消息传递，这里不对其做说明。 - `MethodChannel`：用于Flutter主动调用平台端的方法，并获得相应的返回值，例如获取系统电量、发起Toast等，可以说是“一次性”的调用。这里将通过它来告知平台端禁用截屏功能 - `EventChannel`，用于传递事件。例如Flutter要监听电量变化，平台端可以将监听到的电量变化情况持续的通过`EventChannel`传递给Flutter端。这里将通过它来`截屏监控`功能。disable_screenshots的禁用截屏功能实现（MethodChannel） Flutter端实现创建命令会在lib目录下生成一个disable_screenshots.dart文件，里面会有一个默认的MethodChannel实现样例，我们对其进行修改，修改后的核心源码如下： 12345// 1. 创建一个MethodChannelfinal MethodChannel methodChannel = const MethodChannel(\"com.devlxx.DisableScreenshots/disableScreenshots\");// 2. 通过MethodChannel将方法名和参数编码后发到平台端methodChannel.invokeMethod(\"disableScreenshots\", &#123;\"disable\": disable&#125;); Android端实现（kotlin）创建命令会在android目录下的/src/main/kotlin/com/devlxx/disable_screenshots/生成一个DisableScreenshotsPlugin.kt文件，其中实现禁用截屏的核心代码为： 1234567891011121314151617181920212223242526private fun onAttachedToEngine(applicationContext: Context, messenger: BinaryMessenger) &#123; this.applicationContext = applicationContext // 1. 创建一个MethodChannel this.channel = MethodChannel(messenger, \"com.devlxx.DisableScreenshots/disableScreenshots\") //handle指向了this，this必须实现onMethodCall方法 this.channel.setMethodCallHandler(this)&#125;// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) &#123; if (call.method == \"disableScreenshots\") &#123; var disable = call.argument&lt;Boolean&gt;(\"disable\") == true // 禁止截屏需要获取到当前的activity，如何获取到activity请自行查看源码，这里不做说明。 if (disable) &#123; activity.window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); println(\"禁用截屏\") &#125; else &#123; // 允许截屏 activity.window.clearFlags(WindowManager.LayoutParams.FLAG_SECURE) println(\"允许截屏\") &#125; // 调用后，Flutter端的invokeMethod会收到调用的结果，结果为一个空字符串 result.success(\"\") &#125; else &#123; result.notImplemented() &#125;&#125; iOS端实现。（iOS无法实现禁止截屏功能，这里仅做说明）创建命令会在ios目录下的Classes/下生成一个DisableScreenshotsPlugin.swift文件，其中实现禁用截屏的核心代码为： 12345678910111213141516171819202122232425262728293031public class SwiftDisableScreenshotsPlugin: NSObject &#123; public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建一个MethodChannel let methodChannel = FlutterMethodChannel(name: \"com.devlxx.DisableScreenshots/disableScreenshots\", binaryMessenger: registrar.messenger()) registrar.addMethodCallDelegate(instance, channel: methodChannel) &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterPlugin &#123; // 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里 public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) &#123; /* //iOS平台无法实现禁用截屏功能，这里仅做MethodChannel的使用说明 if call.method == \"disableScreenshots\" &#123; if let arg = call.arguments as? Dictionary&lt;String, Any&gt;, let disable = arg[\"disable\"] as? Bool &#123; if disable &#123; //禁用截屏 &#125; else &#123; //允许截屏 &#125; &#125; else &#123; print(\"【SwiftDisableScreenshotsPlugin】disableScreenshots 收到错误参数\") &#125; &#125; else &#123; result(FlutterMethodNotImplemented) &#125; */ result(FlutterMethodNotImplemented) &#125;&#125; disable_screenshots的截屏监控功能实现（EventChannel） Flutter端实现 1234567// 1. 创建EventChannelfinal EventChannel eventChannel = const EventChannel('com.devlxx.DisableScreenshots/observer');// 2. 监听平台端发来的事件_eventChannel.receiveBroadcastStream().listen((event) &#123; //平台端发来事件后会调用到这里&#125;); Android端实现 12345678910111213141516171819202122232425// 1. 创建EventChannelval eventChannel = EventChannel(messenger, \"com.devlxx.DisableScreenshots/observer\")// 2. handle指向了this，this必须实现onListen及onCancel方法。eventChannel.setStreamHandler(this)//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端override fun onListen(arguments: Any?, events: EventChannel.EventSink?) &#123; println(\"开始监听\") // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. ScreenShotListenManager为一个实现了监听截屏功能的Manager screenShotListenManager = ScreenShotListenManager.newInstance(applicationContext) screenShotListenManager.setListener &#123; imagePath -&gt; println(\"监听到截屏，截屏图片地址是：$imagePath\") // 6. 发送事件给Flutter端，告知监听到了截屏行为。 eventSink?.success(\"监听到截屏行为\") &#125; screenShotListenManager.startListen()&#125;// EventChannel被取消override fun onCancel(arguments: Any?) &#123; screenShotListenManager.stopListen() eventSink = null&#125; iOS端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SwiftDisableScreenshotsPlugin: NSObject &#123; var eventSink: FlutterEventSink? // 注册使用此插件 public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建EventChannel let channel = FlutterEventChannel( name: \"com.devlxx.DisableScreenshots/observer\", binaryMessenger: registrar.messenger() ) // 2. 设置handler为SwiftDisableScreenshotsPlugin，它必须实现onListen及onCancel方法 channel.setStreamHandler(instance) &#125; 6. 发送事件给Flutter端，告知监听到了截屏行为。 @objc func callScreenshots() &#123; eventSink!(\"监听到截屏行为\") &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterStreamHandler &#123; //3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端 public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? &#123; // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. iOS端实现截屏监听功能很简单，添加相应通知的监听即可。 NotificationCenter.default.addObserver( self, selector: #selector(callScreenshots), name: UIApplication.userDidTakeScreenshotNotification, object: nil) return nil &#125; // EventChannel被取消 public func onCancel(withArguments arguments: Any?) -&gt; FlutterError? &#123; NotificationCenter.default.removeObserver(self) eventSink = nil return nil &#125;&#125; 综合MethodChannel及EventChannel的三端实现来看，它们的使用还是比较简单的，对于开发者来说，挑战在于需要对三端都熟悉，并写出高质量的代码。在实际开发时，可以先用相应的开发者工具打开Example目录下的iOS及Android的项目，分别进行平台特定代码的开发、调试。当iOS及Android的平台代码编写完成后，再直接运行Example项目，进行Flutter端的功能开发及整体的调试。 全局添加水印全局添加水印不涉及平台端，为纯Flutter端实现。和常规的Flutter Dart代码编写没什么差异，这里不做说明，具体实现可以直接查看源码。 发布plugin当plugin的三端代码写好后，需要进行发布。plugin的发布非常简单，分为两步。第一步为检查项目是否OK，执行命令：flutter packages pub publish --dry-run后，会提示项目是否存在遗漏或者异常部分，如果有异常，根据提示进行修复即可。例如此项目在执行此命令时，有提示存在问题： 12Package validation found the following potential issue:* Your pubspec.yaml includes an &quot;author&quot; section which is no longer used and may be removed. 这个是Flutter的一个bug，默认创建的模板会包含一个author字段，但是却无法检查通过，将pubspec.yaml中的author字段删除即可检查通过。 检查通过后，可以执行第二步，执行命令：flutter packages pub publish进行发布。执行后，根据命令行会提示进行操作，需要注意的是有一个验证身份的操作，将命令行出现的网址在浏览器中打开，然后在此页面登录自己的Google账号，这样就会将这个plugin与你的账号进行绑定及身份验证，操作完成后即发布成功，命令行输出如下所示： 12345678910Do you want to publish disable_screenshots 0.0.1 (y&#x2F;N)? yPub needs your authorization to upload packages on your behalf.In a web browser, go to https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?access_type&#x3D;offline&amp;approval_prompt&#x3D;force&amp;response_type&#x3D;code&amp;client_id&#x3D;81fds5108-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A54755&amp;scope&#x3D;openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.emailThen click &quot;Allow access&quot;.Waiting for your authorization...Authorization received, processing...Successfully authorized.Uploading...Successfully uploaded package. plugin发布成功后并不能立即在官方的pub中搜到，它需要一段时间来处理，但是可以直接输入地址看到：https://pub.dev/flutter/packages?q=disable_screenshots 发布失败问题处理有时候会上传失败，提示Failed to upload the package。失败有可能是如下几种情况导致： 网络问题以为package是发布到google的服务器上，如果无法科学上网，肯定是会失败的。有些同学开启代理后依然无法上传成功，那么需要检查终端是否走的代理（终端默认不走代理）。此时需要给终端设置代理，也就是命令行代理。在mac平台中，在.bash_profile文件中加入如下代码： 1234567891011# 终端走代理function proxy_on()&#123; export http_proxy=http://127.0.0.1:1087 #填写您本地的实际代理端口 export https_proxy=http://127.0.0.1:1087 #填写您本地的实际代理端口 echo -e \"已开启代理\"&#125;function proxy_off()&#123; unset http_proxy unset https_proxy echo -e \"已关闭代理\"&#125; 重新打开终端后使用proxy_on，即可开启命令行代理。当然你也可以使用软路由科学上网等其他方式让所有程序都走代理。 镜像配置导致的问题很多同学使用pub的国内镜像来提高package拉取的速度，但是这些镜像设置会导致上传失败。 上传时将这些镜像配置关闭即可。 权限问题一直失败无法找到原因时，可以使用命令flutter packages pub publish --verbose显示详细log，以分析问题出现的原因。例如有时候会出现异常log：HTTP response 400 Bad Request for POST https://storage.googleapis.com，这个并不是网络问题导致的，而是权限问题，添加subo执行：sudo flutter packages pub publish --verbose 。 即可上传成功 其它情况如果上述操作都无法解决问题，可以去官方仓库的issue中查找答案或提问。 引用pluginplugin开发完后，我们可以选择多种方式将plugin提供给其它开发者使用： - 从本地路径引入 - 从Git仓库引入 - 从官方pub引入（需要先发布到官方pub） - 从指定源引入 本地路径引入plugin中的Example引入plugin就是通过本地路径方式引入的，这种方式很方便本地修改和调试，进入方式如下： 123456dependencies: flutter: sdk: flutter disable_screenshots: # 当前pubspec.yaml文件的上一级目录是plugin所在目录 path: ../ 从Git仓库引入顾名思义，直接从Git仓库拉取plugin，可以指定分支及路径。企业内部引用可以使用此种方式。样例如下： 1234567dependencies: flutter: sdk: flutter disable_screenshots: git: url: https://github.com/xx-li/disable_screenshots path: path/to/disable_screenshots #这里只做说明，实际disable_screenshots插件在根目录，不需要指定路径。 官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using packages - Flutter问题备忘 在老的flutter项目中，在iOS平台运行可能出现编译问题无法运行。这个是由于老的flutter项目里面没有使用到swift，所以没有briging文件，但是插件使用了swift，所以会编译失败，这种情况直接使用xcode在iOS项目中创建一个swift文件，会自动生成briding文件。 参考资料 GitHub - huiger/ScreenShotDemo: 🔥Android 手机应用内截屏, 截屏监听 Experimental: Create Flutter Plugin · flutter/flutter Wiki · GitHub Using packages - Flutter Developing packages &amp; plugins - Flutter Writing custom platform-specific code - Flutter Flutter 开发（14）：BasicMessageChannel 的使用 | 肥言肥语 dart - How to get Activity and Context in Flutter plugin - Stack Overflow https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.devlxx.com/tags/Flutter/"}]},{"title":"WKWebView的Cookie问题","date":"2018-05-08T11:46:41.000Z","path":"2018/05/08/WKWebView的Cookie问题/","text":"WKWebView与App不在同一个进程运行，不会从App的标准Cookie容器NSHTTPCookieStorage读取Cookie。跨进程的数据同步是一个麻烦及容易出现问题的场景，Apple在iOS11之前没有专门的API用于Cookie操作，在iOS11之后提供了WKHTTPCookieStore，但是自测发现存在一些奇怪的bug，无法使用，此部分后续会做说明。 网上关于WKWebView的Cookie同步我有查到多种方案，但是均无法解决跨域请求的Cookie问题，后来发现使用WKProcessPool可以解决跨域问题。 UIWebView为什么没有Cookie同步问题？网络请求完成后，会返回一个Response，如果Response中带有Set-Cookie字段，如：&quot;Set-Cookie&quot; = &quot;wifi_jsessionid=3aea4df28ab14b4e8714132cb911c15a; Domain=.pingan.com.cn; Path=/&quot;;，操作系统就会将此条Cookie信息写入到NSHTTPCookieStorage中 当UIWebView中有任意请求时（App进程中的请求也是一样），会去NSHTTPCookieStorage查找对应的Cookie信息，如果存在符合条件的Cookie信息，就会在请求头中带上此条Cookie信息。所以UIWebView进行跨域请求是没有任何问题的，只要NSHTTPCookieStorage有符合条件的Cookie信息即可带上。 WKWebView Cookie同步一般解决方案WKWebView上请求不会自动带上NSHTTPCookieStorage中的Cookie, 目前的主要解决方案是通过手动的方式直接在请求头上带上Cookie或者使用JS脚本进行Cookie注入： 在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:12345WKWebView * webView = [WKWebView new]; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://h5.qzone.qq.com/mqzone/index\"]]; [request addValue:@\"skey=skeyValue\" forHTTPHeaderField:@\"Cookie\"]; [webView loadRequest:request]; 此方法只适合解决简单针对性的场景。 通过document.cookie设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:12345678910WKUserContentController* userContentController = WKUserContentController.new;//不设定Domain，则会将domain默认设为请求的URL的DomainWKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @\"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';\" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];// again, use stringWithFormat: in the above line to inject your values programmatically[userContentController addUserScript:cookieScript];WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;webViewConfig.userContentController = userContentController;WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig]; 设定Cookie的辅助方法: 123456789101112- (NSString *)cookieString &#123; NSString *string = [NSString stringWithFormat:@\"%@=%@;domain=%@;path=%@\", self.name, self.value, self.domain, self.path ?: @\"/\"]; if (self.secure) &#123; string = [string stringByAppendingString:@\";secure=true\"]; &#125; return string;&#125; 因为Cookie注入无法跨域，此方法无法解决跨域请求的Cookie问题。 WKProcessPool同步方案解决跨域问题苹果开发者文档对WKProcessPool的定义是：A WKProcessPool object represents a pool of Web Content process. 通过让所有WKWebView共享同一个WKProcessPool实例，可以实现多个 WKWebView之间共享Cookie（session Cookie and persistent Cookie）数据。 既然可以多个WKWebView共享一个WKProcessPool实例，那么是不是可以先访问跨域的URL，将Cookie注入，不就得到了一个有跨域Cookie的WKProcessPool实例吗？再用此实例去访问原始的Web页面，不就可以解决跨域访问的Cookie问题了吗？ 经过实测，此方案是OK的。 样例如下： 可以创建一个单例管理WKProcessPool。如果Cookie更新了，更新WKProcessPool即可同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)updateProcessPool &#123; _isUpdatePooling = YES; if (_webView) &#123; _webView.navigationDelegate = nil; [_webView removeFromSuperview]; _webView = nil; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(willUpdateCookieWithPool)]) &#123; [_delegate willUpdateCookieWithPool]; &#125; //JS注入 NSString *jsStr = [self updateCookieScriptString]; //JS注入的domain（跨域注入会失败） NSURL *url = [NSURL URLWithString:@\"http://www.pingan.com.cn/\"]; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:jsStr injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; WKUserContentController* userContentController = WKUserContentController.new; [userContentController addUserScript:cookieScript]; WKWebViewConfiguration* configuration = WKWebViewConfiguration.new; configuration.userContentController = userContentController; configuration.processPool = self.pool; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration]; [[UIApplication sharedApplication].keyWindow addSubview:webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:3]; webView.navigationDelegate = self; [webView loadRequest:request]; _webView = webView;&#125;#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; LOG_INFO(\"WEB\", @\"didFinishNavigation :%@\", navigation); webView.navigationDelegate = nil; [webView removeFromSuperview]; @synchronized(self) &#123; for (void(^block)(WKProcessPool *pool) in _handlers) &#123; block(_pool); &#125; [_handlers removeAllObjects]; _isUpdatePooling = NO; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(didUpdateCookieWithPool)]) &#123; [_delegate didUpdateCookieWithPool]; &#125; &#125;#pragma mark -- (void)getCookieWithProcessPoolHandler:(void(^)(WKProcessPool *pool))handler &#123; if (_isUpdatePooling) &#123; [_handlers addObject:handler]; &#125; else &#123; handler(_pool); &#125;&#125; 由于WKProcessPool只能在初始化时传入有效，所以调用有一点特殊： 123456789101112131415161718@weakify(self);PAWFWebProcessPoolManager *cookieManager = [PAWFWebProcessPoolManager sharedManager];[cookieManager getCookieWithProcessPoolHandler:^(WKProcessPool * _Nonnull pool) &#123; @strongify(self); self.webView = [self creatWebViewWithPool:pool]; [self.view addSubview:self.webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:self.URL]; [self.webView loadRequest:request];&#125;];- (WKWebView *)creatWebViewWithPool:(WKProcessPool *)pool &#123; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init]; configuration.processPool = pool; CGRect frame = CGRectMake(0, 0, kScreenWidth, CGRectGetHeight(self.contentView.frame) - kGrwonStatusBarHeight); WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:configuration]; wkWebView.navigationDelegate = self; return wkWebView;&#125; WKHTTPCookieStore同步cookie问题WKHTTPCookieStore，存在一些奇怪的bug，完全无法使用，已知问题如下： 无法正常写入cookie的Bug：12345678910111213141516NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@\"wifi_jsessionid\" forKey:NSHTTPCookieName];[cookieProperties setObject:jsessionid forKey:NSHTTPCookieValue];[cookieProperties setObject:@\".pingan.com.cn\" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@\"\" forKey:NSHTTPCookieOriginURL];[cookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath];[cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];[store.httpCookieStore setCookie:cookie completionHandler:^&#123; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; //读取不到写入的cookie。 &#125;]; &#125;]; 使用迂回方式解决写入问题： 123456789101112//添加observer代理[store.httpCookieStore addObserver:self];//注意：网络不畅通时，存在不回调的情况。网络ok后才会调用。原因不明- (void)cookiesDidChangeInCookieStore:(WKHTTPCookieStore *)cookieStore &#123; WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore]; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; LOG_INFO(\"WEB\", @\"cookiesDidChangeInCookieStore: %@\", cookies); //参考链接：https://forums.developer.apple.com/thread/97194 //此时才能看到Cookie被写入了 &#125;];&#125; cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：#140191 自测添加跨域的cookie, Cookie添加成功后进行跨域访问，cookie无法生效。 自测添加正常cookie也无法生效。 参考资料 Can I set the cookies to be used by a WKWebView? WKWebView 那些坑","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"}]},{"title":"iOS crash文件符号化","date":"2018-02-27T02:47:42.000Z","path":"2018/02/27/iOS-crash文件符号化/","text":"carsh文件符号化需要symbolicatecrash脚本、.crash文件、产生crash的app对应的.dSYM文件。脚本可以通过.dSYM文件对.crash文件进行格式化。 资源准备查找symbolicatecrash脚本执行命令：find /Applications/Xcode.app/ -name symbolicatecrash， 返回 1234/Applications/Xcode.app//Contents/Developer/Platforms/WatchSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 找到四个结果，随意使用一个即可，这里使用：/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash 提取crash文件 连上发生crash的手机，在Xcode的Window -&gt; Devices and Simulator 下，选中发生crash的设备，点击View Device Logs按钮 找到对应的crash日志，点击右键，选择Export Log导出。 不是所有的crash，都能产生crash日志。 没有crash日志只能通过其它方式debug. 提取dSYM文件 如果是xcode上打的包，在Xcode的Window -&gt; Organizer下，选中对应的app 选中对应的包，点击右键，选择Show in Finder，找到对应的.xcarchive文件 点击右键，选择显示包内容，在dSYMs文件夹中找到对应的.dSYM文件 如果使用脚本打包，注意.dSYM文件的存档 格式化 建立目录，将上述三个文件放入同一个目录 进入指定目录，执行./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash，会生成格式化的crash文件。 如果出现报错Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.执行export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer修复。","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"Github Pages搭建博客及使用","date":"2018-01-08T12:33:20.000Z","path":"2018/01/08/Github-Pages搭建博客及使用/","text":"Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文基于Hexo进行说明。 环境搭建安装 确保电脑中是安装有Node.js、Git hexo安装：npm install -g hexo-cli 建站执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo配置在 _config.yml 中修改大部份的配置。配置说明见官方文档 主要配置参数： 网站 12345title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言 配置对应的Github Pages 1234deploy: type: git repository: https://github.com/StudyData/StudyData.github.io branch: master 网址 1url: http:&#x2F;&#x2F;blog.devlxx.com 配置评论 12disqus_shortname: devlxxdisqus: true 日常用法 创建新博文：$ hexo new [layout] &lt;title&gt;，如hexo new &quot;Github Pages搭建博客及使用，执行后，会在source/_posts目录下创建hexo new &quot;Github Pages搭建博客及使用.md文件 创建草稿使用特殊布局：draft, 建立时会保存在source/_drafts文件夹，可以执行$ hexo publish [layout] &lt;title&gt;移动到source/_posts目录 生成静态文件：hexo generate 本地查看：hexo server -p 5000，执行后，打开http://localhost:5000/即可查看博客效果。 部署：hexo deploy 可以通过在文章中插入&lt;!--more--&gt;来设置在文章列表中展示的内容。&lt;!--more--&gt;上面内容均会展示在在列表中，下面的会被收起。（for yilia 主题） 进阶域名绑定使用自己的域名逼格更高，域名绑定需要做两部分工作。 Github Pages域名绑定设置使用一个自定义域名去重定向你的 GitHub Pages，你必须创建和提交一个包含自定义域名的 CNAME 文件到你的 GitHub Pages 存储库中。 进入Github Pages仓库：https://github.com/StudyData/StudyData.github.io 添加一个新文件，命名为 CNAME （全部大写！），放在 Pages 分支的根目录下。 在新文件中，添加一行，指定自定义域名的空子域名。例如，使用 blog.example.com 而不是 https://blog.example.com 。 请注意，在 CNAME 文件中只允许有一个域名。 域名服务商设置以万网为例 点击添加解析 记录类型：CHAME 主机记录：blog 记录值：studydata.github.io 添加评论hexo支持各种评论，常见的有1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment等，评估那个适合自己，申请相关服务后在根目录的_config.yml中进行配置，如： 12disqus_shortname: devlxxdisqus: true 畅言对国内支持较好，可以微信，QQ登录，配置如下： 1234#畅言app idchangyan_appid: 'xxxx'#畅言app keychangyan_conf: 'xxxxxxxxxxxxxxxxxx' 资源文件使用 在根目录的_config.yml中进行配置: 1post_asset_folder: true 每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们 也可以在source目录下创建一个资源目录assets，然后通过类似于![](/assets/image.jpg)的方法访问它们。 如何更换主题主题都放置在themes/目录下，一般从github上找到自己心仪的主题，clone到此目录下。然后在_config.yml配置相应的主题。 如： 1theme: hexo-theme-yilia hexo-theme-yilia为clone下来的项目的文件名。 如何使用主题每个主题基本都有自己说明文档，一般通过修改主题中的themes/theme_name/_config.yml文件来实现主题修改。 问题处理 有人会把整个hexo目录放入GitHub Pages仓库，这是不对的，指定hexo d会将生成的博文相关静态文件上传到Github Pages，hexo目录一般用另外一个私有仓库放置，里面可以有你的草稿，主题等。 执行hexo d会将仓库先清空，如果有加入CNAME文件也会被清空，可以将CNAME放入source/目录下，上传的时候会一并传上去。 执行hexo g出现警告WARN No layout:xxx，然后执行hexo s运行本地博客无内容。解决方法： 是否配置的主题在theme下存在，检查下themes/themeName/layout/文件夹里是否有index.js文件，以及目录结构是否与实际主题的layout保持一致 执行hexo g报错：Error: The module &#39;/Users/lixinxing/Documents/BlogBackup/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#39; was compiled against a different Node.js version using 一般是node的版本发生了变化，删除目录下的node_modules文件，然后执行npm install重新安装即可。 依然不行，可以执行npm i -g hexo-cli再跑跑试试。 执行hexo g报错：ERROR Plugin load failed: hexo-generator-json-content 可能是node版本过低，升级node版本即可。 hexo将整个目录都上传了上去，一般是设置了submodule导致的。 把.deploy_git文件夹删除 执行hexo clean删除public目录后，再重新执行命令上传即可。 相关资料 hexo官方文档 hexo主题yilia","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"}]},{"title":"iOS的ipa包重签名","date":"2016-04-23T10:39:18.000Z","path":"2016/04/23/iOS的ipa包重签名/","text":"日常开发中，我们需要一个Apple账号用于发布App到AppStore，一个企业账号用于内部发布测试及给客户演示。但是Apple限制Bundle Identifier是不能重复的。所以我们有时候需要使用企业证书对个人证书发布的ipa包进行重签名。(注：当然你也可以用于其他用途，但是有被Apple封杀的风险) 模拟数据为了能对整个流程进行更好的说明，这里设置一些模拟数据 App 在AppStore的Bundle Identifier:com.test.AppStore 企业证书的名称：iPhone Distribution: Shenzhen Test Technology Co., Ltd. 企业证书对应的Prefix：828E9CDH56 企业账号用于发布的Provisioning Profiles文件名：TestDistributionForEnterprise.mobileprovision 企业账号用于发布的Provisioning Profiles对应的Bundle Identifier：com.test.enterprise 注：如果重签名后需要支持消息推送服务，需要把对应的Identifiers勾选Push Notifications服务 重签名流程创建entitlements.plist授权文件 entitlements.plist文件内容123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;828E9CDH56.*&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;key&gt;get-task-allow&lt;&#x2F;key&gt; &lt;false&#x2F;&gt; &lt;key&gt;application-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56.com.test.enterprise&lt;&#x2F;string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56&lt;&#x2F;string&gt; &lt;key&gt;aps-environment&lt;&#x2F;key&gt; &lt;string&gt;production&lt;&#x2F;string&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 图示如下： ipa文件处理 使用个人账号证书打包（和往常上传AppStore一样操作），导出ipa文件，文件名为test.ipa。 将test.ipa后缀改成zip并进行解压得到一个文件Payload 删除Payload/test.app/_CodeSignature 以及 Payload/test.app/embedded.mobileprovision两个文件 替换证书配置文件（文件名为embedded，不能自定义）1cp TestDistributionForEnterprise.mobileprovision Payload&#x2F;test.app&#x2F;embedded.mobileprovision 重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）12certifierName&#x3D;&quot;iPhone Distribution: Shenzhen Test Technology Co., Ltd.&quot;codesign -f -s $certifierName --entitlements entitlements.plist Payload&#x2F;test.app 打包1zip -r resignTest.ipa Payload 这样就得到了一个新的文件resignTest.ipa，可以企业发布给任何人安装，同时Bundle Identifier依然是com.test.AppStore 注意：1、如果不在Payload所在目录进行打包，如xxx/Payload，则会导致打包出来的安装包无法安装，原因不明。2、如果之前有安装过对应App测试版本，会导致安装失败，可能是缓存导致的问题。 Extension支持在iOS开发中，Extension越来越多，尤其是很多app添加了Today Extension，在重签名的时候需要对extension进行处理，如果有多个extension，那么每个extension都要做重签名处理。对extension进行重签名流程如下： 找到PlugIns目录下对应的Extension文件 与对app进行重签名一样，删除Extension里面的_CodeSignature目录，删除embedded.mobileprovision文件。 使用codesign命令进行重签名，证书与主app一致。命令也一样，修改对应的entitlements.plist和指定目录即可。 例：codesign -f -s $certifierName --entitlements extension_entitlements.plist Payload/test.app/PlugIns/extension.appex 这里有两个注意事项： 先对Extension进行签名，再对主app进行签名，不然会报错说codesign内容被修改之类的错误 重签名的时候注意证书的传参，如果对证书名字中有空格又没有用””引起来，会导致找不到证书。 如果报错This application&#39;s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.，那么应该是安装了一个同样bundle id的app， 把它删掉重新安装就可以了。 企业发布 按照常规的企业发布方式来即可 注意：1、企业发布后出现在有些机型可以安装成功，有些机型安装失败，刚开始怀疑是打的包有问题，后来发现是由于用于安装的plist文件里面的display-image以及full-size-image链接有问题，修复后OK2、如果出现有的手机能安装， 有的手机不能安装， 那可能是.mobileprovision没有被正确替换导致的。 开源项目我把整个流程用Python做了一个脚本，功能流程如下 打包ipa–&gt;重签名–&gt;上传服务器–&gt;发送邮件，点此可以下载。 相关链接代码签名探析","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"逆向","slug":"逆向","permalink":"http://blog.devlxx.com/tags/%E9%80%86%E5%90%91/"}]}]