[{"title":"使用Xcode模板加速及规范开发","date":"2020-06-29T07:26:16.000Z","path":"2020/06/29/使用Xcode模板加速及规范开发/","text":"为什么需要使用模板在开发中，经常会碰到开发类似功能和特性的情况，我们可以使用面向对象编程的继承来对相同部分进行封装，利用多态来进行特定功能区分，这样可以提高开发效率和质量。当然也有函数式开发和面向协议编程等，但是万变不离其宗，大家都在提模块化，组件化，以提高代码复用和质量。但是不管使用哪种编程思想，在实际开发中我们不可能干掉所有的重复代码和重复逻辑，过度的封装也是要成本和有害处的，所以依然会存在很多复制、粘贴等重复操作。 为了减少这些重复操作导致的效率低下，我们可以使用Dash或Gist等工具，创建代码片段，来快速的复制粘贴代码，但是这些只限定于单个文件内的文本编辑。如果你所做的项目对某一类功能的实现已经有了固定套路，例如一个常见的列表页面，包含下拉刷新、加载更多等功能，你选择了MVC或MVVM等架构模式，那么在单个项目内，每个列表页面的代码将会大量相似，每次写起功能，就感觉自己是在重复的搬砖，996爆肝也干不完活。如果是多人开发，可能还会在大体框架基础下搞出好几套大同小异的代码来，这样的害处是显而易见的。 在软件开发中，要提高效率，就得把重复的工作交给机器做，机器会做的又快又好。一般App中会存在大量列表页面，针对类似功能，我们完全可以创建一套模板，然后通过脚本或者软件根据模板来生成代码，我们只需要修改生成代码中的少量代码就可以完成全部功能。有人意识到了这个，并开发了介绍 | Gckit-CLI这款命令行工具，可以通过模板生成代码。 刚开始我也是使用这款命令行工具，但是后面发现Xcode IDE原生支持自定义模板后，我转向了使用Xcode来自定义模板。 Xcode 系统默认模板Xcode在创建代码时，自带模板功能。 它包含iOS、watchOS、tvOS、macOS菜单，在iOS菜单下又分为Source、User Interface等小模块，图示如下： 这些模板的路径位置如下： iOS 平台模版的位置：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates watchOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates tvOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates macOS 平台文件模版的位置：/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates 这里我们仅拿iOS平台模板来进行说明 我们看iOS平台模板的目录结构： 12345678├── File\\ Templates│ ├── Apple\\ Watch│ ├── Playground│ ├── Resource│ ├── Source│ └── User\\ Interface└── Project\\ Templates └── iOS Project\\ Templates是创建项目的模板，这里不做说明。File\\ Templates目录下的内容就是上面图示中iOS模块下的内容，例如我们创建一个Source -&gt; Cocoa Touch Class的模板文件，会进入下一个页面： 这个页面对应Cocoa Touch Class.xctemplate目录下的TemplateInfo.plist文件： 12345678910111213├── File\\ Templates│ ├── Source│ │ ├── Cocoa\\ Touch\\ Class.xctemplate│ │ │ ├── NSObjectObjective-C│ │ │ ├── NSObjectSwift│ │ │ ├── TemplateIcon.png│ │ │ ├── TemplateIcon@2x.png│ │ │ ├── TemplateInfo.plist│ │ │ ├── UICollectionReusableViewObjective-C│ │ │ ├── ...├── ...│ ├── ...... 上面的这个页面是根据这个TemplateInfo.plist配置来生成的，模板的匹配也是根据此配置文件来加载的。 这个文件内容较多，这里就不做说明。我们可以根据里面的内容和展示的页面来依葫芦画瓢学习模板是如何创建的。 自定义Xcode模板我们知道了系统模板的实现原理，那么我们就可以依葫芦画瓢的来实现一个自定义模板。Xcode加载自定义模板的路径是：~/Library/Developer/Xcode/Templates(如果不存在Templates目录，就手动创建一个。)在此路径下，我们创建一个Custom目录，将系统模板中的Cocoa\\ Touch\\ Class.xctemplate目录复制到Custom目录下，这样在工程中新建文件就可以看到自定义的Custom目录及它下面的Cocoa\\ Touch\\ Class模板了： 到了这一步，你就会清楚自定义模板的套路了，剩下的就是依葫芦画瓢来实现自己的模板了。 我根据个人常用编程套路，创建了一套模板，大家可以下载进行参考。下载地址： GitHub - xx-li/CustomTemplates: Xcode rapid development templates， 使用图示： 后文由于模板的匹配是目录匹配方式，所以每一个选项都会对应一个新的目录，例如一个2*2的选项，就会需要四个模板目录来进行匹配。当我们模板进行功能细分时，就需要创建大量的模板，修改一个基础逻辑就要对所有的模板文件进行修改。为了解决这种问题，可以使用脚本来创建模板，具体实现可以参考iOS-VIPER-Xcode-Templates，它使用了ruby来进行模板的生成。","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"如何创建一个Flutter Plugin","date":"2020-06-15T09:51:00.000Z","path":"2020/06/15/如何创建一个Flutter-Plugin/","text":"什么是pluginFlutter和Dart生态系统的软件包有两种模板，分别是packages和plugin，其中plugin包含Android、iOS平台特定实现，一般需要Flutter端与Android或iOS进行通讯交互（类比Hybrid或RN中JS与Native的交互），以实现特定功能。 创建plugin一般使用命令创建Plugin：flutter create —org com.example —template=plugin hello，执行命令后，会在当前目录下生成一个hello文件夹，里面是一个plugin的简单demo实现。iOS可以使用OC和Swift，Android可以使用Java和kotlin进行代码编写，命令默认使用swift及kotlin，如需修改，使用-i及-o命令。例如要创建一个使用OC及java的plugin，命令为：flutter create —org com.example —template=plugin -a java -o objc hello。 创建一个样例Demo为了更好的说明流程，这里创建一个禁用截屏功能的plugin进行说明，plugin提供三个功能：全局添加水印、截屏监控、禁用截屏。其中全局添加水印为在Flutter当前页面栈的最上层添加一个半透、有水印、穿透触摸事件的全遮盖页面，为纯dart实现，不需要与平台进行交互； 截屏监控为当平台监听到截屏行为后，立即通知Flutter端，是一个持续通讯的过程；禁用截屏为Flutter端通知平台执行禁用操作（只支持Android平台）。此plugin已经开发完成并发布到官方pub，可以在GitHub - disable_screenshots下载并查看源码。 创建命令：flutter create --org com.devlxx --template=plugin disable_screenshots 执行命令后会生成如下目录：1234567891011├── disable_screenshots│ ├── CHANGELOG.md│ ├── README.md│ ├── android│ ├── disable_screenshots.iml│ ├── example│ ├── ios│ ├── lib│ ├── pubspec.lock│ ├── pubspec.yaml│ └── test pubspec.yaml：plugin的配置文件。里面有字段：name、description、version、homepage，这些均是字面意思，很好理解。另外有字段environment，指定插件的使用环境，最关键的是有一个flutter字段： 12345678910111213# The following section is specific to Flutter.flutter: # This section identifies this Flutter project as a plugin project. # The &#39;pluginClass&#39; and Android &#39;package&#39; identifiers should not ordinarily # be modified. They are used by the tooling to maintain consistency when # adding or updating assets for this project. plugin: platforms: android: package: com.devlxx.disable_screenshots pluginClass: DisableScreenshotsPlugin ios: pluginClass: DisableScreenshotsPlugin 这个字段说明了plugin支持的平台以及各平台的入口class，这个需要能一一对应。默认会给你创建好，不要随意修改这里及类名即可。 README.md : 项目说明。当发布到官方的pub.dev后，插件的Readme栏目内容即为此文件内容。 lib：pluginFlutter端的实现 ios：pluginios端的实现 android：pluginandroid端的实现 example：plugin的使用demo，可以运行此demo进行测试，另外demo里面也有README.md文件，当发布到官方的pub.dev后，插件的Example栏目内容即为此文件内容。 Flutter与iOS、Android通讯原理Flutter只是一个UI框架，与平台相关的功能只能由平台来原生实现，这就需要Flutter与原生进行相互通讯。它们通过PlatformChannel进行互相通讯，核心原理是： Flutter通过PlatformChannel将要传递的数据编码后，跨线程发送到宿主（iOS或Android） 宿主接收到PlatformChannel的消息后，执行原生API。 宿主执行完原生API后，将数据编码并原路返回给应用程序的Flutter部分图示如下： PlatformChannel有三种类型，分别是：BasicMessageChannel、MethodChannel、EventChannel。其中BasicMessageChannel接收一个MessageCodec作为其编解码器的实现，允许我们使用自定义的消息编解码进行异步消息传递，这里不对其做说明。 - `MethodChannel`：用于Flutter主动调用平台端的方法，并获得相应的返回值，例如获取系统电量、发起Toast等，可以说是“一次性”的调用。这里将通过它来告知平台端禁用截屏功能 - `EventChannel`，用于传递事件。例如Flutter要监听电量变化，平台端可以将监听到的电量变化情况持续的通过`EventChannel`传递给Flutter端。这里将通过它来`截屏监控`功能。disable_screenshots的禁用截屏功能实现（MethodChannel） Flutter端实现创建命令会在lib目录下生成一个disable_screenshots.dart文件，里面会有一个默认的MethodChannel实现样例，我们对其进行修改，修改后的核心源码如下： 12345// 1. 创建一个MethodChannelfinal MethodChannel methodChannel = const MethodChannel(\"com.devlxx.DisableScreenshots/disableScreenshots\");// 2. 通过MethodChannel将方法名和参数编码后发到平台端methodChannel.invokeMethod(\"disableScreenshots\", &#123;\"disable\": disable&#125;); Android端实现（kotlin）创建命令会在android目录下的/src/main/kotlin/com/devlxx/disable_screenshots/生成一个DisableScreenshotsPlugin.kt文件，其中实现禁用截屏的核心代码为： 1234567891011121314151617181920212223242526private fun onAttachedToEngine(applicationContext: Context, messenger: BinaryMessenger) &#123; this.applicationContext = applicationContext // 1. 创建一个MethodChannel this.channel = MethodChannel(messenger, \"com.devlxx.DisableScreenshots/disableScreenshots\") //handle指向了this，this必须实现onMethodCall方法 this.channel.setMethodCallHandler(this)&#125;// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) &#123; if (call.method == \"disableScreenshots\") &#123; var disable = call.argument&lt;Boolean&gt;(\"disable\") == true // 禁止截屏需要获取到当前的activity，如何获取到activity请自行查看源码，这里不做说明。 if (disable) &#123; activity.window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); println(\"禁用截屏\") &#125; else &#123; // 允许截屏 activity.window.clearFlags(WindowManager.LayoutParams.FLAG_SECURE) println(\"允许截屏\") &#125; // 调用后，Flutter端的invokeMethod会收到调用的结果，结果为一个空字符串 result.success(\"\") &#125; else &#123; result.notImplemented() &#125;&#125; iOS端实现。（iOS无法实现禁止截屏功能，这里仅做说明）创建命令会在ios目录下的Classes/下生成一个DisableScreenshotsPlugin.swift文件，其中实现禁用截屏的核心代码为： 12345678910111213141516171819202122232425262728293031public class SwiftDisableScreenshotsPlugin: NSObject &#123; public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建一个MethodChannel let methodChannel = FlutterMethodChannel(name: \"com.devlxx.DisableScreenshots/disableScreenshots\", binaryMessenger: registrar.messenger()) registrar.addMethodCallDelegate(instance, channel: methodChannel) &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterPlugin &#123; // 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里 public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) &#123; /* //iOS平台无法实现禁用截屏功能，这里仅做MethodChannel的使用说明 if call.method == \"disableScreenshots\" &#123; if let arg = call.arguments as? Dictionary&lt;String, Any&gt;, let disable = arg[\"disable\"] as? Bool &#123; if disable &#123; //禁用截屏 &#125; else &#123; //允许截屏 &#125; &#125; else &#123; print(\"【SwiftDisableScreenshotsPlugin】disableScreenshots 收到错误参数\") &#125; &#125; else &#123; result(FlutterMethodNotImplemented) &#125; */ result(FlutterMethodNotImplemented) &#125;&#125; disable_screenshots的截屏监控功能实现（EventChannel） Flutter端实现 1234567// 1. 创建EventChannelfinal EventChannel eventChannel = const EventChannel('com.devlxx.DisableScreenshots/observer');// 2. 监听平台端发来的事件_eventChannel.receiveBroadcastStream().listen((event) &#123; //平台端发来事件后会调用到这里&#125;); Android端实现 12345678910111213141516171819202122232425// 1. 创建EventChannelval eventChannel = EventChannel(messenger, \"com.devlxx.DisableScreenshots/observer\")// 2. handle指向了this，this必须实现onListen及onCancel方法。eventChannel.setStreamHandler(this)//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端override fun onListen(arguments: Any?, events: EventChannel.EventSink?) &#123; println(\"开始监听\") // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. ScreenShotListenManager为一个实现了监听截屏功能的Manager screenShotListenManager = ScreenShotListenManager.newInstance(applicationContext) screenShotListenManager.setListener &#123; imagePath -&gt; println(\"监听到截屏，截屏图片地址是：$imagePath\") // 6. 发送事件给Flutter端，告知监听到了截屏行为。 eventSink?.success(\"监听到截屏行为\") &#125; screenShotListenManager.startListen()&#125;// EventChannel被取消override fun onCancel(arguments: Any?) &#123; screenShotListenManager.stopListen() eventSink = null&#125; iOS端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SwiftDisableScreenshotsPlugin: NSObject &#123; var eventSink: FlutterEventSink? // 注册使用此插件 public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建EventChannel let channel = FlutterEventChannel( name: \"com.devlxx.DisableScreenshots/observer\", binaryMessenger: registrar.messenger() ) // 2. 设置handler为SwiftDisableScreenshotsPlugin，它必须实现onListen及onCancel方法 channel.setStreamHandler(instance) &#125; 6. 发送事件给Flutter端，告知监听到了截屏行为。 @objc func callScreenshots() &#123; eventSink!(\"监听到截屏行为\") &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterStreamHandler &#123; //3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端 public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? &#123; // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. iOS端实现截屏监听功能很简单，添加相应通知的监听即可。 NotificationCenter.default.addObserver( self, selector: #selector(callScreenshots), name: UIApplication.userDidTakeScreenshotNotification, object: nil) return nil &#125; // EventChannel被取消 public func onCancel(withArguments arguments: Any?) -&gt; FlutterError? &#123; NotificationCenter.default.removeObserver(self) eventSink = nil return nil &#125;&#125; 综合MethodChannel及EventChannel的三端实现来看，它们的使用还是比较简单的，对于开发者来说，挑战在于需要对三端都熟悉，并写出高质量的代码。在实际开发时，可以先用相应的开发者工具打开Example目录下的iOS及Android的项目，分别进行平台特定代码的开发、调试。当iOS及Android的平台代码编写完成后，再直接运行Example项目，进行Flutter端的功能开发及整体的调试。 全局添加水印全局添加水印不涉及平台端，为纯Flutter端实现。和常规的Flutter Dart代码编写没什么差异，这里不做说明，具体实现可以直接查看源码。 发布plugin当plugin的三端代码写好后，需要进行发布。plugin的发布非常简单，分为两步。第一步为检查项目是否OK，执行命令：flutter packages pub publish --dry-run后，会提示项目是否存在遗漏或者异常部分，如果有异常，根据提示进行修复即可。例如此项目在执行此命令时，有提示存在问题： 12Package validation found the following potential issue:* Your pubspec.yaml includes an &quot;author&quot; section which is no longer used and may be removed. 这个是Flutter的一个bug，默认创建的模板会包含一个author字段，但是却无法检查通过，将pubspec.yaml中的author字段删除即可检查通过。 检查通过后，可以执行第二步，执行命令：flutter packages pub publish进行发布。执行后，根据命令行会提示进行操作，需要注意的是有一个验证身份的操作，将命令行出现的网址在浏览器中打开，然后在此页面登录自己的Google账号，这样就会将这个plugin与你的账号进行绑定及身份验证，操作完成后即发布成功，命令行输出如下所示： 12345678910Do you want to publish disable_screenshots 0.0.1 (y&#x2F;N)? yPub needs your authorization to upload packages on your behalf.In a web browser, go to https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?access_type&#x3D;offline&amp;approval_prompt&#x3D;force&amp;response_type&#x3D;code&amp;client_id&#x3D;81fds5108-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A54755&amp;scope&#x3D;openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.emailThen click &quot;Allow access&quot;.Waiting for your authorization...Authorization received, processing...Successfully authorized.Uploading...Successfully uploaded package. plugin发布成功后并不能立即在官方的pub中搜到，它需要一段时间来处理，但是可以直接输入地址看到：https://pub.dev/flutter/packages?q=disable_screenshots 引用pluginplugin开发完后，我们可以选择多种方式将plugin提供给其它开发者使用： - 从本地路径引入 - 从Git仓库引入 - 从官方pub引入（需要先发布到官方pub） - 从指定源引入 本地路径引入plugin中的Example引入plugin就是通过本地路径方式引入的，这种方式很方便本地修改和调试，进入方式如下： 123456dependencies: flutter: sdk: flutter disable_screenshots: # 当前pubspec.yaml文件的上一级目录是plugin所在目录 path: ../ 从Git仓库引入顾名思义，直接从Git仓库拉取plugin，可以指定分支及路径。企业内部引用可以使用此种方式。样例如下： 1234567dependencies: flutter: sdk: flutter disable_screenshots: git: url: https://github.com/xx-li/disable_screenshots path: path/to/disable_screenshots #这里只做说明，实际disable_screenshots插件在根目录，不需要指定路径。 官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using packages - Flutter问题备忘 在老的flutter项目中，在iOS平台运行可能出现编译问题无法运行。这个是由于老的flutter项目里面没有使用到swift，所以没有briging文件，但是插件使用了swift，所以会编译失败，这种情况直接使用xcode在iOS项目中创建一个swift文件，会自动生成briding文件。 参考资料 GitHub - huiger/ScreenShotDemo: 🔥Android 手机应用内截屏, 截屏监听 Experimental: Create Flutter Plugin · flutter/flutter Wiki · GitHub Using packages - Flutter Developing packages &amp; plugins - Flutter Writing custom platform-specific code - Flutter Flutter 开发（14）：BasicMessageChannel 的使用 | 肥言肥语 dart - How to get Activity and Context in Flutter plugin - Stack Overflow https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.devlxx.com/tags/Flutter/"}]},{"title":"WKWebView的Cookie问题","date":"2018-05-08T11:46:41.000Z","path":"2018/05/08/WKWebView的Cookie问题/","text":"WKWebView与App不在同一个进程运行，不会从App的标准Cookie容器NSHTTPCookieStorage读取Cookie。跨进程的数据同步是一个麻烦及容易出现问题的场景，Apple在iOS11之前没有专门的API用于Cookie操作，在iOS11之后提供了WKHTTPCookieStore，但是自测发现存在一些奇怪的bug，无法使用，此部分后续会做说明。 网上关于WKWebView的Cookie同步我有查到多种方案，但是均无法解决跨域请求的Cookie问题，后来发现使用WKProcessPool可以解决跨域问题。 UIWebView为什么没有Cookie同步问题？网络请求完成后，会返回一个Response，如果Response中带有Set-Cookie字段，如：&quot;Set-Cookie&quot; = &quot;wifi_jsessionid=3aea4df28ab14b4e8714132cb911c15a; Domain=.pingan.com.cn; Path=/&quot;;，操作系统就会将此条Cookie信息写入到NSHTTPCookieStorage中 当UIWebView中有任意请求时（App进程中的请求也是一样），会去NSHTTPCookieStorage查找对应的Cookie信息，如果存在符合条件的Cookie信息，就会在请求头中带上此条Cookie信息。所以UIWebView进行跨域请求是没有任何问题的，只要NSHTTPCookieStorage有符合条件的Cookie信息即可带上。 WKWebView Cookie同步一般解决方案WKWebView上请求不会自动带上NSHTTPCookieStorage中的Cookie, 目前的主要解决方案是通过手动的方式直接在请求头上带上Cookie或者使用JS脚本进行Cookie注入： 在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:12345WKWebView * webView = [WKWebView new]; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://h5.qzone.qq.com/mqzone/index\"]]; [request addValue:@\"skey=skeyValue\" forHTTPHeaderField:@\"Cookie\"]; [webView loadRequest:request]; 此方法只适合解决简单针对性的场景。 通过document.cookie设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:12345678910WKUserContentController* userContentController = WKUserContentController.new;//不设定Domain，则会将domain默认设为请求的URL的DomainWKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @\"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';\" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];// again, use stringWithFormat: in the above line to inject your values programmatically[userContentController addUserScript:cookieScript];WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;webViewConfig.userContentController = userContentController;WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig]; 设定Cookie的辅助方法: 123456789101112- (NSString *)cookieString &#123; NSString *string = [NSString stringWithFormat:@\"%@=%@;domain=%@;path=%@\", self.name, self.value, self.domain, self.path ?: @\"/\"]; if (self.secure) &#123; string = [string stringByAppendingString:@\";secure=true\"]; &#125; return string;&#125; 因为Cookie注入无法跨域，此方法无法解决跨域请求的Cookie问题。 WKProcessPool同步方案解决跨域问题苹果开发者文档对WKProcessPool的定义是：A WKProcessPool object represents a pool of Web Content process. 通过让所有WKWebView共享同一个WKProcessPool实例，可以实现多个 WKWebView之间共享Cookie（session Cookie and persistent Cookie）数据。 既然可以多个WKWebView共享一个WKProcessPool实例，那么是不是可以先访问跨域的URL，将Cookie注入，不就得到了一个有跨域Cookie的WKProcessPool实例吗？再用此实例去访问原始的Web页面，不就可以解决跨域访问的Cookie问题了吗？ 经过实测，此方案是OK的。 样例如下： 可以创建一个单例管理WKProcessPool。如果Cookie更新了，更新WKProcessPool即可同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)updateProcessPool &#123; _isUpdatePooling = YES; if (_webView) &#123; _webView.navigationDelegate = nil; [_webView removeFromSuperview]; _webView = nil; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(willUpdateCookieWithPool)]) &#123; [_delegate willUpdateCookieWithPool]; &#125; //JS注入 NSString *jsStr = [self updateCookieScriptString]; //JS注入的domain（跨域注入会失败） NSURL *url = [NSURL URLWithString:@\"http://www.pingan.com.cn/\"]; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:jsStr injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; WKUserContentController* userContentController = WKUserContentController.new; [userContentController addUserScript:cookieScript]; WKWebViewConfiguration* configuration = WKWebViewConfiguration.new; configuration.userContentController = userContentController; configuration.processPool = self.pool; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration]; [[UIApplication sharedApplication].keyWindow addSubview:webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:3]; webView.navigationDelegate = self; [webView loadRequest:request]; _webView = webView;&#125;#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; LOG_INFO(\"WEB\", @\"didFinishNavigation :%@\", navigation); webView.navigationDelegate = nil; [webView removeFromSuperview]; @synchronized(self) &#123; for (void(^block)(WKProcessPool *pool) in _handlers) &#123; block(_pool); &#125; [_handlers removeAllObjects]; _isUpdatePooling = NO; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(didUpdateCookieWithPool)]) &#123; [_delegate didUpdateCookieWithPool]; &#125; &#125;#pragma mark -- (void)getCookieWithProcessPoolHandler:(void(^)(WKProcessPool *pool))handler &#123; if (_isUpdatePooling) &#123; [_handlers addObject:handler]; &#125; else &#123; handler(_pool); &#125;&#125; 由于WKProcessPool只能在初始化时传入有效，所以调用有一点特殊： 123456789101112131415161718@weakify(self);PAWFWebProcessPoolManager *cookieManager = [PAWFWebProcessPoolManager sharedManager];[cookieManager getCookieWithProcessPoolHandler:^(WKProcessPool * _Nonnull pool) &#123; @strongify(self); self.webView = [self creatWebViewWithPool:pool]; [self.view addSubview:self.webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:self.URL]; [self.webView loadRequest:request];&#125;];- (WKWebView *)creatWebViewWithPool:(WKProcessPool *)pool &#123; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init]; configuration.processPool = pool; CGRect frame = CGRectMake(0, 0, kScreenWidth, CGRectGetHeight(self.contentView.frame) - kGrwonStatusBarHeight); WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:configuration]; wkWebView.navigationDelegate = self; return wkWebView;&#125; WKHTTPCookieStore同步cookie问题WKHTTPCookieStore，存在一些奇怪的bug，完全无法使用，已知问题如下： 无法正常写入cookie的Bug：12345678910111213141516NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@\"wifi_jsessionid\" forKey:NSHTTPCookieName];[cookieProperties setObject:jsessionid forKey:NSHTTPCookieValue];[cookieProperties setObject:@\".pingan.com.cn\" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@\"\" forKey:NSHTTPCookieOriginURL];[cookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath];[cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];[store.httpCookieStore setCookie:cookie completionHandler:^&#123; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; //读取不到写入的cookie。 &#125;]; &#125;]; 使用迂回方式解决写入问题： 123456789101112//添加observer代理[store.httpCookieStore addObserver:self];//注意：网络不畅通时，存在不回调的情况。网络ok后才会调用。原因不明- (void)cookiesDidChangeInCookieStore:(WKHTTPCookieStore *)cookieStore &#123; WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore]; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; LOG_INFO(\"WEB\", @\"cookiesDidChangeInCookieStore: %@\", cookies); //参考链接：https://forums.developer.apple.com/thread/97194 //此时才能看到Cookie被写入了 &#125;];&#125; cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：#140191 自测添加跨域的cookie, Cookie添加成功后进行跨域访问，cookie无法生效。 自测添加正常cookie也无法生效。 参考资料 Can I set the cookies to be used by a WKWebView? WKWebView 那些坑","tags":[{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"},{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"iOS crash文件符号化","date":"2018-02-27T02:47:42.000Z","path":"2018/02/27/iOS-crash文件符号化/","text":"carsh文件符号化需要symbolicatecrash脚本、.crash文件、产生crash的app对应的.dSYM文件。脚本可以通过.dSYM文件对.crash文件进行格式化。 资源准备查找symbolicatecrash脚本执行命令：find /Applications/Xcode.app/ -name symbolicatecrash， 返回 1234/Applications/Xcode.app//Contents/Developer/Platforms/WatchSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 找到四个结果，随意使用一个即可，这里使用：/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash 提取crash文件 连上发生crash的手机，在Xcode的Window -&gt; Devices and Simulator 下，选中发生crash的设备，点击View Device Logs按钮 找到对应的crash日志，点击右键，选择Export Log导出。 不是所有的crash，都能产生crash日志。 没有crash日志只能通过其它方式debug. 提取dSYM文件 如果是xcode上打的包，在Xcode的Window -&gt; Organizer下，选中对应的app 选中对应的包，点击右键，选择Show in Finder，找到对应的.xcarchive文件 点击右键，选择显示包内容，在dSYMs文件夹中找到对应的.dSYM文件 如果使用脚本打包，注意.dSYM文件的存档 格式化 建立目录，将上述三个文件放入同一个目录 进入指定目录，执行./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash，会生成格式化的crash文件。 如果出现报错Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.执行export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer修复。","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"Github Pages搭建博客及使用","date":"2018-01-08T12:33:20.000Z","path":"2018/01/08/Github-Pages搭建博客及使用/","text":"Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文基于Hexo进行说明。 环境搭建安装 确保电脑中是安装有Node.js、Git hexo安装：npm install -g hexo-cli 建站执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo配置在 _config.yml 中修改大部份的配置。配置说明见官方文档 主要配置参数： 网站 12345title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言 配置对应的Github Pages 1234deploy: type: git repository: https://github.com/StudyData/StudyData.github.io branch: master 网址 1url: http:&#x2F;&#x2F;blog.devlxx.com 配置评论 12disqus_shortname: devlxxdisqus: true 日常用法 创建新博文：$ hexo new [layout] &lt;title&gt;，如hexo new &quot;Github Pages搭建博客及使用，执行后，会在source/_posts目录下创建hexo new &quot;Github Pages搭建博客及使用.md文件 创建草稿使用特殊布局：draft, 建立时会保存在source/_drafts文件夹，可以执行$ hexo publish [layout] &lt;title&gt;移动到source/_posts目录 生成静态文件：hexo generate 本地查看：hexo server -p 5000，执行后，打开http://localhost:5000/即可查看博客效果。 部署：hexo deploy 可以通过在文章中插入&lt;!--more--&gt;来设置在文章列表中展示的内容。&lt;!--more--&gt;上面内容均会展示在在列表中，下面的会被收起。（for yilia 主题） 进阶域名绑定使用自己的域名逼格更高，域名绑定需要做两部分工作。 Github Pages域名绑定设置使用一个自定义域名去重定向你的 GitHub Pages，你必须创建和提交一个包含自定义域名的 CNAME 文件到你的 GitHub Pages 存储库中。 进入Github Pages仓库：https://github.com/StudyData/StudyData.github.io 添加一个新文件，命名为 CNAME （全部大写！），放在 Pages 分支的根目录下。 在新文件中，添加一行，指定自定义域名的空子域名。例如，使用 blog.example.com 而不是 https://blog.example.com 。 请注意，在 CNAME 文件中只允许有一个域名。 域名服务商设置以万网为例 点击添加解析 记录类型：CHAME 主机记录：blog 记录值：studydata.github.io 添加评论hexo支持各种评论，常见的有1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment等，评估那个适合自己，申请相关服务后在根目录的_config.yml中进行配置，如： 12disqus_shortname: devlxxdisqus: true 畅言对国内支持较好，可以微信，QQ登录，配置如下： 1234#畅言app idchangyan_appid: 'xxxx'#畅言app keychangyan_conf: 'xxxxxxxxxxxxxxxxxx' 资源文件使用 在根目录的_config.yml中进行配置: 1post_asset_folder: true 每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们 也可以在source目录下创建一个资源目录assets，然后通过类似于![](/assets/image.jpg)的方法访问它们。 如何更换主题主题都放置在themes/目录下，一般从github上找到自己心仪的主题，clone到此目录下。然后在_config.yml配置相应的主题。 如： 1theme: hexo-theme-yilia hexo-theme-yilia为clone下来的项目的文件名。 如何使用主题每个主题基本都有自己说明文档，一般通过修改主题中的themes/theme_name/_config.yml文件来实现主题修改。 问题处理 有人会把整个hexo目录放入GitHub Pages仓库，这是不对的，指定hexo d会将生成的博文相关静态文件上传到Github Pages，hexo目录一般用另外一个私有仓库放置，里面可以有你的草稿，主题等。 执行hexo d会将仓库先清空，如果有加入CNAME文件也会被清空，可以将CNAME放入source/目录下，上传的时候会一并传上去。 执行hexo g出现警告WARN No layout:xxx，然后执行hexo s运行本地博客无内容。解决方法： 是否配置的主题在theme下存在，检查下themes/themeName/layout/文件夹里是否有index.js文件，以及目录结构是否与实际主题的layout保持一致 执行hexo g报错：Error: The module &#39;/Users/lixinxing/Documents/BlogBackup/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#39; was compiled against a different Node.js version using 一般是node的版本发生了变化，删除目录下的node_modules文件，然后执行npm install重新安装即可。 依然不行，可以执行npm i -g hexo-cli再跑跑试试。 执行hexo g报错：ERROR Plugin load failed: hexo-generator-json-content 可能是node版本过低，升级node版本即可。 hexo将整个目录都上传了上去，一般是设置了submodule导致的。 把.deploy_git文件夹删除 执行hexo clean删除public目录后，再重新执行命令上传即可。 相关资料 hexo官方文档 hexo主题yilia","tags":[{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"},{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"iOS的ipa包重签名","date":"2016-04-23T10:39:18.000Z","path":"2016/04/23/iOS的ipa包重签名/","text":"日常开发中，我们需要一个Apple账号用于发布App到AppStore，一个企业账号用于内部发布测试及给客户演示。但是Apple限制Bundle Identifier是不能重复的。所以我们有时候需要使用企业证书对个人证书发布的ipa包进行重签名。(注：当然你也可以用于其他用途，但是有被Apple封杀的风险) 模拟数据为了能对整个流程进行更好的说明，这里设置一些模拟数据 App 在AppStore的Bundle Identifier:com.test.AppStore 企业证书的名称：iPhone Distribution: Shenzhen Test Technology Co., Ltd. 企业证书对应的Prefix：828E9CDH56 企业账号用于发布的Provisioning Profiles文件名：TestDistributionForEnterprise.mobileprovision 企业账号用于发布的Provisioning Profiles对应的Bundle Identifier：com.test.enterprise 注：如果重签名后需要支持消息推送服务，需要把对应的Identifiers勾选Push Notifications服务 重签名流程创建entitlements.plist授权文件 entitlements.plist文件内容123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;828E9CDH56.*&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;key&gt;get-task-allow&lt;&#x2F;key&gt; &lt;false&#x2F;&gt; &lt;key&gt;application-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56.com.test.enterprise&lt;&#x2F;string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56&lt;&#x2F;string&gt; &lt;key&gt;aps-environment&lt;&#x2F;key&gt; &lt;string&gt;production&lt;&#x2F;string&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 图示如下： ipa文件处理 使用个人账号证书打包（和往常上传AppStore一样操作），导出ipa文件，文件名为test.ipa。 将test.ipa后缀改成zip并进行解压得到一个文件Payload 删除Payload/test.app/_CodeSignature 以及 Payload/test.app/embedded.mobileprovision两个文件 替换证书配置文件（文件名为embedded，不能自定义）1cp TestDistributionForEnterprise.mobileprovision Payload&#x2F;test.app&#x2F;embedded.mobileprovision 重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）12certifierName&#x3D;&quot;iPhone Distribution: Shenzhen Test Technology Co., Ltd.&quot;codesign -f -s $certifierName --entitlements entitlements.plist Payload&#x2F;test.app 打包1zip -r resignTest.ipa Payload 这样就得到了一个新的文件resignTest.ipa，可以企业发布给任何人安装，同时Bundle Identifier依然是com.test.AppStore 注意：1、如果不在Payload所在目录进行打包，如xxx/Payload，则会导致打包出来的安装包无法安装，原因不明。2、如果之前有安装过对应App测试版本，会导致安装失败，可能是缓存导致的问题。 Extension支持在iOS开发中，Extension越来越多，尤其是很多app添加了Today Extension，在重签名的时候需要对extension进行处理，如果有多个extension，那么每个extension都要做重签名处理。对extension进行重签名流程如下： 找到PlugIns目录下对应的Extension文件 与对app进行重签名一样，删除Extension里面的_CodeSignature目录，删除embedded.mobileprovision文件。 使用codesign命令进行重签名，证书与主app一致。命令也一样，修改对应的entitlements.plist和指定目录即可。 例：codesign -f -s $certifierName --entitlements extension_entitlements.plist Payload/test.app/PlugIns/extension.appex 这里有两个注意事项： 先对Extension进行签名，再对主app进行签名，不然会报错说codesign内容被修改之类的错误 重签名的时候注意证书的传参，如果对证书名字中有空格又没有用””引起来，会导致找不到证书。 如果报错This application&#39;s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.，那么应该是安装了一个同样bundle id的app， 把它删掉重新安装就可以了。 企业发布 按照常规的企业发布方式来即可 注意：1、企业发布后出现在有些机型可以安装成功，有些机型安装失败，刚开始怀疑是打的包有问题，后来发现是由于用于安装的plist文件里面的display-image以及full-size-image链接有问题，修复后OK2、如果出现有的手机能安装， 有的手机不能安装， 那可能是.mobileprovision没有被正确替换导致的。 开源项目我把整个流程用Python做了一个脚本，功能流程如下 打包ipa–&gt;重签名–&gt;上传服务器–&gt;发送邮件，点此可以下载。 相关链接代码签名探析","tags":[{"name":"逆向","slug":"逆向","permalink":"http://blog.devlxx.com/tags/%E9%80%86%E5%90%91/"},{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]}]