[{"title":"M1设备的Xcode编译问题深究","date":"2021-12-02T07:07:09.000Z","path":"2021/12/02/M1设备的Xcode编译问题深究/","text":"问题的由来在Apple发布M1芯片之前，一直使用Intel的芯片，没有出现什么问题。发布M1芯片后，由于两者架构的不同（M1是arm64架构，Intel是x86_64的架构），导致很多软件运行出现了问题。我们在M1机型中使用Xcode编译模拟器时，可能会碰到如下报错： 1ld: in youpath&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon(UMComBaseEvent.o), building for iOS Simulator, but linking in object file built for iOS, file &#39;&#x2F;Users&#x2F;mtgj&#x2F;Desktop&#x2F;TestArch1&#x2F;Pods&#x2F;UMCommon&#x2F;UMCommon_7.3.5&#x2F;UMCommon.framework&#x2F;UMCommon&#39; for architecture arm64 或 12345ld: warning: ignoring file YoupPth&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;FMDB&#x2F;FMDB.framework&#x2F;FMDB, building for iOS Simulator-x86_64 but attempting to link with file built for iOS Simulator-arm64Undefined symbols for architecture x86_64: &quot;_OBJC_CLASS_$_FMDatabaseQueue&quot;, referenced from: objc-class-ref in SqflitePlugin.old: symbol(s) not found for architecture x86_64 这些报错，都是是由于项目中存在.a或.framework静态库导致的。以前，我们创建静态库时，会分别打包出一份针对真机（arm64）和模拟器的（x86_64），然后将这两份合并成一个包后引入项目中进行使用。在Intel机型上，真机上使用arm64指令，模拟器（x86_64）中使用x86_64指令，所以不存在问题。但是在M1机型上，模拟器是以arm64运行的，显然再以x86_64运行就会出现问题。 有同学可能会想到包中是有arm64指令（真机）的，拿给以arm64运行的模拟器使用不就可以了吗？ 实际上xcode底层并不是这样处理的，它真机就找真机的，模拟器就找模拟器的。 解决方案常用方案对于这类架构报错问题，网上的资料一般会告诉你两个解决方案： 以Rosetta模式运行Xcode。 修改Build Settings -&gt; Excluded Architectures选项，添加Any iOS Simulator SDK选项，并设置值为arm64。图示如下： 这两种方案都能解决编译问题，但是也都存在问题。 在iOS12及以后，不再支持iphone5及以下机型，而后续的机型都是arm64架构，所以这里不再对之前的armv6/armv7/armv7s/i386 等指令集进行说明。 Rosetta方案说明以Rosetta模式运行是M1机器上x86软件无法运行的解决方案，它会将x86指令转译成ARM指令运行，这种转译显然是存在性能损耗的，损耗大概在20%～30%，详情可参考文章：苹果换芯，成了开发者们的噩梦？，不到万不得已，不推荐使用这种方案。 Excluded Architectures方案说明修改Excluded Architectures选项也有它的问题。字面意思是排除架构的意思，我们设置在模拟器中排除arm64就能解决模拟器无法编译arm64的问题。 这样的设置能生效会让人有点费解，我们知道，在intel机型上，模拟器本来就是以x86方式运行的，排除arm64毫无影响。但是在M1机型上，模拟器是以arm64方式运行的，排除了arm64反而能跑，这不是把我的智商摁在地上摩擦么？，但是苹果就是这样干的，当在M1机型上，排除了模拟器的arm64架构后，模拟器还是会以arm64的方式运行，但是模拟器中的app是以x86的方式运行的，对苹果的这个骚操作我们不得不服。图示如下： 这种情况下，模拟器和应用会通过XPC进行通信，虽然理论上不会有问题，但通信时间会比较长，导致一些依赖计时器判断的逻辑会出问题，例如滑动手势，加速度的判断会出一些问题，导致模拟器里大部分情况下列表无法触发惯性滚动。 - by kem 其它问题有时候在Excluded Architectures选项中排除了模拟器的arm64指令，依然无法编译通过，那么一般是项目设置和cocoapods的设置不一致导致，设置为一致后一般可以解决问题。可以通过在Podfile中添加如下内容来解决： 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['EXCLUDED_ARCHS[sdk=iphonesimulator*]'] = \"arm64\" end endend 最优解通过上述内容，我们知道了问题的由来，它是由于项目中存在.a或.framework，它们提供的指令集不完整导致的。Apple对于这类问题，也提供了解决方案，请由我细细道来。 以Xcode13为例，在我们创建静态库时，选择真机编译出来的包只包含arm64指令，选择模拟器编译出来的会同时包含arm64和x86_64指令。我看一些网上的教程，教别人将模拟器部分的arm64移除，其实大可不必。因为要支持M1机器正常跑模拟器，模拟器必须同时包含arm64和x86_64指令。 2019年的WWDC，apple提供了一种新的框架封装格式XCFramework。简单理解就是以前使用lipo合并不同指令集的包，现在则使用新的指令合并成XCFramework格式。 打包成framework，格式如下： 12345678910111213141516171819202122232425$ tree Release-iphoneos/TestFramework.frameworkRelease-iphoneos/TestFramework.framework├── Headers│ ├── TestFramework.h│ └── TestManager.h├── Info.plist├── Modules│ └── module.modulemap└── TestFramework$ tree Release-iphonesimulator/TestFramework.frameworkRelease-iphonesimulator/TestFramework.framework├── Headers│ ├── TestFramework.h│ └── TestManager.h├── Info.plist├── Modules│ └── module.modulemap├── TestFramework└── _CodeSignature ├── CodeDirectory ├── CodeRequirements ├── CodeRequirements-1 ├── CodeResources └── CodeSignature 打包成XCFramework后，格式如下： 123456789101112131415161718192021222324252627$ tree TestFramework.xcframeworkTestFramework.xcframework├── Info.plist├── ios-arm64│ └── TestFramework.framework│ ├── Headers│ │ ├── TestFramework.h│ │ └── TestManager.h│ ├── Info.plist│ ├── Modules│ │ └── module.modulemap│ └── TestFramework└── ios-arm64_x86_64-simulator └── TestFramework.framework ├── Headers │ ├── TestFramework.h │ └── TestManager.h ├── Info.plist ├── Modules │ └── module.modulemap ├── TestFramework └── _CodeSignature ├── CodeDirectory ├── CodeRequirements ├── CodeRequirements-1 ├── CodeResources └── CodeSignature 从上述可以看出，XCFramework就是把两个不同指令集的framework放入了同一个文件夹(.xcframework)，并生成了一个配置文件Info.plist。这样生成的XCFramework就可以完美的解决M1机器无法编译模拟器的问题。 XCFramework的创建指令也很简单： 1234567891011# -- 针对.a --# 指令：xcodebuild -create-xcframework -library &lt;path&gt; [-headers &lt;path&gt;] [-library &lt;path&gt; [-headers &lt;path&gt;]...] -output &lt;path&gt;# 样例：xcodebuild -create-xcframework -library youpath/TestFramework.a -headers youpath/TestFramework -library youpath/TestFramework.a -headers youpath/TestFramework -output youpath/TestFramework.xcframework# -- 针对.framework --# 指令：xcodebuild -create-xcframework -framework &lt;path&gt; [-framework &lt;path&gt;...] -output &lt;path&gt;# 样例：xcodebuild -create-xcframework -framework Release-iphoneos/TestFramework.framework -framework Release-iphonesimulator/TestFramework.framework -output TestFramework.xcframework 解决M1机型无法编译模拟器的关键就是针对模拟器的包要同时包含arm64和x86_64指令集。如果使用只支持x86_64指令集的模拟器包，就算打包成XCFramework也会依然存在这个问题。 后记以现在的情况，很多第三方框架，并没有使用XCFramework，而项目中只要有一个框架没有支持模拟器的arm64指令，那么在M1机器上，模拟器只能以Rosetta模式运行应用，对这一块的普遍支持估计要等M1普及以后了。 参考资料 苹果换芯，成了开发者们的噩梦？ armv6、armv7、armv7s、armv8、armv64及其i386、x86_64区别 细说iOS静态库和动态库 关于Xcode11的XCFrameworks框架","tags":[]},{"title":"Aspects框架的源码解读及问题解析","date":"2021-10-18T01:35:53.000Z","path":"2021/10/18/Aspects框架的源码解读及问题解析/","text":"前言在iOS日常开发中，对某些方法进行hook是很常见的操作。最常见的是使用Category在+load中进行方法swizzle，它是针对类的，会改变这个类所有实例的行为。但是有时候我们只想针对单个实例进行hook，这种方法就显得无力了。而Aspects框架可以搞定这个问题。它的原理是通过Runtime动态的创建子类，把实例的isa指针指向新创建的子类，然后在子类中对hook的方法进行处理，这样就支持了对单个实例的hook。Aspects框架支持对类和实例的hook，API很易用，可以方便的让你在任何地方进行hook，是线程安全的。但是Aspects框架也有一些缺陷，一不小心就会掉坑里面，我会通过源码解析进行说明。 源码解析我主要使用图示对Aspects的源码进行说明，建议参考源码一起查看。要看懂这些内容，需要对isa指针，消息转发机制，runtime有一定的了解，本文中不会对这些内容展开来讲，因为要把这些东西讲清楚，每一项都需要单独写一篇文章了。 主要流程解析 它第一个流程是使用关联对象添加Container，在这个过程中会进行一些前置条件的判断，例如这个方法是否支持被hook等，如果条件验证通过，就会把这次hook的信息保存起来，在方法调用的时候，查询出来使用。 第二个流程是动态创建子类，如果是针对类的hook，则不会走这一步。 第三步是替换这个类的forwardInvocation:方法为__ASPECTS_ARE_BEING_CALLED__，这个方法内部会查找到之前创建的Container，然后根据Container中的逻辑进行实际的调用。 第四步是将原有方法的IMP改为_objc_msgForward，改完后当调用原有方法时，就会调用_objc_msgForward，从而触发forwardInvocation:方法。 我对它的流程做了一个简化的图示，标有每个流程的序号，后面会对每个流程进行解析。流程如下： 图示中的取出对象类型，是指的调用hook的对象的类型，如果是实例对象，那么就走类路径；如果是类对象，则走元类路径；如果是kvo等实际类型不一致的情况，则走其它子类路径。 ①添加Container流程这个流程中，把hook的逻辑封装成Container，并使用关联对象进行保存。这个过程中会判断hook的方法是否被支持、判断被hook类的继承关系、验证回调block正确性等操作。具体图示如下： 关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123; ... aspect_performLocked(^&#123; // 加锁 // hook前置条件判断 if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123; // 用selector作key，通过关联对象获得Container对象。 AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); // 内部会判断block与hook的selector是否匹配，不匹配返回nil。 identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) &#123; // 添加identifier，包含了hook的类型和回调。 [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. aspect_prepareClassAndHookSelector(self, selector, error); &#125; &#125; &#125;); return identifier;&#125;static BOOL aspect_isSelectorAllowedAndTrack(NSObject *self, SEL selector, AspectOptions options, NSError **error) &#123; static NSSet *disallowedSelectorList; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; disallowedSelectorList = [NSSet setWithObjects:@\"retain\", @\"release\", @\"autorelease\", @\"forwardInvocation:\", nil]; &#125;); // 这里对不支持hook的方法进行过滤 NSString *selectorName = NSStringFromSelector(selector); if ([disallowedSelectorList containsObject:selectorName]) &#123; NSString *errorDescription = [NSString stringWithFormat:@\"Selector %@ is blacklisted.\", selectorName]; AspectError(AspectErrorSelectorBlacklisted, errorDescription); return NO; &#125; // dealloc只支持AspectPositionBefore类型下调用 AspectOptions position = options&amp;AspectPositionFilter; if ([selectorName isEqualToString:@\"dealloc\"] &amp;&amp; position != AspectPositionBefore) &#123; NSString *errorDesc = @\"AspectPositionBefore is the only valid position when hooking dealloc.\"; AspectError(AspectErrorSelectorDeallocPosition, errorDesc); return NO; &#125; // 判断是否存在这个方法 if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123; NSString *errorDesc = [NSString stringWithFormat:@\"Unable to find selector -[%@ %@].\", NSStringFromClass(self.class), selectorName]; AspectError(AspectErrorDoesNotRespondToSelector, errorDesc); return NO; &#125; // 这里禁止有继承关系的类hook同一个方法，代码量较多，不是关键内容，这里不贴出 if (class_isMetaClass(object_getClass(self))) &#123; ... &#125; return YES;&#125;/// AspectsContainer内部添加AspectIdentifier的实现。/// 这里可以看出对同一个方法的多次hook都会被调用，不会出现后面hook的覆盖前面的情况。- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123; NSParameterAssert(aspect); NSUInteger position = options&amp;AspectPositionFilter; switch (position) &#123; case AspectPositionBefore: self.beforeAspects = [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break; case AspectPositionInstead: self.insteadAspects = [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break; case AspectPositionAfter: self.afterAspects = [(self.afterAspects ?:@[]) arrayByAddingObject:aspect]; break; &#125;&#125; 从源码中可以看到，不支持的hook方法有[NSSet setWithObjects:@&quot;retain&quot;, @&quot;release&quot;, @&quot;autorelease&quot;, @&quot;forwardInvocation:&quot;, nil];。其中retain, release, autorelease在arc下是被禁用的，框架本身是hook了forwardInvocation:进行实现的，所以对它的hook也不支持。 dealloc只支持AspectPositionBefore类型，使用AspectPositionInstead会导致系统默认的dealloc操作被替换无法执行而出现问题。 AspectPositionAfter类型，调用时对象可能已经已经被释放了，从而引发野指针错误。 Aspects禁止有继承关系的类hook同一个方法，具体可以参见它的一个issue，它报告了这样操作会导致死循环，我会在文章后面再进行说明。 Aspects使用block进行hook的调用，涉及到方法参数的传递和返回值问题，所以其中会对block进行校验。 ②runtime创建子类iOS中的KVO就是通过runtime动态创建子类，然后在子类中重写对应的setter方法来实现的，Aspects支持对单个实例的hook原理与此有一些类似。图示如下：具体说明请查看源码中的注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 执行hookstatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123; NSCParameterAssert(selector); // 针对实例类型，会通过runtime动态创建子类。类类型则直接hook。 Class klass = aspect_hookClass(self, error); ...&#125;static Class aspect_hookClass(NSObject *self, NSError **error) &#123; NSCParameterAssert(self); Class statedClass = self.class; Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // 已经被hook过的类，直接返回 if ([className hasSuffix:AspectsSubclassSuffix]) &#123; return baseClass; // 是元类(MetaClass)，则代表是对类进行hook。（非单个实例） &#125;else if (class_isMetaClass(baseClass)) &#123; // 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__ return aspect_swizzleClassInPlace((Class)self); // 可能是一个KVO对象等情况，传入实际的类型进行hook。 &#125;else if (statedClass != baseClass) &#123; return aspect_swizzleClassInPlace(baseClass); &#125; // 单个实例的情况，动态创建子类进行hook. const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) &#123; subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) &#123; NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 内部是将类的forwardInvocation:方法替换为__ASPECTS_ARE_BEING_CALLED__ aspect_swizzleForwardInvocation(subclass); // 重写class方法，返回之前的类型，而不是新创建的子类。避免hook后，类型判断出现问题。 aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); objc_registerClassPair(subclass); &#125; object_setClass(self, subclass); return subclass;&#125; ③替换forwardInvocation:这部分就是把原有的forwardInvocation:替换为自定义的实现：__ASPECTS_ARE_BEING_CALLED__。源码如下： 12345678910static NSString *const AspectsForwardInvocationSelectorName = @\"__aspects_forwardInvocation:\";static void aspect_swizzleForwardInvocation(Class klass) &#123; NSCParameterAssert(klass); // If there is no method, replace will act like class_addMethod. IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); if (originalImplementation) &#123; class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); &#125; AspectLog(@\"Aspects: %@ is now aspect aware.\", NSStringFromClass(klass));&#125; 替换后的对应关系图示如下： ④hook方法交换IMP:图示如下： 第③步和第④步可能有些同学会感到疑惑，为什么要替换forwardInvocation以及为什么要将hook的方法的IMP替换为_objc_msgForward，这个和iOS的消息转发机制有关，可以自行查找相关资料，这里就不做说明了。需要注意的是有些框架也是通过iOS的消息发送机制来做一些操作，例如JSPatch，使用的时候需要注意，避免发生冲突。 被hook方法的调用流程当hook注入后，对hook方法进行调用时，调用流程就会发生变化。图示如下： 从上述解析过程中，我们可以看到Aspects这个框架是设计的很巧妙的，从中可以看到非常多runtime知识的应用。但是作者并不推荐在实际项目中进行使用： 因为Apsects对类的底层进行了修改，这种修改是基础方面的修改，需要考虑到各种场景和边界问题，一旦某方面考虑不周，就会引发出一些未知问题。另外这个框架是有缺陷的，很久没有进行更新了，我对它的已知问题点进行了总结，在下面进行说明。如果有未总结到位的，欢迎补充。 问题点基于类的hooking，同一条继承链条上的所有类，一个方法只能被hook一次，后hook的无效。之前这样会出现死循环，后面作者进行了修改，对这个行为进行了禁止并加了错误提示。详见这个issue 123456789101112131415161718192021222324252627282930@interface A : NSObject- (void)foo;@end@implementation A- (void)foo &#123; NSLog(@\"%s\", __PRETTY_FUNCTION__);&#125;@end@interface B : A @end@implementation B- (void)foo &#123; NSLog(@\"%s\", __PRETTY_FUNCTION__); [super foo]; // 导致死循环的代码&#125;@endint main(int argc, char *argv[]) &#123; [B aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@\"before -[B foo]\"); &#125;]; [A aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@\"before -[A foo]\"); &#125;]; B *b = [[B alloc] init]; [b foo]; // 调用后死循环&#125; 我们都知道，super是从它的父类开始查找方法，然后传入self进行调用。 根据我们之前对源码的解析，在这里调用[super foo]后会从父类查找foo的IMP，查到后发现父类的IMP已经被替换为_objc_msgForward，然后传入self调用。 因为是传入的self，所以实际会调用到它自身的forwardInvocation:，这样就导致了死循环。 针对单个实例的hook，hook后使用kvo没问题，使用kvo后hook会出现问题。这里通过代码进行说明，以Animal对象为例： 123456789101112131415161718192021222324252627282930313233@interface Animal : NSObject@property(strong, nonatomic) NSString * name;@end@implementation Animal- (void)testKVO &#123; [self addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; self.name = @\"Animal\";&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@\"observeValueForKeyPath keypath:%@ name:%@\", keyPath, self.name);&#125;- (void)dealloc &#123; [self removeObserver:self forKeyPath:@\"name\"];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [animal testKVO]; // 这里如果改为针对类进行hook，则不会存在问题，因为类hook修改的是Animal类，而实例hook修改的是NSKVONotifying_Animal类 [animal aspect_hookSelector:@selector(setName:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, NSString *name)&#123; NSLog(@\"aspects hook setName\"); &#125; error:nil]; // 这里会crash animal.name = @\"ChangedAnimalName\"; &#125;&#125; 异常原因分析图示如下： 上面是继承链和方法调用流程的图示，可以看出，_NSSetObjectValueAndNotify是被aspects__setName:调用的，_NSSetObjectValueAndNotify的内部实现逻辑是取调用它的selector，去父类查找方法，即aspects__setName:方法，而Animal对象并没有这个方法的实现，这就导致了crash。 与category的共存问题先用aspects进行hook，再使用category进行hook，会导致crash。反之则没有问题。样例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@interface Animal : NSObject@property(strong, nonatomic) NSString * name;@end@implementation Animal- (void)setName:(NSString *)name &#123; NSLog(@\"%s\", __func__); _name = name;&#125;@end@interface Animal(hook)+ (void)categoryHook;@end@implementation Animal(hook)+ (void)categoryHook &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [super class]; SEL originalSelector = @selector(setName:); SEL swizzledSelector = @selector(lx_setName:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125;- (void)lx_setName:(NSString *)name &#123; NSLog(@\"%s\", __func__); [self lx_setName:name];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [Animal aspect_hookSelector:@selector(setName:) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, NSString *name)&#123; NSLog(@\"aspects hook setName\"); &#125; error:nil]; [Animal categoryHook]; // 调用后crash：[Animal lx_setName:]: unrecognized selector sent to instance 0x100608dc0 animal.name = @\"ChangedAnimalName\"; &#125;&#125; 这个与__ASPECTS_ARE_BEING_CALLED__的内部逻辑有关，里面会对调用的方法添加前缀aspect__进行调用，以调用到原始的IMP，但是category hook后破坏了这个流程。图示如下： 根据上述图示，实际只有aspects__setName，没有aspects__lx_setName，导致找不到方法而crash 基于类的hook，如果对同一个类同时hook类方法和实例方法，那么后hook的方法调用时会crash。样例代码如下：123456789101112131415161718192021222324252627282930@interface Animal : NSObject- (void)testInstanceMethod;+ (void)testClassMethod;@end@implementation Animal- (void)testInstanceMethod &#123; NSLog(@\"%s\", __func__);&#125;+ (void)testClassMethod &#123; NSLog(@\"%s\", __func__);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Animal *animal = [[Animal alloc] init]; [Animal aspect_hookSelector:@selector(testInstanceMethod) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook testInstanceMethod\"); &#125; error:nil]; [object_getClass([Animal class]) aspect_hookSelector:@selector(testClassMethod) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook testClassMethod\"); &#125; error:nil]; [animal testInstanceMethod]; // crash: \"+[Animal testClassMethod]: unrecognized selector sent to class 0x1000114a0\" [Animal testClassMethod]; &#125;&#125; 这样的调用在日常开发中非常正常，但是它会导致crash。它是由于aspect_swizzleClassInPlace方法中的逻辑缺陷导致的。 1234567891011121314static Class aspect_swizzleClassInPlace(Class klass) &#123; NSCParameterAssert(klass); // Animal类对象与Animal元类对象会得到同一个字符串。 NSString *className = NSStringFromClass(klass); NSLog(@\"aspect_swizzleClassInPlace %@ %p\", klass, object_getClass(klass)); _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) &#123; // 类对象和元类对象得到同一个className，这里后加入的会被错误的过滤掉。 if (![swizzledClasses containsObject:className]) &#123; aspect_swizzleForwardInvocation(klass); [swizzledClasses addObject:className]; &#125; &#125;); return klass;&#125; 从上述代码可以看到，它的去重逻辑只是简单的字符串判断，取Animal的元类和类名得到同一个字符串Animal，导致后添加的被过滤，当调用后被hook的方法后，执行_objc_msgForward，因为后hook的aspect_swizzleForwardInvocation被过滤了没有执行，所以找不到forwardInvocation:的IMP，导致了crash。 _objc_msgForward会出现冲突的问题内部是通过消息转发机制来实现的，使用时要注意，避免与其它使用_objc_msgForward或相关逻辑的框架发生冲突。 性能问题hook后的方法，通过原有消息机制找到IMP后，并不会直接调用。而是会进行消息转发进入到__ASPECTS_ARE_BEING_CALLED__方法，内部再通过key取出相应的Coantiner进行调用，相对于未hook之前，额外增加了调用成本。所以不建议对频繁调用的方法和在项目中大量使用。 线程问题框架内部为了保证线程安全，有进行加锁，但是使用的是自旋锁OSSpinLock，存在线程反转的问题，在iOS10已经被标记为弃用。 对类方法的hook，需要使用object_getClass来获取元类对象进行hook这个不是框架问题，而是有些同学不知道如何对类方法进行hook，这里进行说明。 12345678910@interface Animal : NSObject+ (void)testClassMethod;@end// 需要通过object_getClass来获取元类对象进行hook[object_getClass(Animal) aspect_hookSelector:@selector(testClassMethod) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123; NSLog(@\"aspects hook setName\");&#125; error:null];","tags":[]},{"title":"对独立开发的思考","date":"2021-03-01T04:20:36.000Z","path":"2021/03/01/对独立开发的思考/","text":"独立开发经历第一个小程序项目我在17年的时候买人生的第一套房，是一套二手房，当时对二手房的各项交易费用一知半解，感觉自己就像一头屠宰桌上的猪，任人宰割。刚好那个时候微信小程序开始兴起，基于学习兴趣和需求，做了一个计算购房费用的小程序（在微信上搜索“首付款计算器”可以看到）。做出来后找了一个中介朋友，让他以激活码的方式帮我销售，收入五五分成，他帮我销售了几份后反馈有的客户没法安装（微信版本异常），有的客户有异常问题（非技术问题）。那个时候刚好工作比较忙，又觉得整这些事情太麻烦了（收益低），就没有更新和维护这个项目了。 第二个跨平台项目在20年的时候，由于年龄的逐渐增长，开始考虑去扩展一些额外的收入点。那个时候刚好在学习Flutter，就想用Flutter对之前的项目进行重构，做市面上最专业的购房费用计算器。当时的初衷是想从开发到发布，系统的学习一项新技能，另外就是看能不能赚点钱。但是实际情况和我预想的有点偏差，我增加了很多预想之外的需求。 一开始只想支持长沙的新房和二手房费用计算，但是做到后面想支持北上广深，因为这意味着更大的市场。为了支持不同城市，我对计算层进行了重构，引入了词法分析，支持不同的城市根据配置数据进行费用计算（不同城市的费用不一样），而这又引入了新的问题，配置下发和更新需要接口提供支持。然后我决定用Go开发后台，我自学了Go的语法和Beego框架，然后又学习了Docker，编写了部署脚本，把后台部署在了自己购买的云服务器上面。 后面想到都有接口了，干脆开发一套用户体系，对计算结果进行收藏和管理吧，于是开发了用户体系，对计算层又进行了修改，支持修改和列表显示，加入了版本升级、用户反馈等常规功能。 这些对于技术人来说，都是轻车熟路，不熟悉的地方查查文档也能解决。最麻烦的地方在于不同城市的费用计算规则，一般人觉得购房就是一些税费什么的很简单，但是我当时是想做市面上最专业的购房计算器，需要支持住宅、商业的计算，然后购房者、卖房者有个人（非中国籍、中国籍）、公司（大公司、小公司）、机构等各种情况，实际上是非常复杂的。我伪装成购房者在各大购房平台咨询中介费用问题，但是有些问题中介也不清楚，还有些问题不同中介回复的不一样，最终没有办法，只有跑到当地的房管局进行咨询确认，所以最终这个项目只支持了长沙和深圳的费用计算。 项目完成后iOS端顺利发布到了AppStore，Android端在各大应用商店发布需要软著，后面就没有发了，自己通过云存储部署了一个简单的H5页面来进行Android端的分发。在这里不得不说AppStore的强大，在我没有做推广的情况下，还是有一定的下载量（付费下载），让我收回了购买Apple开发者账号的成本。 对独立开发的反思以上是我做项目的前期，但是我完全没有考虑清楚项目后期的事情，那就是维护和营销。在我们的工作中，经常接触到这两个词，也知道是什么意思，但是在自己的个人项目中，你对这两个词有可能会有完全不一样的理解。我开始思考自己这个项目的意义，是用于学习技术还是为了赚钱？是为了做一个好的产品还是为了炫技？ 所幸我看了一篇公众号文章和软件开发相关的一些思考，作者叫liuyubobobo，我很喜欢的一位开发者。文章中有一小段视频：97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？，我觉得自己就像是这个视频中的程序员，讲着一堆牛逼的技术术语，但实际上却不知道如何做好一个项目。后面经过思考，我发现自己犯了如下错误： 没有想清楚是要学习还是要赚钱。抱着又想学习又想赚钱的想法，两头都没有做好。 盲目的给项目引入了过多的技术，导致后续维护成本很高。个人开发者没有必要维护自己的后台，更没有必要维护一套自建的用户体系，使用对应平台的云接口，稳定，开发效率高。 进入了一个自己不熟悉的领域（房产），我需要学习新的知识，还要跟上数据更新的步伐，不停的去学习。我分析一些做的好的个人开发者，都是做的工具类的软件，不需要把精力花费在陌生领域的学习，可以把精力集中在打磨产品的体验方面。 选择以App的承载方式来做这个项目是错误的，微信小程序才是最好的方案。（给好几个朋友推荐，都是反问，你为什么不做成微信小程序类？） 总结做一个好的产品，应该从用户体验出发，去思考能给用户提供什么？能给用户带来什么？然后再倒推用什么技术，在人力与资源受限时，我们要学会借力于平台，使用稳定可靠的技术。让用户打开我们产品的时候，都会说：太好了，这就是我想要的！而不是坐在那里，想着自己有什么吊炸天的技术，然后怎么把它卖出去。另外关于营销，我觉得其中的学问是不亚于技术的，需要持续的学习和实践，像我17年的小程序项目那样，能找到一个专业的销售人员绑定在一起，对产品的销售是很有帮助的。 附录 个人项目下载地址 97年乔布斯回归苹果时，被程序员当众嘲讽不懂技术，看他如何巧妙回应？ 和软件开发相关的一些思考","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"思考","slug":"思考","permalink":"http://blog.devlxx.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"Flutter定制上下拉刷新功能","date":"2020-07-09T06:45:44.000Z","path":"2020/07/09/Flutter定制上下拉刷新功能/","text":"技术选型项目中需要定制一个基于Gif图片的下拉刷新功能，调研发现Flutter支持上下拉刷新的框架很多，其中有两个比较有名的有flutter_easyrefresh和pull_to_refresh，两个框架功能都很强大，都能满足需求，其中flutter_easyrefresh在github的star更多，lib包大小为644KB，pull_to_refresh在pub.dev的评分更高，lib包大小为172KB，综合考虑后，选择基于pull_to_refresh来实现框架功能。 下拉刷新GIF图片的生成下拉刷新需要控制Gif图片的播放，所以需要引入组件flutter_gifimage，gifimage支持加载本地和网络的gif图片，但是不支持加载图片列表的方式来执行gif动画，所以我们需要将图片列表生成为gif图片（UI小姐姐只给了图片列表）。网上有很多网站可以生成gif，但是都有图片数量限制。 下载一个生成gif的软件来生成又显得很麻烦，我们选择使用Python的Pillow库来创建gif图片。Pillow是PIL的python3版本，功能强大，可以很好的完成需求。创建脚本如下： 12345678910111213141516from PIL import Image, ImageDrawdef gen_frame(path): png = Image.open(path).convert('RGBA') background = Image.new('RGBA', png.size, (255,255,255,0)) alpha_composite = Image.alpha_composite(background, png) return alpha_compositeimage_list = []im0 = gen_frame('refresh_images/Loading_00@2x.png')for i in range(1,57): path = 'refresh_images/Loading_0' + str(i) + \"@2x.png\" image_list.append(gen_frame(path))# 生成透明图片需要加两个个参数：transparency=0, disposal=2im0.save('GIF.gif', save_all=True, append_images=image_list, loop=0, duration=34, transparency=0, disposal=2) 上述脚本对Gif背景进行了处理，以生成一张透明背景的gif图片 Gif下拉刷新组件头部的实现pull_to_refresh中提供了抽象类RefreshIndicator与RefreshIndicator，与material提供的重名，所以需要隐藏。 import部分代码如下： 123import 'package:flutter/material.dart' hide RefreshIndicator, RefreshIndicatorState;import 'package:pull_to_refresh/pull_to_refresh.dart'; 最终下拉刷新的Header实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart' hide RefreshIndicator, RefreshIndicatorState;import 'package:flutter_gifimage/flutter_gifimage.dart';import 'package:pull_to_refresh/pull_to_refresh.dart';class GifHeader extends RefreshIndicator &#123; GifHeader() : super(height: 72.0, refreshStyle: RefreshStyle.Follow); @override _GifHeaderState createState() =&gt; _GifHeaderState();&#125;class _GifHeaderState extends RefreshIndicatorState&lt;GifHeader&gt; with SingleTickerProviderStateMixin &#123; GifController _gifController; @override void initState() &#123; //value可以理解成Gif图片里面的第几帧 _gifController = GifController( vsync: this, value: 0, ); super.initState(); &#125; @override void onModeChange(RefreshStatus mode) &#123; if (mode == RefreshStatus.refreshing) &#123; //min和max都可以理解成Gif图片里面的第几帧，这里表示低0帧到第44帧 _gifController.repeat( min: 0, max: 44, period: Duration(milliseconds: 2000)); &#125; super.onModeChange(mode); &#125; @override Future&lt;void&gt; endRefresh() &#123; return _gifController.animateTo(44, duration: Duration(milliseconds: 500)); &#125; @override void resetValue() &#123; // reset not ok , the plugin need to update lowwer _gifController.value = 0; super.resetValue(); &#125; @override Widget buildContent(BuildContext context, RefreshStatus mode) &#123; return GifImage( image: AssetImage(\"images/pull_refresh.gif\"), controller: _gifController, height: 72.0, ); &#125; @override void dispose() &#123; _gifController.dispose(); super.dispose(); &#125;&#125; 设置Gif的value（帧）时，不能超过Gif的最大帧数，不然超出的帧数是显示一个有颜色的空白页面 集成进入项目pull_to_refresh提供了全局的统一配置类RefreshConfiguration，用它来包裹MaterialApp则可以全局生效，代码如下： 123456789101112131415161718192021Widget build(BuildContext context) &#123; return RefreshConfiguration( headerBuilder: () =&gt; GifHeader(), // 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个 footerBuilder: () =&gt; ClassicFooter(), // 配置默认底部指示器 headerTriggerDistance: 72.0, // 头部触发刷新的越界距离 // springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9), // 自定义回弹动画,三个属性值意义请查询flutter api maxOverScrollExtent: 100, //头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性 maxUnderScrollExtent: 0, // 底部最大可以拖动的范围 enableScrollWhenRefreshCompleted: true, //这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true enableLoadingWhenFailed: true, //在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多 hideFooterWhenNotFull: false, // Viewport不满一屏时,禁用上拉加载更多功能 // 当列表无法充满全屏的时候，加载更多跟在列表后面 shouldFooterFollowWhenNotFull: (status) =&gt; true, enableBallisticLoad: true, // 可以通过惯性滑动触发加载更多 child: MaterialApp( title: 'Flutter Demo', home: HomePage(), ), );&#125; 全局配置好后，则可以在列表进行集成了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:my_flutter/message/notice_list_page/notice_ist_cell.dart';import 'package:my_flutter/message/notice_list_page/notice_list_model.dart';import 'package:pull_to_refresh/pull_to_refresh.dart';class NoticeListPage extends StatefulWidget &#123; @override _NoticeListPageState createState() =&gt; _NoticeListPageState();&#125;class _NoticeListPageState extends State&lt;NoticeListPage&gt; &#123; RefreshController _refreshController = RefreshController(initialRefresh: true); List&lt;NoticeListModel&gt; list = []; void _onRefresh() async &#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 2000)); // 这里可以添加逻辑判断，如果无更多数据：_refreshController.loadNoData(); // 如果加载失败： 设置_refreshController.refreshFailed() _refreshController.refreshCompleted(); setState(() &#123; list = _getList(); &#125;); &#125; void _onLoading() async &#123; // monitor network fetch await Future.delayed(Duration(milliseconds: 1000)); // if failed,use loadFailed(),if no data return,use LoadNodata() _refreshController.loadComplete(); if (mounted) setState(() &#123; list.addAll(_getList()); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SmartRefresher( enablePullDown: true, enablePullUp: list.length &gt; 0, controller: _refreshController, onRefresh: _onRefresh, onLoading: _onLoading, child: ListView.builder( itemBuilder: (c, i) =&gt; NoticeListCell(model: list[i]), itemExtent: 100.0, itemCount: list.length, ), ), ); &#125; List&lt;NoticeListModel&gt; _getList() &#123; return [NoticeListModel(),NoticeListModel()]; &#125;&#125;","tags":[]},{"title":"使用Xcode模板加速及规范开发","date":"2020-06-29T07:26:16.000Z","path":"2020/06/29/使用Xcode模板加速及规范开发/","text":"前言：开发效率和质量是每位开发人员永恒的追求，而Xcode的模板功能可以帮助你更好的达成这个目标，更难能可贵的是它还能在一定程度上帮助你统一实现逻辑和开发规范。 为什么需要使用模板在日常开发中，经常会碰到开发类似功能的情况，我们可以使用面向对象编程的继承来对相同部分进行封装，利用多态来进行特定功能区分，这样可以提高开发效率和质量。当然也有函数式开发和面向协议编程等，但是万变不离其宗，大家都在提模块化，组件化，以提高开发效率、质量、可维护性等。但是不管使用哪种框架和编码方式，都不可能干掉所有的重复代码和重复逻辑，依然会存在很多复制、粘贴等重复操作。例如我们在项目基础框架之上实现两个列表模块A和B，那么A和B模块中大部分的代码文件都是类似的，里面的内容也都是类似的。 为了减少这些重复操作导致的效率低下，我们可以使用Dash或Gist等工具，创建代码片段，来快速的复制粘贴代码，但是这些只限定于单个文件内的文本编辑。如果你所做的项目对某一类功能的实现已经有了固定套路，例如一个常见的列表页面，包含下拉刷新、加载更多等功能，你选择了MVC或MVVM等架构模式，那么在单个项目内，每个列表页面的代码（在一个文件或多个文件中）将会大量相似，每次都要重复的创建类似的文件，写类似的实现。如果是多人开发，还可能会在大体框架基础下搞出好几套大同小异的代码来，而这样的害处是显而易见的。 如何使用模板加速开发？模板工具在软件开发中，要提高效率，就得把重复的工作交给电脑来做，电脑会做的又快又好。针对上面提到的问题，我们完全可以创建一套模板，然后通过脚本或者IDE来批量生成代码，生成代码后，只需要修改其中的少量代码就可以完成全部功能，这样就避免了大量的文件创建和代码复制粘贴操作，也避免了一些由于操作失误导致的bug，同时也避免了一些不同开发人员的不同实现逻辑的问题。 我了解到有两种实现方案： 介绍 | Gckit-CLI Xcode自定义模板 我刚开始是使用的Gckit-CLI工工具，但是发现Xcode原生支持自定义模板后，我转向了使用Xcode自定义模板，因为集成在IDE中使用起来更加的便捷。所以这里我只介绍Xcode自定义模板功能的使用，对Gckit-CLI感兴趣的可以去它的官网自行查看。 Xcode自定义模板的使用Xcode系统默认模板说明Xcode在创建项目或文件时，就是使用了Xcode自带的模板功能。 它包含iOS、watchOS、tvOS、macOS菜单，在iOS菜单下又分为Source、User Interface等类别，类别里面有Cocoa Touch Class、Swift File等模块，图示如下： 这些模板的路径位置如下： iOS 平台模版的位置：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates watchOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates tvOS 平台的模版位置：/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates macOS 平台文件模版的位置：/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates 这里我们仅拿iOS平台模板来进行说明 我们看iOS平台模板的目录结构： 12345678├── File\\ Templates│ ├── Apple\\ Watch│ ├── Playground│ ├── Resource│ ├── Source│ └── User\\ Interface└── Project\\ Templates └── iOS Project\\ Templates是创建项目的模板，这里不做说明。File\\ Templates目录下的内容就是上面图示中iOS菜单下的内容，例如我们根据Source -&gt; Cocoa Touch Class的模板创建文件，会进入如下页面： Xcode模板页面的生成Cocoa Touch Class模板文件目录结构如下 123456789101112131415161718├── File\\ Templates│ ├── Source│ │ ├── Cocoa\\ Touch\\ Class.xctemplate # Cocoa Touch Class模板文件目录│ │ │ ├── NSObjectObjective-C│ │ │ ├── NSObjectSwift│ │ │ ├── TemplateIcon.png│ │ │ ├── TemplateIcon@2x.png│ │ │ ├── TemplateInfo.plist # 根据此文件生成页面和匹配模板目录│ │ │ ├── UICollectionReusableViewObjective-C│ │ │ ├── UICollectionReusableViewXIBObjective-C│ │ │ │ ├── UICollectionReusableViewObjective-C│ │ │ | │ ├── ___FILEBASENAME___.h│ │ │ | │ ├── ___FILEBASENAME___.m│ │ │ | │ ├── ___FILEBASENAME___.xib│ │ │ ├── ...├── ...│ ├── ...... 上述页面对应Cocoa Touch Class.xctemplate目录下的TemplateInfo.plist文件，这个页面是根据此文件生成的。 我们看下TemplateInfo.plist文件的内容（内容太多，只贴出部分，上面的注释是作者添加的）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182··· 省略部分 &lt;dict&gt; # 这里对应中间的子类输入控件 &lt;key&gt;Identifier&lt;/key&gt; &lt;string&gt;cocoaTouchSubclass&lt;/string&gt; &lt;key&gt;Required&lt;/key&gt; # 必须展示这个控件在页面上 &lt;string&gt;YES&lt;/string&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Subclass of:&lt;/string&gt; # 左边的说明文本 &lt;key&gt;Description&lt;/key&gt; &lt;string&gt;What class to subclass in the new file&lt;/string&gt; &lt;key&gt;Type&lt;/key&gt; # UI样式类型是class类型，可以输入值，也可以选择值 &lt;string&gt;class&lt;/string&gt; &lt;key&gt;Default&lt;/key&gt; # 默认选择的值是NSObject &lt;string&gt;NSObject&lt;/string&gt; &lt;key&gt;FallbackHeader&lt;/key&gt; &lt;string&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/string&gt; &lt;key&gt;Values&lt;/key&gt; # 可选择的列表 &lt;array&gt; &lt;string&gt;NSObject&lt;/string&gt; &lt;string&gt;UIView&lt;/string&gt; &lt;string&gt;UIViewController&lt;/string&gt; &lt;string&gt;UITableViewController&lt;/string&gt; &lt;string&gt;UITableViewCell&lt;/string&gt; &lt;string&gt;UICollectionViewController&lt;/string&gt; &lt;string&gt;UICollectionViewCell&lt;/string&gt; &lt;string&gt;UICollectionReusableView&lt;/string&gt; &lt;/array&gt; &lt;key&gt;Suffixes&lt;/key&gt; # 输入匹配相关 &lt;dict&gt; &lt;key&gt;UIViewController&lt;/key&gt; &lt;string&gt;ViewController&lt;/string&gt; &lt;key&gt;UITableViewController&lt;/key&gt; &lt;string&gt;TableViewController&lt;/string&gt; &lt;key&gt;UITableViewCell&lt;/key&gt; &lt;string&gt;TableViewCell&lt;/string&gt; &lt;key&gt;UICollectionViewController&lt;/key&gt; &lt;string&gt;CollectionViewController&lt;/string&gt; &lt;key&gt;UICollectionViewCell&lt;/key&gt; &lt;string&gt;CollectionViewCell&lt;/string&gt; &lt;key&gt;UICollectionReusableView&lt;/key&gt; &lt;string&gt;CollectionReusableView&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;dict&gt; # 对应最底部的语言选择按钮 &lt;key&gt;Identifier&lt;/key&gt; &lt;string&gt;languageChoice&lt;/string&gt; &lt;key&gt;Required&lt;/key&gt; # 必须展示这个控件在页面上 &lt;true/&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Language:&lt;/string&gt; # 左边的说明文本 &lt;key&gt;Description&lt;/key&gt; &lt;string&gt;The implementation language&lt;/string&gt; &lt;key&gt;Type&lt;/key&gt; #UI样式是popup，弹出列表选择值 &lt;string&gt;popup&lt;/string&gt; &lt;key&gt;Default&lt;/key&gt; &lt;string&gt;Objective-C&lt;/string&gt; &lt;key&gt;Values&lt;/key&gt; &lt;array&gt; # 可选择的列表 &lt;string&gt;Swift&lt;/string&gt; &lt;string&gt;Objective-C&lt;/string&gt; &lt;/array&gt; &lt;key&gt;MainTemplateFiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Swift&lt;/key&gt; &lt;string&gt;___FILEBASENAME___.swift&lt;/string&gt; &lt;key&gt;Objective-C&lt;/key&gt; &lt;string&gt;___FILEBASENAME___.m&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;AllowedTypes&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Swift&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.swift-source&lt;/string&gt; &lt;/array&gt; &lt;key&gt;Objective-C&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.objective-c-source&lt;/string&gt; &lt;string&gt;public.objective-c-plus-plus-source&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt;··· 省略部分 模板的匹配用户在上述页面填写和选择了内容后，点击Next创建，就进入了模板匹配逻辑。假如用户在Subclass of选项中输入或选择了UICollectionReusableView，不勾选Also create XIB file勾选框，在Language选项中选择Objective-C，那么Xcode就会将这两个值按顺序拼接起来，得到文件名：UICollectionReusableViewObjective-C，然后会在TemplateInfo.plist文件所在目录中，搜索文件名为UICollectionReusableViewObjective-C的文件夹，如果有就取这个文件夹内模板文件来生成代码（有几个文件就生成几个）。如果没搜索到，就进行默认创建。 模板代码如何生成在上面流程中，已经匹配到了UICollectionReusableViewObjective-C模板，这个模板存在两个文件。 123UICollectionReusableViewObjective-C├── ___FILEBASENAME___.h└── ___FILEBASENAME___.m 其中___FILEBASENAME___.h的内容是： 1234567891011&#x2F;&#x2F;___FILEHEADER______IMPORTHEADER_cocoaTouchSubclass___NS_ASSUME_NONNULL_BEGIN@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___@endNS_ASSUME_NONNULL_END Xcode会使用用户在创建页面输入的类名来替换文件名中的___FILEBASENAME___，使用用户在Subclass of中输入的内容来替换___VARIABLE_cocoaTouchSubclass___，使用之前设置好的文件注释头来替换___FILEHEADER___，全部替换完成后写入文件输出，呈现给用户的就是创建文件完成。到此为止，通过模板创建文件整个流程全部走完了。 Xcode模板的相关配置和字段较多，可以根据里面的内容和展示的页面和行为来猜测每个字段的含义，然后依葫芦画瓢来学习Xcode模板是如何工作的。（如果您有找到这方面的文档，请评论区告诉我） 如何创建Xcode自定义模板自定义模板和系统模板的实现和使用基本是一样的。将自定义模板放在特定目录下时，Xcode就会将自定义模板加载出来。 修改模板后要重启xcode才能生效。 自定义模板的路径是：~/Library/Developer/Xcode/Templates(如果不存在Templates目录，就手动创建一个。)在此路径下，我们创建一个Custom目录，将系统模板中的Cocoa\\ Touch\\ Class.xctemplate目录复制到Custom目录下，这样在工程中新建文件就可以看到自定义的Custom目录及它下面的Cocoa\\ Touch\\ Class模板了： 到了这一步，你就会清楚自定义模板的套路了，剩下的就是依葫芦画瓢来实现自己的模板了。 我根据个人常用编程习惯，创建了一套模板，大家可以下载进行参考。下载地址： GitHub - xx-li/CustomTemplates: Xcode rapid development templates， 使用图示： 后文由于模板的匹配是目录匹配方式，所以每一个选项都会对应一个新的目录，例如一个2*2的选项，就会需要四个模板目录来进行匹配。当我们对模板进行功能细分时，就需要创建大量的模板，而每一个模板可能有大量内容是相似的，修改一个基础逻辑就要对所有的模板文件进行修改。为了解决这种问题，可以使用脚本来创建模板。 在上面的仓库中CustomTemplates，有用Python写的模板生成脚本。因为是用于个人项目，生成的代码缺乏基础框架支持，并不能直接使用，您可以参考编写适用于自己的脚本和模板。 参考资料iOS-VIPER-Xcode-Templates","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"如何创建一个Flutter Plugin","date":"2020-06-15T09:51:00.000Z","path":"2020/06/15/如何创建一个Flutter-Plugin/","text":"什么是pluginFlutter和Dart生态系统的软件包有两种模板，分别是packages和plugin，其中plugin包含Android、iOS平台特定实现，一般需要Flutter端与Android或iOS进行通讯交互（类比Hybrid或RN中JS与Native的交互），以实现特定功能。 创建plugin一般使用命令创建Plugin：flutter create —org com.example —template=plugin hello，执行命令后，会在当前目录下生成一个hello文件夹，里面是一个plugin的简单demo实现。iOS可以使用OC和Swift，Android可以使用Java和kotlin进行代码编写，命令默认使用swift及kotlin，如需修改，使用-i及-o命令。例如要创建一个使用OC及java的plugin，命令为：flutter create —org com.example —template=plugin -a java -o objc hello。 平台通道数据类型及编解码器在平台通道进行数据传输时，Flutter它会自动对这些值进行序列化和反序列化。 下表展示了如何在平台端接收 Dart 值，反之亦然： 创建一个样例Demo为了更好的说明流程，这里创建一个禁用截屏功能的plugin进行说明，plugin提供三个功能：全局添加水印、截屏监控、禁用截屏。其中全局添加水印为在Flutter当前页面栈的最上层添加一个半透、有水印、穿透触摸事件的全遮盖页面，为纯dart实现，不需要与平台进行交互； 截屏监控为当平台监听到截屏行为后，立即通知Flutter端，是一个持续通讯的过程；禁用截屏为Flutter端通知平台执行禁用操作（只支持Android平台）。此plugin已经开发完成并发布到官方pub，可以在GitHub - disable_screenshots下载并查看源码。 创建命令：flutter create --org com.devlxx --template=plugin disable_screenshots 执行命令后会生成如下目录：1234567891011├── disable_screenshots│ ├── CHANGELOG.md│ ├── README.md│ ├── android│ ├── disable_screenshots.iml│ ├── example│ ├── ios│ ├── lib│ ├── pubspec.lock│ ├── pubspec.yaml│ └── test pubspec.yaml：plugin的配置文件。里面有字段：name、description、version、homepage，这些均是字面意思，很好理解。另外有字段environment，指定插件的使用环境，最关键的是有一个flutter字段： 12345678910111213# The following section is specific to Flutter.flutter: # This section identifies this Flutter project as a plugin project. # The &#39;pluginClass&#39; and Android &#39;package&#39; identifiers should not ordinarily # be modified. They are used by the tooling to maintain consistency when # adding or updating assets for this project. plugin: platforms: android: package: com.devlxx.disable_screenshots pluginClass: DisableScreenshotsPlugin ios: pluginClass: DisableScreenshotsPlugin 这个字段说明了plugin支持的平台以及各平台的入口class，这个需要能一一对应。默认会给你创建好，不要随意修改这里及类名即可。 README.md : 项目说明。当发布到官方的pub.dev后，插件的Readme栏目内容即为此文件内容。 lib：pluginFlutter端的实现 ios：pluginios端的实现 android：pluginandroid端的实现 example：plugin的使用demo，可以运行此demo进行测试，另外demo里面也有README.md文件，当发布到官方的pub.dev后，插件的Example栏目内容即为此文件内容。 Flutter与iOS、Android通讯原理Flutter只是一个UI框架，与平台相关的功能只能由平台来原生实现，这就需要Flutter与原生进行相互通讯。它们通过PlatformChannel进行互相通讯，核心原理是： Flutter通过PlatformChannel将要传递的数据编码后，跨线程发送到宿主（iOS或Android） 宿主接收到PlatformChannel的消息后，执行原生API。 宿主执行完原生API后，将数据编码并原路返回给应用程序的Flutter部分图示如下： PlatformChannel有三种类型，分别是：BasicMessageChannel、MethodChannel、EventChannel。其中BasicMessageChannel接收一个MessageCodec作为其编解码器的实现，允许我们使用自定义的消息编解码进行异步消息传递，这里不对其做说明。 - `MethodChannel`：用于Flutter主动调用平台端的方法，并获得相应的返回值，例如获取系统电量、发起Toast等，可以说是“一次性”的调用。这里将通过它来告知平台端禁用截屏功能 - `EventChannel`，用于传递事件。例如Flutter要监听电量变化，平台端可以将监听到的电量变化情况持续的通过`EventChannel`传递给Flutter端。这里将通过它来`截屏监控`功能。disable_screenshots的禁用截屏功能实现（MethodChannel） Flutter端实现创建命令会在lib目录下生成一个disable_screenshots.dart文件，里面会有一个默认的MethodChannel实现样例，我们对其进行修改，修改后的核心源码如下： 12345// 1. 创建一个MethodChannelfinal MethodChannel methodChannel = const MethodChannel(\"com.devlxx.DisableScreenshots/disableScreenshots\");// 2. 通过MethodChannel将方法名和参数编码后发到平台端methodChannel.invokeMethod(\"disableScreenshots\", &#123;\"disable\": disable&#125;); Android端实现（kotlin）创建命令会在android目录下的/src/main/kotlin/com/devlxx/disable_screenshots/生成一个DisableScreenshotsPlugin.kt文件，其中实现禁用截屏的核心代码为： 1234567891011121314151617181920212223242526private fun onAttachedToEngine(applicationContext: Context, messenger: BinaryMessenger) &#123; this.applicationContext = applicationContext // 1. 创建一个MethodChannel this.channel = MethodChannel(messenger, \"com.devlxx.DisableScreenshots/disableScreenshots\") //handle指向了this，this必须实现onMethodCall方法 this.channel.setMethodCallHandler(this)&#125;// 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) &#123; if (call.method == \"disableScreenshots\") &#123; var disable = call.argument&lt;Boolean&gt;(\"disable\") == true // 禁止截屏需要获取到当前的activity，如何获取到activity请自行查看源码，这里不做说明。 if (disable) &#123; activity.window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); println(\"禁用截屏\") &#125; else &#123; // 允许截屏 activity.window.clearFlags(WindowManager.LayoutParams.FLAG_SECURE) println(\"允许截屏\") &#125; // 调用后，Flutter端的invokeMethod会收到调用的结果，结果为一个空字符串 result.success(\"\") &#125; else &#123; result.notImplemented() &#125;&#125; iOS端实现。（iOS无法实现禁止截屏功能，这里仅做说明）创建命令会在ios目录下的Classes/下生成一个DisableScreenshotsPlugin.swift文件，其中实现禁用截屏的核心代码为： 12345678910111213141516171819202122232425262728293031public class SwiftDisableScreenshotsPlugin: NSObject &#123; public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建一个MethodChannel let methodChannel = FlutterMethodChannel(name: \"com.devlxx.DisableScreenshots/disableScreenshots\", binaryMessenger: registrar.messenger()) registrar.addMethodCallDelegate(instance, channel: methodChannel) &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterPlugin &#123; // 当Flutter端的MethodChannel调用invokeMethod时，它的参数会传递到这里 public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) &#123; /* //iOS平台无法实现禁用截屏功能，这里仅做MethodChannel的使用说明 if call.method == \"disableScreenshots\" &#123; if let arg = call.arguments as? Dictionary&lt;String, Any&gt;, let disable = arg[\"disable\"] as? Bool &#123; if disable &#123; //禁用截屏 &#125; else &#123; //允许截屏 &#125; &#125; else &#123; print(\"【SwiftDisableScreenshotsPlugin】disableScreenshots 收到错误参数\") &#125; &#125; else &#123; result(FlutterMethodNotImplemented) &#125; */ result(FlutterMethodNotImplemented) &#125;&#125; disable_screenshots的截屏监控功能实现（EventChannel） Flutter端实现 1234567// 1. 创建EventChannelfinal EventChannel eventChannel = const EventChannel('com.devlxx.DisableScreenshots/observer');// 2. 监听平台端发来的事件_eventChannel.receiveBroadcastStream().listen((event) &#123; //平台端发来事件后会调用到这里&#125;); Android端实现 12345678910111213141516171819202122232425// 1. 创建EventChannelval eventChannel = EventChannel(messenger, \"com.devlxx.DisableScreenshots/observer\")// 2. handle指向了this，this必须实现onListen及onCancel方法。eventChannel.setStreamHandler(this)//3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端override fun onListen(arguments: Any?, events: EventChannel.EventSink?) &#123; println(\"开始监听\") // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. ScreenShotListenManager为一个实现了监听截屏功能的Manager screenShotListenManager = ScreenShotListenManager.newInstance(applicationContext) screenShotListenManager.setListener &#123; imagePath -&gt; println(\"监听到截屏，截屏图片地址是：$imagePath\") // 6. 发送事件给Flutter端，告知监听到了截屏行为。 eventSink?.success(\"监听到截屏行为\") &#125; screenShotListenManager.startListen()&#125;// EventChannel被取消override fun onCancel(arguments: Any?) &#123; screenShotListenManager.stopListen() eventSink = null&#125; iOS端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SwiftDisableScreenshotsPlugin: NSObject &#123; var eventSink: FlutterEventSink? // 注册使用此插件 public static func register(with registrar: FlutterPluginRegistrar) &#123; let instance = SwiftDisableScreenshotsPlugin() // 1. 创建EventChannel let channel = FlutterEventChannel( name: \"com.devlxx.DisableScreenshots/observer\", binaryMessenger: registrar.messenger() ) // 2. 设置handler为SwiftDisableScreenshotsPlugin，它必须实现onListen及onCancel方法 channel.setStreamHandler(instance) &#125; 6. 发送事件给Flutter端，告知监听到了截屏行为。 @objc func callScreenshots() &#123; eventSink!(\"监听到截屏行为\") &#125;&#125;extension SwiftDisableScreenshotsPlugin: FlutterStreamHandler &#123; //3. 获取到EventChannel.EventSink后，可以通过它发送事件给Flutter端 public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? &#123; // 4. 需要将events存起来，后续需要通过它将事件发送给Flutter端 eventSink = events // 5. iOS端实现截屏监听功能很简单，添加相应通知的监听即可。 NotificationCenter.default.addObserver( self, selector: #selector(callScreenshots), name: UIApplication.userDidTakeScreenshotNotification, object: nil) return nil &#125; // EventChannel被取消 public func onCancel(withArguments arguments: Any?) -&gt; FlutterError? &#123; NotificationCenter.default.removeObserver(self) eventSink = nil return nil &#125;&#125; 综合MethodChannel及EventChannel的三端实现来看，它们的使用还是比较简单的，对于开发者来说，挑战在于需要对三端都熟悉，并写出高质量的代码。在实际开发时，可以先用相应的开发者工具打开Example目录下的iOS及Android的项目，分别进行平台特定代码的开发、调试。当iOS及Android的平台代码编写完成后，再直接运行Example项目，进行Flutter端的功能开发及整体的调试。 全局添加水印全局添加水印不涉及平台端，为纯Flutter端实现。和常规的Flutter Dart代码编写没什么差异，这里不做说明，具体实现可以直接查看源码。 发布plugin当plugin的三端代码写好后，需要进行发布。plugin的发布非常简单，分为两步。第一步为检查项目是否OK，执行命令：flutter packages pub publish --dry-run后，会提示项目是否存在遗漏或者异常部分，如果有异常，根据提示进行修复即可。例如此项目在执行此命令时，有提示存在问题： 12Package validation found the following potential issue:* Your pubspec.yaml includes an &quot;author&quot; section which is no longer used and may be removed. 这个是Flutter的一个bug，默认创建的模板会包含一个author字段，但是却无法检查通过，将pubspec.yaml中的author字段删除即可检查通过。 检查通过后，可以执行第二步，执行命令：flutter packages pub publish进行发布。执行后，根据命令行会提示进行操作，需要注意的是有一个验证身份的操作，将命令行出现的网址在浏览器中打开，然后在此页面登录自己的Google账号，这样就会将这个plugin与你的账号进行绑定及身份验证，操作完成后即发布成功，命令行输出如下所示： 12345678910Do you want to publish disable_screenshots 0.0.1 (y&#x2F;N)? yPub needs your authorization to upload packages on your behalf.In a web browser, go to https:&#x2F;&#x2F;accounts.google.com&#x2F;o&#x2F;oauth2&#x2F;auth?access_type&#x3D;offline&amp;approval_prompt&#x3D;force&amp;response_type&#x3D;code&amp;client_id&#x3D;81fds5108-8grd2eg9tj9f38os6f1urbcvsq399u8n.apps.googleusercontent.com&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A54755&amp;scope&#x3D;openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.emailThen click &quot;Allow access&quot;.Waiting for your authorization...Authorization received, processing...Successfully authorized.Uploading...Successfully uploaded package. plugin发布成功后并不能立即在官方的pub中搜到，它需要一段时间来处理，但是可以直接输入地址看到：https://pub.dev/flutter/packages?q=disable_screenshots 发布失败问题处理有时候会上传失败，提示Failed to upload the package。失败有可能是如下几种情况导致： 网络问题以为package是发布到google的服务器上，如果无法科学上网，肯定是会失败的。有些同学开启代理后依然无法上传成功，那么需要检查终端是否走的代理（终端默认不走代理）。此时需要给终端设置代理，也就是命令行代理。在mac平台中，在.bash_profile文件中加入如下代码： 1234567891011# 终端走代理function proxy_on()&#123; export http_proxy=http://127.0.0.1:1087 #填写您本地的实际代理端口 export https_proxy=http://127.0.0.1:1087 #填写您本地的实际代理端口 echo -e \"已开启代理\"&#125;function proxy_off()&#123; unset http_proxy unset https_proxy echo -e \"已关闭代理\"&#125; 重新打开终端后使用proxy_on，即可开启命令行代理。当然你也可以使用软路由科学上网等其他方式让所有程序都走代理。 镜像配置导致的问题很多同学使用pub的国内镜像来提高package拉取的速度，但是这些镜像设置会导致上传失败。 上传时将这些镜像配置关闭即可。 权限问题一直失败无法找到原因时，可以使用命令flutter packages pub publish --verbose显示详细log，以分析问题出现的原因。例如有时候会出现异常log：HTTP response 400 Bad Request for POST https://storage.googleapis.com，这个并不是网络问题导致的，而是权限问题，添加subo执行：sudo flutter packages pub publish --verbose 。 即可上传成功 其它情况如果上述操作都无法解决问题，可以去官方仓库的issue中查找答案或提问。 引用pluginplugin开发完后，我们可以选择多种方式将plugin提供给其它开发者使用： - 从本地路径引入 - 从Git仓库引入 - 从官方pub引入（需要先发布到官方pub） - 从指定源引入 本地路径引入plugin中的Example引入plugin就是通过本地路径方式引入的，这种方式很方便本地修改和调试，进入方式如下： 123456dependencies: flutter: sdk: flutter disable_screenshots: # 当前pubspec.yaml文件的上一级目录是plugin所在目录 path: ../ 从Git仓库引入顾名思义，直接从Git仓库拉取plugin，可以指定分支及路径。企业内部引用可以使用此种方式。样例如下： 1234567dependencies: flutter: sdk: flutter disable_screenshots: git: url: https://github.com/xx-li/disable_screenshots path: path/to/disable_screenshots #这里只做说明，实际disable_screenshots插件在根目录，不需要指定路径。 官方pub引入及指定源引入这里不做说明，详情可以看官方教程：Using packages - Flutter问题备忘 在老的flutter项目中，在iOS平台运行可能出现编译问题无法运行。这个是由于老的flutter项目里面没有使用到swift，所以没有briging文件，但是插件使用了swift，所以会编译失败，这种情况直接使用xcode在iOS项目中创建一个swift文件，会自动生成briding文件。 参考资料 GitHub - huiger/ScreenShotDemo: 🔥Android 手机应用内截屏, 截屏监听 Experimental: Create Flutter Plugin · flutter/flutter Wiki · GitHub Using packages - Flutter Developing packages &amp; plugins - Flutter Writing custom platform-specific code - Flutter Flutter 开发（14）：BasicMessageChannel 的使用 | 肥言肥语 dart - How to get Activity and Context in Flutter plugin - Stack Overflow https://stackoverflow.com/questions/28606689/how-to-prevent-screen-capture-in-android","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.devlxx.com/tags/Flutter/"}]},{"title":"WKWebView的Cookie问题","date":"2018-05-08T11:46:41.000Z","path":"2018/05/08/WKWebView的Cookie问题/","text":"WKWebView与App不在同一个进程运行，不会从App的标准Cookie容器NSHTTPCookieStorage读取Cookie。跨进程的数据同步是一个麻烦及容易出现问题的场景，Apple在iOS11之前没有专门的API用于Cookie操作，在iOS11之后提供了WKHTTPCookieStore，但是自测发现存在一些奇怪的bug，无法使用，此部分后续会做说明。 网上关于WKWebView的Cookie同步我有查到多种方案，但是均无法解决跨域请求的Cookie问题，后来发现使用WKProcessPool可以解决跨域问题。 UIWebView为什么没有Cookie同步问题？网络请求完成后，会返回一个Response，如果Response中带有Set-Cookie字段，如：&quot;Set-Cookie&quot; = &quot;wifi_jsessionid=3aea4df28ab14b4e8714132cb911c15a; Domain=.pingan.com.cn; Path=/&quot;;，操作系统就会将此条Cookie信息写入到NSHTTPCookieStorage中 当UIWebView中有任意请求时（App进程中的请求也是一样），会去NSHTTPCookieStorage查找对应的Cookie信息，如果存在符合条件的Cookie信息，就会在请求头中带上此条Cookie信息。所以UIWebView进行跨域请求是没有任何问题的，只要NSHTTPCookieStorage有符合条件的Cookie信息即可带上。 WKWebView Cookie同步一般解决方案WKWebView上请求不会自动带上NSHTTPCookieStorage中的Cookie, 目前的主要解决方案是通过手动的方式直接在请求头上带上Cookie或者使用JS脚本进行Cookie注入： 在请求头中设置Cookie, 解决首个请求Cookie带不上的问题:12345WKWebView * webView = [WKWebView new]; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://h5.qzone.qq.com/mqzone/index\"]]; [request addValue:@\"skey=skeyValue\" forHTTPHeaderField:@\"Cookie\"]; [webView loadRequest:request]; 此方法只适合解决简单针对性的场景。 通过document.cookie设置Cookie解决后续页面(同域)Ajax、iframe请求的Cookie问题:12345678910WKUserContentController* userContentController = WKUserContentController.new;//不设定Domain，则会将domain默认设为请求的URL的DomainWKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @\"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';\" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];// again, use stringWithFormat: in the above line to inject your values programmatically[userContentController addUserScript:cookieScript];WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;webViewConfig.userContentController = userContentController;WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig]; 设定Cookie的辅助方法: 123456789101112- (NSString *)cookieString &#123; NSString *string = [NSString stringWithFormat:@\"%@=%@;domain=%@;path=%@\", self.name, self.value, self.domain, self.path ?: @\"/\"]; if (self.secure) &#123; string = [string stringByAppendingString:@\";secure=true\"]; &#125; return string;&#125; 因为Cookie注入无法跨域，此方法无法解决跨域请求的Cookie问题。 WKProcessPool同步方案解决跨域问题苹果开发者文档对WKProcessPool的定义是：A WKProcessPool object represents a pool of Web Content process. 通过让所有WKWebView共享同一个WKProcessPool实例，可以实现多个 WKWebView之间共享Cookie（session Cookie and persistent Cookie）数据。 既然可以多个WKWebView共享一个WKProcessPool实例，那么是不是可以先访问跨域的URL，将Cookie注入，不就得到了一个有跨域Cookie的WKProcessPool实例吗？再用此实例去访问原始的Web页面，不就可以解决跨域访问的Cookie问题了吗？ 经过实测，此方案是OK的。 样例如下： 可以创建一个单例管理WKProcessPool。如果Cookie更新了，更新WKProcessPool即可同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)updateProcessPool &#123; _isUpdatePooling = YES; if (_webView) &#123; _webView.navigationDelegate = nil; [_webView removeFromSuperview]; _webView = nil; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(willUpdateCookieWithPool)]) &#123; [_delegate willUpdateCookieWithPool]; &#125; //JS注入 NSString *jsStr = [self updateCookieScriptString]; //JS注入的domain（跨域注入会失败） NSURL *url = [NSURL URLWithString:@\"http://www.pingan.com.cn/\"]; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:jsStr injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; WKUserContentController* userContentController = WKUserContentController.new; [userContentController addUserScript:cookieScript]; WKWebViewConfiguration* configuration = WKWebViewConfiguration.new; configuration.userContentController = userContentController; configuration.processPool = self.pool; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration]; [[UIApplication sharedApplication].keyWindow addSubview:webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:3]; webView.navigationDelegate = self; [webView loadRequest:request]; _webView = webView;&#125;#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; LOG_INFO(\"WEB\", @\"didFinishNavigation :%@\", navigation); webView.navigationDelegate = nil; [webView removeFromSuperview]; @synchronized(self) &#123; for (void(^block)(WKProcessPool *pool) in _handlers) &#123; block(_pool); &#125; [_handlers removeAllObjects]; _isUpdatePooling = NO; &#125; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(didUpdateCookieWithPool)]) &#123; [_delegate didUpdateCookieWithPool]; &#125; &#125;#pragma mark -- (void)getCookieWithProcessPoolHandler:(void(^)(WKProcessPool *pool))handler &#123; if (_isUpdatePooling) &#123; [_handlers addObject:handler]; &#125; else &#123; handler(_pool); &#125;&#125; 由于WKProcessPool只能在初始化时传入有效，所以调用有一点特殊： 123456789101112131415161718@weakify(self);PAWFWebProcessPoolManager *cookieManager = [PAWFWebProcessPoolManager sharedManager];[cookieManager getCookieWithProcessPoolHandler:^(WKProcessPool * _Nonnull pool) &#123; @strongify(self); self.webView = [self creatWebViewWithPool:pool]; [self.view addSubview:self.webView]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:self.URL]; [self.webView loadRequest:request];&#125;];- (WKWebView *)creatWebViewWithPool:(WKProcessPool *)pool &#123; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init]; configuration.processPool = pool; CGRect frame = CGRectMake(0, 0, kScreenWidth, CGRectGetHeight(self.contentView.frame) - kGrwonStatusBarHeight); WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:configuration]; wkWebView.navigationDelegate = self; return wkWebView;&#125; WKHTTPCookieStore同步cookie问题WKHTTPCookieStore，存在一些奇怪的bug，完全无法使用，已知问题如下： 无法正常写入cookie的Bug：12345678910111213141516NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@\"wifi_jsessionid\" forKey:NSHTTPCookieName];[cookieProperties setObject:jsessionid forKey:NSHTTPCookieValue];[cookieProperties setObject:@\".pingan.com.cn\" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@\"\" forKey:NSHTTPCookieOriginURL];[cookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath];[cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore];[store.httpCookieStore setCookie:cookie completionHandler:^&#123; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; //读取不到写入的cookie。 &#125;]; &#125;]; 使用迂回方式解决写入问题： 123456789101112//添加observer代理[store.httpCookieStore addObserver:self];//注意：网络不畅通时，存在不回调的情况。网络ok后才会调用。原因不明- (void)cookiesDidChangeInCookieStore:(WKHTTPCookieStore *)cookieStore &#123; WKWebsiteDataStore *store = [WKWebsiteDataStore defaultDataStore]; [store.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123; LOG_INFO(\"WEB\", @\"cookiesDidChangeInCookieStore: %@\", cookies); //参考链接：https://forums.developer.apple.com/thread/97194 //此时才能看到Cookie被写入了 &#125;];&#125; cookie添加成功后，WKWebVie无法使用WKWebsiteDataStore中的cookie信息。详情可见：#140191 自测添加跨域的cookie, Cookie添加成功后进行跨域访问，cookie无法生效。 自测添加正常cookie也无法生效。 参考资料 Can I set the cookies to be used by a WKWebView? WKWebView 那些坑","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"}]},{"title":"iOS crash文件符号化","date":"2018-02-27T02:47:42.000Z","path":"2018/02/27/iOS-crash文件符号化/","text":"carsh文件符号化需要symbolicatecrash脚本、.crash文件、产生crash的app对应的.dSYM文件。脚本可以通过.dSYM文件对.crash文件进行格式化。 资源准备查找symbolicatecrash脚本执行命令：find /Applications/Xcode.app/ -name symbolicatecrash， 返回 1234/Applications/Xcode.app//Contents/Developer/Platforms/WatchSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash/Applications/Xcode.app//Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 找到四个结果，随意使用一个即可，这里使用：/Applications/Xcode.app//Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash 提取crash文件 连上发生crash的手机，在Xcode的Window -&gt; Devices and Simulator 下，选中发生crash的设备，点击View Device Logs按钮 找到对应的crash日志，点击右键，选择Export Log导出。 不是所有的crash，都能产生crash日志。 没有crash日志只能通过其它方式debug. 提取dSYM文件 如果是xcode上打的包，在Xcode的Window -&gt; Organizer下，选中对应的app 选中对应的包，点击右键，选择Show in Finder，找到对应的.xcarchive文件 点击右键，选择显示包内容，在dSYMs文件夹中找到对应的.dSYM文件 如果使用脚本打包，注意.dSYM文件的存档 格式化 建立目录，将上述三个文件放入同一个目录 进入指定目录，执行./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash，会生成格式化的crash文件。 如果出现报错Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.执行export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer修复。","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.devlxx.com/tags/iOS/"}]},{"title":"Github Pages搭建博客及使用","date":"2018-01-08T12:33:20.000Z","path":"2018/01/08/Github-Pages搭建博客及使用/","text":"Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文基于Hexo进行说明。 环境搭建安装 确保电脑中是安装有Node.js、Git hexo安装：npm install -g hexo-cli 建站执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo配置在 _config.yml 中修改大部份的配置。配置说明见官方文档 主要配置参数： 网站 12345title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言 配置对应的Github Pages 1234deploy: type: git repository: https://github.com/StudyData/StudyData.github.io branch: master 网址 1url: http:&#x2F;&#x2F;blog.devlxx.com 配置评论 12disqus_shortname: devlxxdisqus: true 日常用法 创建新博文：$ hexo new [layout] &lt;title&gt;，如hexo new &quot;Github Pages搭建博客及使用，执行后，会在source/_posts目录下创建hexo new &quot;Github Pages搭建博客及使用.md文件 创建草稿使用特殊布局：draft, 建立时会保存在source/_drafts文件夹，可以执行$ hexo publish [layout] &lt;title&gt;移动到source/_posts目录 生成静态文件：hexo generate 本地查看：hexo server -p 5000，执行后，打开http://localhost:5000/即可查看博客效果。 部署：hexo deploy 可以通过在文章中插入&lt;!--more--&gt;来设置在文章列表中展示的内容。&lt;!--more--&gt;上面内容均会展示在在列表中，下面的会被收起。（for yilia 主题） 进阶域名绑定使用自己的域名逼格更高，域名绑定需要做两部分工作。 Github Pages域名绑定设置使用一个自定义域名去重定向你的 GitHub Pages，你必须创建和提交一个包含自定义域名的 CNAME 文件到你的 GitHub Pages 存储库中。 进入Github Pages仓库：https://github.com/StudyData/StudyData.github.io 添加一个新文件，命名为 CNAME （全部大写！），放在 Pages 分支的根目录下。 在新文件中，添加一行，指定自定义域名的空子域名。例如，使用 blog.example.com 而不是 https://blog.example.com 。 请注意，在 CNAME 文件中只允许有一个域名。 域名服务商设置以万网为例 点击添加解析 记录类型：CHAME 主机记录：blog 记录值：studydata.github.io 添加评论hexo支持各种评论，常见的有1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment等，评估那个适合自己，申请相关服务后在根目录的_config.yml中进行配置，如： 12disqus_shortname: devlxxdisqus: true 畅言对国内支持较好，可以微信，QQ登录，配置如下： 1234#畅言app idchangyan_appid: 'xxxx'#畅言app keychangyan_conf: 'xxxxxxxxxxxxxxxxxx' 资源文件使用 在根目录的_config.yml中进行配置: 1post_asset_folder: true 每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们 也可以在source目录下创建一个资源目录assets，然后通过类似于![](/assets/image.jpg)的方法访问它们。 如何更换主题主题都放置在themes/目录下，一般从github上找到自己心仪的主题，clone到此目录下。然后在_config.yml配置相应的主题。 如： 1theme: hexo-theme-yilia hexo-theme-yilia为clone下来的项目的文件名。 如何使用主题每个主题基本都有自己说明文档，一般通过修改主题中的themes/theme_name/_config.yml文件来实现主题修改。 问题处理 有人会把整个hexo目录放入GitHub Pages仓库，这是不对的，指定hexo d会将生成的博文相关静态文件上传到Github Pages，hexo目录一般用另外一个私有仓库放置，里面可以有你的草稿，主题等。 执行hexo d会将仓库先清空，如果有加入CNAME文件也会被清空，可以将CNAME放入source/目录下，上传的时候会一并传上去。 执行hexo g出现警告WARN No layout:xxx，然后执行hexo s运行本地博客无内容。解决方法： 是否配置的主题在theme下存在，检查下themes/themeName/layout/文件夹里是否有index.js文件，以及目录结构是否与实际主题的layout保持一致 执行hexo g报错：Error: The module &#39;/Users/lixinxing/Documents/BlogBackup/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#39; was compiled against a different Node.js version using 一般是node的版本发生了变化，删除目录下的node_modules文件，然后执行npm install重新安装即可。 依然不行，可以执行npm i -g hexo-cli再跑跑试试。 执行hexo g报错：ERROR Plugin load failed: hexo-generator-json-content 可能是node版本过低，升级node版本即可。 hexo将整个目录都上传了上去，一般是设置了submodule导致的。 把.deploy_git文件夹删除 执行hexo clean删除public目录后，再重新执行命令上传即可。 相关资料 hexo官方文档 hexo主题yilia","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"WEB","slug":"WEB","permalink":"http://blog.devlxx.com/tags/WEB/"}]},{"title":"iOS的ipa包重签名","date":"2016-04-23T10:39:18.000Z","path":"2016/04/23/iOS的ipa包重签名/","text":"日常开发中，我们需要一个Apple账号用于发布App到AppStore，一个企业账号用于内部发布测试及给客户演示。但是Apple限制Bundle Identifier是不能重复的。所以我们有时候需要使用企业证书对个人证书发布的ipa包进行重签名。(注：当然你也可以用于其他用途，但是有被Apple封杀的风险) 模拟数据为了能对整个流程进行更好的说明，这里设置一些模拟数据 App 在AppStore的Bundle Identifier:com.test.AppStore 企业证书的名称：iPhone Distribution: Shenzhen Test Technology Co., Ltd. 企业证书对应的Prefix：828E9CDH56 企业账号用于发布的Provisioning Profiles文件名：TestDistributionForEnterprise.mobileprovision 企业账号用于发布的Provisioning Profiles对应的Bundle Identifier：com.test.enterprise 注：如果重签名后需要支持消息推送服务，需要把对应的Identifiers勾选Push Notifications服务 重签名流程创建entitlements.plist授权文件 entitlements.plist文件内容123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;keychain-access-groups&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;828E9CDH56.*&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;key&gt;get-task-allow&lt;&#x2F;key&gt; &lt;false&#x2F;&gt; &lt;key&gt;application-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56.com.test.enterprise&lt;&#x2F;string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;&#x2F;key&gt; &lt;string&gt;828E9CDH56&lt;&#x2F;string&gt; &lt;key&gt;aps-environment&lt;&#x2F;key&gt; &lt;string&gt;production&lt;&#x2F;string&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 图示如下： ipa文件处理 使用个人账号证书打包（和往常上传AppStore一样操作），导出ipa文件，文件名为test.ipa。 将test.ipa后缀改成zip并进行解压得到一个文件Payload 删除Payload/test.app/_CodeSignature 以及 Payload/test.app/embedded.mobileprovision两个文件 替换证书配置文件（文件名为embedded，不能自定义）1cp TestDistributionForEnterprise.mobileprovision Payload&#x2F;test.app&#x2F;embedded.mobileprovision 重签名（certifierName为重签名证书文件名，有证书Prefix后缀需要加后缀，以钥匙串里的为准）12certifierName&#x3D;&quot;iPhone Distribution: Shenzhen Test Technology Co., Ltd.&quot;codesign -f -s $certifierName --entitlements entitlements.plist Payload&#x2F;test.app 打包1zip -r resignTest.ipa Payload 这样就得到了一个新的文件resignTest.ipa，可以企业发布给任何人安装，同时Bundle Identifier依然是com.test.AppStore 注意：1、如果不在Payload所在目录进行打包，如xxx/Payload，则会导致打包出来的安装包无法安装，原因不明。2、如果之前有安装过对应App测试版本，会导致安装失败，可能是缓存导致的问题。 Extension支持在iOS开发中，Extension越来越多，尤其是很多app添加了Today Extension，在重签名的时候需要对extension进行处理，如果有多个extension，那么每个extension都要做重签名处理。对extension进行重签名流程如下： 找到PlugIns目录下对应的Extension文件 与对app进行重签名一样，删除Extension里面的_CodeSignature目录，删除embedded.mobileprovision文件。 使用codesign命令进行重签名，证书与主app一致。命令也一样，修改对应的entitlements.plist和指定目录即可。 例：codesign -f -s $certifierName --entitlements extension_entitlements.plist Payload/test.app/PlugIns/extension.appex 这里有两个注意事项： 先对Extension进行签名，再对主app进行签名，不然会报错说codesign内容被修改之类的错误 重签名的时候注意证书的传参，如果对证书名字中有空格又没有用””引起来，会导致找不到证书。 如果报错This application&#39;s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed.，那么应该是安装了一个同样bundle id的app， 把它删掉重新安装就可以了。 企业发布 按照常规的企业发布方式来即可 注意：1、企业发布后出现在有些机型可以安装成功，有些机型安装失败，刚开始怀疑是打的包有问题，后来发现是由于用于安装的plist文件里面的display-image以及full-size-image链接有问题，修复后OK2、如果出现有的手机能安装， 有的手机不能安装， 那可能是.mobileprovision没有被正确替换导致的。 开源项目我把整个流程用Python做了一个脚本，功能流程如下 打包ipa–&gt;重签名–&gt;上传服务器–&gt;发送邮件，点此可以下载。 相关链接代码签名探析","tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://blog.devlxx.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"逆向","slug":"逆向","permalink":"http://blog.devlxx.com/tags/%E9%80%86%E5%90%91/"}]}]